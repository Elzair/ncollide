var searchIndex = {};
searchIndex["ncollide"] = {"doc":"ncollide\n========","items":[[8,"FloatError","ncollide::math","Trait for constant helping handling floating point computations.",null,null],[10,"epsilon","","Epsilon value used to perform fuzzy comparisons with zero.",0,{"inputs":[],"output":{"name":"self"}}],[8,"Scalar","","Trait implemented by scalar types.",null,null],[8,"Point","","Trait implemented by point types.",null,null],[16,"Vect","","Type of a point&#39;s tangent space element, i.e., the vector type.",1,null],[8,"Vector","","Trait implemented by vector types.",null,null],[16,"Scalar","","",2,null],[8,"Isometry","","Trait implemented by transformation matrices types.",null,null],[8,"HasInertiaMatrix","","Trait implement by vectors that are transformable by the inertia matrix `I`.",null,null],[0,"data","ncollide::utils","Data structure utilities.",null,null],[0,"pair","ncollide::utils::data","Hashable pair of objects implementing `HasUid`.",null,null],[11,"new","ncollide_utils::data::pair","Builds a new `Pair`.",3,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"pair"}}],[11,"decode","","",3,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",3,{"inputs":[{"name":"pair"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"pair"}],"output":{"name":"pair"}}],[11,"eq","","",3,{"inputs":[{"name":"pair"},{"name":"pair"}],"output":{"name":"bool"}}],[11,"decode","","",4,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",4,{"inputs":[{"name":"pairtwhash"},{"name":"__s"}],"output":{"name":"result"}}],[11,"new","","Creates a new PairTWHash",4,{"inputs":[],"output":{"name":"pairtwhash"}}],[11,"hash","","",4,{"inputs":[{"name":"pairtwhash"},{"name":"pair"}],"output":{"name":"usize"}}],[11,"decode","ncollide_utils::data::hash","",5,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",5,{"inputs":[{"name":"uintpairtwhash"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"uintpairtwhash"}],"output":{"name":"uintpairtwhash"}}],[11,"new","","Creates a new UintPairTWHash.",5,{"inputs":[],"output":{"name":"uintpairtwhash"}}],[11,"hash","","",5,null],[11,"decode","","",6,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",6,{"inputs":[{"name":"uinttwhash"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"uinttwhash"}],"output":{"name":"uinttwhash"}}],[11,"new","","Creates a new UintTWHash.",6,{"inputs":[],"output":{"name":"uinttwhash"}}],[11,"hash","","",6,{"inputs":[{"name":"uinttwhash"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"decode","ncollide_utils::data::hash_map","",7,{"inputs":[{"name":"__dkv"}],"output":{"name":"result"}}],[11,"encode","","",7,{"inputs":[{"name":"entry"},{"name":"__skv"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"entry"}],"output":{"name":"entry"}}],[11,"decode","","",8,{"inputs":[{"name":"__dkvh"}],"output":{"name":"result"}}],[11,"encode","","",8,{"inputs":[{"name":"hashmap"},{"name":"__skvh"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"hashmap"}],"output":{"name":"hashmap"}}],[11,"new","","Creates a new hash map.",8,{"inputs":[{"name":"h"}],"output":{"name":"hashmap"}}],[11,"new_with_capacity","","Creates a new hash map with a given capacity.",8,{"inputs":[{"name":"usize"},{"name":"h"}],"output":{"name":"hashmap"}}],[11,"elements","","The elements added to this hash map.",8,null],[11,"elements_mut","","The elements added to this hash map.",8,null],[11,"len","","The number of elements contained by this hashmap.",8,{"inputs":[{"name":"hashmap"}],"output":{"name":"usize"}}],[11,"is_empty","","Whether or not this hashmap is empty.",8,{"inputs":[{"name":"hashmap"}],"output":{"name":"bool"}}],[11,"clear","","Removes everything from this hashmap.",8,null],[11,"remove_elem_at","","Removes the element at the specified position of the element array.",8,{"inputs":[{"name":"hashmap"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"get_and_remove","","Removes an element and returns its value if it existed.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"option"}}],[11,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",8,{"inputs":[{"name":"hashmap"},{"name":"k"},{"name":"f"}],"output":{"name":"option"}}],[11,"insert_or_replace","","Inserts or replace an element.",8,{"inputs":[{"name":"hashmap"},{"name":"k"},{"name":"v"},{"name":"bool"}],"output":{"name":"v"}}],[11,"contains_key","","Checks whether this hashmap contains a specific key.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"bool"}}],[11,"find","","Finds a reference to the element with a given key.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"option"}}],[11,"insert","","Inserts an element on the hash map.",8,{"inputs":[{"name":"hashmap"},{"name":"k"},{"name":"v"}],"output":{"name":"bool"}}],[11,"remove","","Remove an element from the hash map.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"bool"}}],[11,"find_mut","","Gets a mutable reference to an element of the hashmap.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"option"}}],[11,"new","ncollide_utils::data::owned_allocation_cache","Initializes the cache.",9,{"inputs":[],"output":{"name":"ownedallocationcache"}}],[11,"alloc","","Box a value into a potentially already allocated box.",9,{"inputs":[{"name":"ownedallocationcache"},{"name":"t"}],"output":{"name":"box"}}],[11,"retain","","Retains a box which can be re-used by the `box` method.",9,null],[11,"clear","","Clears the cache, destroying any stored pointer.",9,null],[11,"new","ncollide_utils::data::vec_slice","Creates a new immutable slice.",10,null],[11,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",10,null],[11,"len","","The length of this slice.",10,{"inputs":[{"name":"vecslice"}],"output":{"name":"usize"}}],[11,"is_empty","","Whether or not this slice is empty.",10,{"inputs":[{"name":"vecslice"}],"output":{"name":"bool"}}],[11,"get","","Gets the i-th element of the slice.",10,{"inputs":[{"name":"vecslice"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",10,{"inputs":[{"name":"vecslice"},{"name":"usize"}],"output":{"name":"t"}}],[11,"new","","Creates a new mutable slice.",11,null],[11,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",11,null],[11,"len","","The length of this slice.",11,{"inputs":[{"name":"vecslicemut"}],"output":{"name":"usize"}}],[11,"is_empty","","Whether or not this slice is empty.",11,{"inputs":[{"name":"vecslicemut"}],"output":{"name":"bool"}}],[11,"as_slice","","Creates an immutable slice from this mutable slice.",11,{"inputs":[{"name":"vecslicemut"}],"output":{"name":"vecslice"}}],[11,"get","","Gets the i-th element of the slice.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_unchecked_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",11,null],[11,"new","ncollide_utils::data::ref_with_cost","Creates a new reference packed with a cost value.",12,{"inputs":[{"name":"t"},{"name":"n"}],"output":{"name":"refwithcost"}}],[11,"eq","","",12,{"inputs":[{"name":"refwithcost"},{"name":"refwithcost"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",12,{"inputs":[{"name":"refwithcost"},{"name":"refwithcost"}],"output":{"name":"option"}}],[11,"cmp","","",12,{"inputs":[{"name":"refwithcost"},{"name":"refwithcost"}],"output":{"name":"ordering"}}],[11,"decode","ncollide_utils::data::uid_remap","",13,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",13,{"inputs":[{"name":"fastkey"},{"name":"__s"}],"output":{"name":"result"}}],[11,"cmp","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"option"}}],[11,"lt","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"le","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"gt","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"ge","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"eq","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"hash","","",13,null],[11,"clone","","",13,{"inputs":[{"name":"fastkey"}],"output":{"name":"fastkey"}}],[11,"fmt","","",13,{"inputs":[{"name":"fastkey"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new_invalid","","Creates a new invalid key that won&#39;t be used by the `UidRemap` structure, ever.",13,{"inputs":[],"output":{"name":"fastkey"}}],[11,"uid","","The small uid contained by this key.",13,{"inputs":[{"name":"fastkey"}],"output":{"name":"usize"}}],[11,"clone","","",14,{"inputs":[{"name":"uidremap"}],"output":{"name":"uidremap"}}],[11,"fmt","","",14,{"inputs":[{"name":"uidremap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",14,{"inputs":[],"output":{"name":"uidremap"}}],[11,"new","","Creates an empty `UidRemap`.",14,{"inputs":[{"name":"bool"}],"output":{"name":"uidremap"}}],[11,"get_fast_key","","Gets the fast key associated to the given key.",14,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"len","","Return the number of elements in the map.",14,{"inputs":[{"name":"uidremap"}],"output":{"name":"usize"}}],[11,"is_empty","","Return true if the map contains no elements.",14,{"inputs":[{"name":"uidremap"}],"output":{"name":"bool"}}],[11,"clear","","Clears the map, removing all key-value pairs.",14,null],[11,"get","","Returns a reference to the value corresponding to the key.",14,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get_fast","","Returns a reference to the value corresponding to the fast key.",14,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"option"}}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",14,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"contains_fast_key","","Returns true if the map contains a value for the specified fast key.",14,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",14,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get_fast_mut","","Returns a mutable reference to the value corresponding to the fast key.",14,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair to the map. If the key already had a value\npresent in the map, that value and its fast key are returned. Otherwise, `None` is\nreturned.",14,null],[11,"remove","","Removes a key from the map, returning the value at the key if the key exists.",14,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"keys","","Returns an iterator visiting all keys.",14,{"inputs":[{"name":"uidremap"}],"output":{"name":"fastkeys"}}],[11,"values","","Returns an iterator visiting all values.\nThe iterator&#39;s element type is `&amp;&#39;r O`.",14,{"inputs":[{"name":"uidremap"}],"output":{"name":"values"}}],[11,"iter","","Returns an iterator visiting all key-value pairs.",14,{"inputs":[{"name":"uidremap"}],"output":{"name":"fastkeysandvalues"}}],[11,"iter_mut","","Returns an iterator visiting all key-value pairs with mutable references to the values.",14,{"inputs":[{"name":"uidremap"}],"output":{"name":"fastkeysandvaluesmut"}}],[11,"next","","",15,{"inputs":[{"name":"fastkeys"}],"output":{"name":"option"}}],[11,"next","","",16,{"inputs":[{"name":"fastkeysandvalues"}],"output":{"name":"option"}}],[11,"next","","",17,{"inputs":[{"name":"fastkeysandvaluesmut"}],"output":{"name":"option"}}],[11,"update","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",14,{"inputs":[{"name":"uidremap"},{"name":"usize"},{"name":"o"},{"name":"f"}],"output":{"name":"bool"}}],[11,"update_with_key","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `key, oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",14,{"inputs":[{"name":"uidremap"},{"name":"usize"},{"name":"o"},{"name":"f"}],"output":{"name":"bool"}}],[11,"from_iter","","",14,{"inputs":[{"name":"i"}],"output":{"name":"uidremap"}}],[11,"extend","","",14,null],[11,"index","","",14,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"o"}}],[11,"default","ncollide_utils::data::vec_map","",18,{"inputs":[],"output":{"name":"vecmap"}}],[11,"clone","","",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"vecmap"}}],[11,"clone_from","","",18,null],[11,"hash","","",18,null],[11,"new","","Creates an empty `VecMap`.",18,{"inputs":[],"output":{"name":"vecmap"}}],[11,"with_capacity","","Creates an empty `VecMap` with space for at least `capacity`\nelements before resizing.",18,{"inputs":[{"name":"usize"}],"output":{"name":"vecmap"}}],[11,"capacity","","Returns the number of elements the `VecMap` can hold without\nreallocating.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"usize"}}],[11,"reserve_len","","Reserves capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long\nas all inserted keys are less than `len`.",18,null],[11,"reserve_len_exact","","Reserves the minimum capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long as all inserted\nkeys are less than `len`.",18,null],[11,"keys","","Returns an iterator visiting all keys in ascending order of the keys.\nThe iterator&#39;s element type is `usize`.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"keys"}}],[11,"values","","Returns an iterator visiting all values in ascending order of the keys.\nThe iterator&#39;s element type is `&amp;&#39;r V`.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"values"}}],[11,"iter","","Returns an iterator visiting all key-value pairs in ascending order of the keys.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r V)`.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns an iterator visiting all key-value pairs in ascending order of the keys,\nwith mutable references to the values.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r mut V)`.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"itermut"}}],[11,"split_off","","Splits the collection into two at the given key.",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"vecmap"}}],[11,"len","","Returns the number of elements in the map.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if the map contains no elements.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"bool"}}],[11,"clear","","Clears the map, removing all key-value pairs.",18,null],[11,"get","","Returns a reference to the value corresponding to the key.",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair into the map. If the key already had a value\npresent in the map, that value is returned. Otherwise, `None` is returned.",18,{"inputs":[{"name":"vecmap"},{"name":"usize"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"entry","","Gets the given key&#39;s corresponding entry in the map for in-place manipulation.",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"entry"}}],[11,"get","","Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant",19,{"inputs":[{"name":"entry"}],"output":{"name":"result"}}],[11,"or_insert","","Ensures a value is in the entry by inserting the default if empty, and returns\na mutable reference to the value in the entry.",19,{"inputs":[{"name":"entry"},{"name":"v"}],"output":{"name":"v"}}],[11,"or_insert_with","","Ensures a value is in the entry by inserting the result of the default function if empty,\nand returns a mutable reference to the value in the entry.",19,{"inputs":[{"name":"entry"},{"name":"f"}],"output":{"name":"v"}}],[11,"insert","","Sets the value of the entry with the VacantEntry&#39;s key,\nand returns a mutable reference to it.",20,{"inputs":[{"name":"vacantentry"},{"name":"v"}],"output":{"name":"v"}}],[11,"get","","Gets a reference to the value in the entry.",21,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"get_mut","","Gets a mutable reference to the value in the entry.",21,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"into_mut","","Converts the entry into a mutable reference to its value.",21,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"insert","","Sets the value of the entry with the OccupiedEntry&#39;s key,\nand returns the entry&#39;s old value.",21,{"inputs":[{"name":"occupiedentry"},{"name":"v"}],"output":{"name":"v"}}],[11,"remove","","Takes the value of the entry out of the map, and returns it.",21,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"fmt","","",18,{"inputs":[{"name":"vecmap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_iter","","",18,{"inputs":[{"name":"i"}],"output":{"name":"vecmap"}}],[11,"into_iter","","Returns an iterator visiting all key-value pairs in ascending order of\nthe keys, consuming the original `VecMap`.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r V)`.",18,{"inputs":[{"name":"vecmap"}],"output":{"name":"intoiter"}}],[11,"extend","","",18,null],[11,"index","","",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index","","",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index_mut","","",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index_mut","","",18,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"clone","","",22,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"next","","",22,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",22,null],[11,"next_back","","",22,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",23,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"size_hint","","",23,null],[11,"next_back","","",23,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"clone","","",24,{"inputs":[{"name":"keys"}],"output":{"name":"keys"}}],[11,"clone","","",25,{"inputs":[{"name":"values"}],"output":{"name":"values"}}],[11,"next","","",24,{"inputs":[{"name":"keys"}],"output":{"name":"option"}}],[11,"size_hint","","",24,null],[11,"next_back","","",24,{"inputs":[{"name":"keys"}],"output":{"name":"option"}}],[11,"next","","",25,{"inputs":[{"name":"values"}],"output":{"name":"option"}}],[11,"size_hint","","",25,null],[11,"next_back","","",25,{"inputs":[{"name":"values"}],"output":{"name":"option"}}],[11,"next","","",26,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",26,null],[11,"next_back","","",26,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"new","ncollide_utils::optimization","Creates a new backtracking line search methods.",27,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"usize"}],"output":{"name":"backtrackinglinesearch"}}],[11,"step_size","","",27,{"inputs":[{"name":"backtrackinglinesearch"},{"name":"f"},{"name":"v"},{"name":"v"},{"name":"v"}],"output":{"name":"n"}}],[11,"fmt","ncollide_utils::hashable_partial_eq","",28,{"inputs":[{"name":"hashablepartialeq"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"hashablepartialeq"}],"output":{"name":"hashablepartialeq"}}],[11,"decode","","",28,{"inputs":[{"name":"__dt"}],"output":{"name":"result"}}],[11,"encode","","",28,{"inputs":[{"name":"hashablepartialeq"},{"name":"__st"}],"output":{"name":"result"}}],[11,"eq","","",28,{"inputs":[{"name":"hashablepartialeq"},{"name":"hashablepartialeq"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"hashablepartialeq"},{"name":"hashablepartialeq"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `HashablePartialEq`. This is unsafe because you must be sure that you really\nwant to transform the wrapped object&#39;s partial equality to an equivalence relation.",28,{"inputs":[{"name":"t"}],"output":{"name":"hashablepartialeq"}}],[11,"unwrap","","Gets the wrapped value.",28,{"inputs":[{"name":"hashablepartialeq"}],"output":{"name":"t"}}],[11,"hash","","",28,null],[11,"as_bytes","nalgebra::structs::vector","",29,null],[11,"as_bytes","nalgebra::structs::point","",30,null],[11,"as_bytes","nalgebra::structs::vector","",31,null],[11,"as_bytes","nalgebra::structs::point","",32,null],[3,"Pair","ncollide::utils::data::pair","An unordered pair of elements implementing `HasUid`.",null,null],[12,"first","","first object of the pair",3,null],[12,"second","","second object of the pair",3,null],[3,"PairTWHash","","Tomas Wang based hash function for a `Pair` object.",null,null],[0,"hash","ncollide::utils::data","Trait for hash functions.",null,null],[8,"HashFun","ncollide::utils::data::hash","Hash function.",null,null],[10,"hash","","Hash function.",33,{"inputs":[{"name":"hashfun"},{"name":"k"}],"output":{"name":"usize"}}],[3,"UintPairTWHash","","Hash function for pairs of `usize`, using the Tomas Wang hash.",null,null],[3,"UintTWHash","","Hash function for `usize`.",null,null],[5,"key_from_pair","","Combines two `usize` on a single one.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"tomas_wang_hash","","Tomas Wang integer hash function.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[0,"hash_map","ncollide::utils::data","An hash map with a customizable hash function.",null,null],[3,"Entry","ncollide::utils::data::hash_map","Entry of an `HashMap`.",null,null],[12,"key","","The key of the entry.",7,null],[12,"value","","The value of the entry.",7,null],[3,"HashMap","","Alternative implementation of `HashMap`.",null,null],[0,"owned_allocation_cache","ncollide::utils::data","Allocation cache for owned objects.",null,null],[3,"OwnedAllocationCache","ncollide::utils::data::owned_allocation_cache","Cache for owned objects.",null,null],[0,"vec_slice","ncollide::utils::data","Slicing on non-contiguous data.",null,null],[3,"VecSlice","ncollide::utils::data::vec_slice","A vector slice with a specific length and stride.",null,null],[3,"VecSliceMut","","A mutable vector slice with a specific length and stride.",null,null],[0,"ref_with_cost","ncollide::utils::data","A reference packed with a cost value.",null,null],[3,"RefWithCost","ncollide::utils::data::ref_with_cost","A reference packed with a cost value.",null,null],[12,"object","","The reference to an object.",12,null],[12,"cost","","The cost of the object.",12,null],[0,"uid_remap","ncollide::utils::data","A map allowing a slow lookup for arbitrary `usize` and fast lookup for small ones.",null,null],[3,"FastKey","ncollide::utils::data::uid_remap","A special type of key used by `UidRemap` to perform faster lookups than with the user-defined\nid of type `usize`.",null,null],[3,"UidRemap","","A set of values having large usize key.",null,null],[3,"FastKeys","","An iterator through a `UidRemap` fast keys in use.",null,null],[3,"FastKeysAndValues","","An iterator through a `UidRemap` fast keys and values.",null,null],[3,"FastKeysAndValuesMut","","An iterator through a `UidRemap` fast keys and values.",null,null],[0,"vec_map","ncollide::utils::data","A simple map based on a vector for small integer keys. Space requirements\nare O(highest integer key).",null,null],[3,"VecMap","ncollide::utils::data::vec_map","A map optimized for small integer keys.",null,null],[4,"Entry","","A view into a single entry in a map, which may either be vacant or occupied.",null,null],[13,"Vacant","","A vacant Entry",19,null],[13,"Occupied","","An occupied Entry",19,null],[3,"VacantEntry","","A vacant Entry.",null,null],[3,"OccupiedEntry","","An occupied Entry.",null,null],[3,"Iter","","An iterator over the key-value pairs of a map.",null,null],[3,"IterMut","","An iterator over the key-value pairs of a map, with the\nvalues being mutable.",null,null],[3,"Keys","","An iterator over the keys of a map.",null,null],[3,"Values","","An iterator over the values of a map.",null,null],[3,"IntoIter","","A consuming iterator over the key-value pairs of a map.",null,null],[5,"cov_and_center","ncollide::utils","Computes the covariance matrix and center of a set of points.",null,null],[5,"newton","","Finds the root of a function using the Newton method.",null,null],[5,"triangle_center","","Computes the center of a triangle.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"p"}}],[5,"bfgs","","Minimizes a function using the quasi-newton BFGS method.",null,null],[5,"center_reduce","","Centers and reduces a set of data.",null,null],[5,"center","","Computes the center of a set of point.",null,null],[3,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`.",null,null],[5,"binom","","Computes the binomial coefficient C^k_n (&quot;k among n&quot;).",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"point_cloud_support_point","","Computes the support point of a cloud of points.",null,null],[5,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron.",null,null],[5,"is_point_in_triangle","","Tests if a point is inside of a triangle.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"bool"}}],[5,"dsin","","Computes the n-th derivative of the sinus function.",null,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"n"}}],[5,"triangle_area","","Computes the area of a triangle.",null,null],[8,"LineSearch","","Trait for line search methods.",null,null],[10,"step_size","","Gets a near-optimal step size for the next descent.",34,{"inputs":[{"name":"linesearch"},{"name":"f"},{"name":"v"},{"name":"v"},{"name":"v"}],"output":{"name":"n"}}],[5,"is_affinely_dependent_triangle3","","Tests if three 3D points are exactly aligned without the need of the `Cross` trait.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"bool"}}],[5,"median","","Computes the median of a set of values.",null,null],[3,"BacktrackingLineSearch","","The backtracking line search method.",null,null],[5,"triangle_perimeter","","Computes the perimeter of a triangle.",null,null],[5,"cross3","","A 3d cross product that do not require the `Cross&lt;Self, Self&gt;` trait impl.",null,{"inputs":[{"name":"v"},{"name":"v"}],"output":{"name":"v"}}],[5,"cov","","Computes the convariance matrix of a set of points.",null,null],[5,"tetrahedron_volume","","Computes the volume of a tetrahedron.",null,null],[5,"minimize_with_bfgs","","Minimizes a function using the bfgs method.",null,null],[5,"maximize_with_newton","","Maximizes a real function using the Newton method.",null,null],[5,"circumcircle","","Computes the circumcircle of a triangle.",null,null],[5,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed.",null,null],[5,"tetrahedron_center","","Computes the center of a tetrahedron.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"p"}}],[5,"sort3","","Sorts a set of three values in increasing order.",null,null],[5,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component.",null,null],[5,"dcos","","Computes the n-th derivative of the cosinus function.",null,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"n"}}],[5,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component.",null,null],[8,"AsBytes","","Trait that transforms thing to a slice of u8.",null,null],[10,"as_bytes","","",35,null],[5,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"bool"}}],[0,"shape","ncollide","Collision shapes supported by ncollide.",null,null],[11,"is_shape","ncollide::shape","Tests if this shape has a specific type `T`.",36,{"inputs":[{"name":"shape"}],"output":{"name":"bool"}}],[11,"as_shape","","Performs the cast.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"clone","ncollide_geometry::shape::shape","",37,{"inputs":[{"name":"shapehandle"}],"output":{"name":"shapehandle"}}],[11,"new","","Creates a sharable shape handle from a shape.",37,{"inputs":[{"name":"s"}],"output":{"name":"shapehandle"}}],[11,"as_ref","","",37,{"inputs":[{"name":"shapehandle"}],"output":{"name":"shape"}}],[11,"deref","","",37,{"inputs":[{"name":"shapehandle"}],"output":{"name":"shape"}}],[11,"decode","ncollide_geometry::shape::plane","",38,{"inputs":[{"name":"__dv"}],"output":{"name":"result"}}],[11,"encode","","",38,{"inputs":[{"name":"plane"},{"name":"__sv"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"plane"}],"output":{"name":"plane"}}],[11,"fmt","","",38,{"inputs":[{"name":"plane"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",38,{"inputs":[{"name":"plane"},{"name":"plane"}],"output":{"name":"bool"}}],[11,"ne","","",38,{"inputs":[{"name":"plane"},{"name":"plane"}],"output":{"name":"bool"}}],[11,"new","","Builds a new plane from its center and its normal.",38,{"inputs":[{"name":"v"}],"output":{"name":"plane"}}],[11,"new_normalized","","Builds a new plane from its center and its normal.",38,{"inputs":[{"name":"v"}],"output":{"name":"plane"}}],[11,"normal","","The plane normal.",38,{"inputs":[{"name":"plane"}],"output":{"name":"v"}}],[11,"decode","ncollide_geometry::shape::cuboid","",39,{"inputs":[{"name":"__dv"}],"output":{"name":"result"}}],[11,"encode","","",39,{"inputs":[{"name":"cuboid"},{"name":"__sv"}],"output":{"name":"result"}}],[11,"clone","","",39,{"inputs":[{"name":"cuboid"}],"output":{"name":"cuboid"}}],[11,"fmt","","",39,{"inputs":[{"name":"cuboid"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",39,{"inputs":[{"name":"cuboid"},{"name":"cuboid"}],"output":{"name":"bool"}}],[11,"ne","","",39,{"inputs":[{"name":"cuboid"},{"name":"cuboid"}],"output":{"name":"bool"}}],[11,"new","","Creates a new box from its half-extents. Half-extents are the box half-width along each\naxis. Each half-extent must be greater than 0.04.",39,{"inputs":[{"name":"v"}],"output":{"name":"cuboid"}}],[11,"half_extents","","The half-extents of this box. Half-extents are the box half-width along each axis.",39,{"inputs":[{"name":"cuboid"}],"output":{"name":"v"}}],[11,"support_point","","",39,null],[11,"fmt","ncollide_geometry::shape::minkowski_sum","",40,{"inputs":[{"name":"minkowskisum"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",40,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"}],"output":{"name":"minkowskisum"}}],[11,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",40,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"m"}}],[11,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",40,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"m"}}],[11,"g1","","The first shape of this Minkowski Sum.",40,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"g1"}}],[11,"g2","","The second shape of this Minkowski Sum.",40,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"g2"}}],[11,"fmt","","",41,{"inputs":[{"name":"annotatedminkowskisum"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",41,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"}],"output":{"name":"annotatedminkowskisum"}}],[11,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",41,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"m"}}],[11,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",41,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"m"}}],[11,"g1","","The first shape of this Minkowski Sum.",41,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"g1"}}],[11,"g2","","The second shape of this Minkowski Sum.",41,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"g2"}}],[11,"support_point","","",40,null],[11,"support_point","","",41,null],[11,"decode","ncollide_geometry::shape::segment","",42,{"inputs":[{"name":"__dp"}],"output":{"name":"result"}}],[11,"encode","","",42,{"inputs":[{"name":"segment"},{"name":"__sp"}],"output":{"name":"result"}}],[11,"clone","","",42,{"inputs":[{"name":"segment"}],"output":{"name":"segment"}}],[11,"fmt","","",42,{"inputs":[{"name":"segment"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",42,{"inputs":[{"name":"segment"},{"name":"segment"}],"output":{"name":"bool"}}],[11,"ne","","",42,{"inputs":[{"name":"segment"},{"name":"segment"}],"output":{"name":"bool"}}],[11,"new","","Creates a new segment from two points.",42,{"inputs":[{"name":"p"},{"name":"p"}],"output":{"name":"segment"}}],[11,"a","","The first point of this segment.",42,{"inputs":[{"name":"segment"}],"output":{"name":"p"}}],[11,"b","","The second point of this segment.",42,{"inputs":[{"name":"segment"}],"output":{"name":"p"}}],[11,"new_with_vertices_and_indices","","",42,null],[11,"support_point","","",42,null],[11,"decode","ncollide_geometry::shape::triangle","",43,{"inputs":[{"name":"__dp"}],"output":{"name":"result"}}],[11,"encode","","",43,{"inputs":[{"name":"triangle"},{"name":"__sp"}],"output":{"name":"result"}}],[11,"clone","","",43,{"inputs":[{"name":"triangle"}],"output":{"name":"triangle"}}],[11,"fmt","","",43,{"inputs":[{"name":"triangle"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",43,{"inputs":[{"name":"triangle"},{"name":"triangle"}],"output":{"name":"bool"}}],[11,"ne","","",43,{"inputs":[{"name":"triangle"},{"name":"triangle"}],"output":{"name":"bool"}}],[11,"new","","Creates a triangle from three points.",43,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"triangle"}}],[11,"a","","The fist point of this triangle.",43,{"inputs":[{"name":"triangle"}],"output":{"name":"p"}}],[11,"b","","The second point of this triangle.",43,{"inputs":[{"name":"triangle"}],"output":{"name":"p"}}],[11,"c","","The third point of this triangle.",43,{"inputs":[{"name":"triangle"}],"output":{"name":"p"}}],[11,"new_with_vertices_and_indices","","",43,null],[11,"support_point","","",43,null],[11,"clone","ncollide_geometry::shape::base_mesh","",44,{"inputs":[{"name":"basemesh"}],"output":{"name":"basemesh"}}],[11,"new","","Builds a new mesh.",44,{"inputs":[{"name":"arc"},{"name":"arc"},{"name":"option"},{"name":"option"}],"output":{"name":"basemesh"}}],[11,"vertices","","The vertices of this mesh.",44,{"inputs":[{"name":"basemesh"}],"output":{"name":"arc"}}],[11,"len","","The number of primitives on thes mesh.",44,{"inputs":[{"name":"basemesh"}],"output":{"name":"usize"}}],[11,"bounding_volumes","","Bounding volumes of the subsimplices.",44,null],[11,"indices","","The indices of this mesh.",44,{"inputs":[{"name":"basemesh"}],"output":{"name":"arc"}}],[11,"uvs","","The texture coordinates of this mesh.",44,{"inputs":[{"name":"basemesh"}],"output":{"name":"option"}}],[11,"normals","","The normals of this mesh.",44,{"inputs":[{"name":"basemesh"}],"output":{"name":"option"}}],[11,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",44,{"inputs":[{"name":"basemesh"}],"output":{"name":"bvt"}}],[11,"element_at","","Gets the i-th mesh element.",44,{"inputs":[{"name":"basemesh"},{"name":"usize"}],"output":{"name":"e"}}],[11,"clone","ncollide_geometry::shape::trimesh","",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"trimesh"}}],[11,"new","","Builds a new mesh.",45,{"inputs":[{"name":"arc"},{"name":"arc"},{"name":"option"},{"name":"option"}],"output":{"name":"trimesh"}}],[11,"base_mesh","","The base representation of this mesh.",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"basemesh"}}],[11,"vertices","","The vertices of this mesh.",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"arc"}}],[11,"bounding_volumes","","Bounding volumes of the subsimplices.",45,null],[11,"indices","","The indices of this mesh.",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"arc"}}],[11,"uvs","","The texture coordinates of this mesh.",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"option"}}],[11,"normals","","The normals of this mesh.",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"option"}}],[11,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"bvt"}}],[11,"triangle_at","","Gets the i-th mesh element.",45,{"inputs":[{"name":"trimesh"},{"name":"usize"}],"output":{"name":"triangle"}}],[11,"map_part_at","","",45,null],[11,"map_transformed_part_at","","",45,null],[11,"aabb_at","","",45,{"inputs":[{"name":"trimesh"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"bvt","","",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"bvt"}}],[11,"clone","ncollide_geometry::shape::polyline","",46,{"inputs":[{"name":"polyline"}],"output":{"name":"polyline"}}],[11,"new","","Builds a new mesh.",46,{"inputs":[{"name":"arc"},{"name":"arc"},{"name":"option"},{"name":"option"}],"output":{"name":"polyline"}}],[11,"base_mesh","","The base representation of this mesh.",46,{"inputs":[{"name":"polyline"}],"output":{"name":"basemesh"}}],[11,"vertices","","The vertices of this mesh.",46,{"inputs":[{"name":"polyline"}],"output":{"name":"arc"}}],[11,"bounding_volumes","","Bounding volumes of the subsimplices.",46,null],[11,"indices","","The indices of this mesh.",46,{"inputs":[{"name":"polyline"}],"output":{"name":"arc"}}],[11,"uvs","","The texture coordinates of this mesh.",46,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"normals","","The normals of this mesh.",46,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",46,{"inputs":[{"name":"polyline"}],"output":{"name":"bvt"}}],[11,"segment_at","","Gets the i-th mesh element.",46,{"inputs":[{"name":"polyline"},{"name":"usize"}],"output":{"name":"segment"}}],[11,"map_part_at","","",46,null],[11,"map_transformed_part_at","","",46,null],[11,"aabb_at","","",46,{"inputs":[{"name":"polyline"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"bvt","","",46,{"inputs":[{"name":"polyline"}],"output":{"name":"bvt"}}],[11,"decode","ncollide_geometry::shape::ball","",47,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",47,{"inputs":[{"name":"ball"},{"name":"__sn"}],"output":{"name":"result"}}],[11,"clone","","",47,{"inputs":[{"name":"ball"}],"output":{"name":"ball"}}],[11,"fmt","","",47,{"inputs":[{"name":"ball"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",47,{"inputs":[{"name":"ball"},{"name":"ball"}],"output":{"name":"bool"}}],[11,"ne","","",47,{"inputs":[{"name":"ball"},{"name":"ball"}],"output":{"name":"bool"}}],[11,"new","","Creates a new ball from its radius and center.",47,{"inputs":[{"name":"n"}],"output":{"name":"ball"}}],[11,"radius","","The ball radius.",47,{"inputs":[{"name":"ball"}],"output":{"name":"n"}}],[11,"support_point","","",47,null],[11,"decode","ncollide_geometry::shape::capsule","",48,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",48,{"inputs":[{"name":"capsule"},{"name":"__sn"}],"output":{"name":"result"}}],[11,"clone","","",48,{"inputs":[{"name":"capsule"}],"output":{"name":"capsule"}}],[11,"fmt","","",48,{"inputs":[{"name":"capsule"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",48,{"inputs":[{"name":"capsule"},{"name":"capsule"}],"output":{"name":"bool"}}],[11,"ne","","",48,{"inputs":[{"name":"capsule"},{"name":"capsule"}],"output":{"name":"bool"}}],[11,"new","","Creates a new capsule.",48,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"capsule"}}],[11,"half_height","","The capsule half length along the `y` axis.",48,{"inputs":[{"name":"capsule"}],"output":{"name":"n"}}],[11,"radius","","The radius of the capsule&#39;s rounded part.",48,{"inputs":[{"name":"capsule"}],"output":{"name":"n"}}],[11,"support_point","","",48,null],[11,"decode","ncollide_geometry::shape::cone","",49,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",49,{"inputs":[{"name":"cone"},{"name":"__sn"}],"output":{"name":"result"}}],[11,"clone","","",49,{"inputs":[{"name":"cone"}],"output":{"name":"cone"}}],[11,"fmt","","",49,{"inputs":[{"name":"cone"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",49,{"inputs":[{"name":"cone"},{"name":"cone"}],"output":{"name":"bool"}}],[11,"ne","","",49,{"inputs":[{"name":"cone"},{"name":"cone"}],"output":{"name":"bool"}}],[11,"new","","Creates a new cone.",49,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"cone"}}],[11,"half_height","","The cone half length along the `y` axis.",49,{"inputs":[{"name":"cone"}],"output":{"name":"n"}}],[11,"radius","","The radius of the cone along all but the `y` axis.",49,{"inputs":[{"name":"cone"}],"output":{"name":"n"}}],[11,"support_point","","",49,null],[11,"decode","ncollide_geometry::shape::cylinder","",50,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",50,{"inputs":[{"name":"cylinder"},{"name":"__sn"}],"output":{"name":"result"}}],[11,"clone","","",50,{"inputs":[{"name":"cylinder"}],"output":{"name":"cylinder"}}],[11,"fmt","","",50,{"inputs":[{"name":"cylinder"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",50,{"inputs":[{"name":"cylinder"},{"name":"cylinder"}],"output":{"name":"bool"}}],[11,"ne","","",50,{"inputs":[{"name":"cylinder"},{"name":"cylinder"}],"output":{"name":"bool"}}],[11,"new","","Creates a new cylinder.",50,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"cylinder"}}],[11,"half_height","","The cylinder half length along the `y` axis.",50,{"inputs":[{"name":"cylinder"}],"output":{"name":"n"}}],[11,"radius","","The radius of the cylinder along all but the `y` axis.",50,{"inputs":[{"name":"cylinder"}],"output":{"name":"n"}}],[11,"support_point","","",50,null],[11,"fmt","ncollide_geometry::shape::reflection","",51,{"inputs":[{"name":"reflection"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Build the reflection of a shape. Since the representation is implicit,\nthe reflection computation is done in constant time.",51,{"inputs":[{"name":"g"}],"output":{"name":"reflection"}}],[11,"shape","","The reflected shape.",51,{"inputs":[{"name":"reflection"}],"output":{"name":"g"}}],[11,"support_point","","",51,null],[11,"decode","ncollide_geometry::shape::torus","",52,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",52,{"inputs":[{"name":"torus"},{"name":"__sn"}],"output":{"name":"result"}}],[11,"clone","","",52,{"inputs":[{"name":"torus"}],"output":{"name":"torus"}}],[11,"fmt","","",52,{"inputs":[{"name":"torus"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",52,{"inputs":[{"name":"torus"},{"name":"torus"}],"output":{"name":"bool"}}],[11,"ne","","",52,{"inputs":[{"name":"torus"},{"name":"torus"}],"output":{"name":"bool"}}],[11,"new","","Creates a new torus with the given radiuses.",52,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"torus"}}],[11,"minor_radius","","The torus minor radius.",52,{"inputs":[{"name":"torus"}],"output":{"name":"n"}}],[11,"major_radius","","The torus major radius.",52,{"inputs":[{"name":"torus"}],"output":{"name":"n"}}],[11,"clone","ncollide_geometry::shape::compound","",53,{"inputs":[{"name":"compound"}],"output":{"name":"compound"}}],[11,"new","","Builds a new compound shape.",53,{"inputs":[{"name":"vec"}],"output":{"name":"compound"}}],[11,"shapes","","The shapes of this compound shape.",53,null],[11,"bvt","","The optimization structure used by this compound shape.",53,{"inputs":[{"name":"compound"}],"output":{"name":"bvt"}}],[11,"bounding_volumes","","The shapes bounding volumes.",53,null],[11,"aabb_at","","The AABB of the i-th shape compositing this compound.",53,{"inputs":[{"name":"compound"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"map_part_at","","",53,null],[11,"map_transformed_part_at","","",53,null],[11,"aabb_at","","",53,{"inputs":[{"name":"compound"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"bvt","","",53,{"inputs":[{"name":"compound"}],"output":{"name":"bvt"}}],[11,"decode","ncollide_geometry::shape::convex","",54,{"inputs":[{"name":"__dp"}],"output":{"name":"result"}}],[11,"encode","","",54,{"inputs":[{"name":"convexhull"},{"name":"__sp"}],"output":{"name":"result"}}],[11,"clone","","",54,{"inputs":[{"name":"convexhull"}],"output":{"name":"convexhull"}}],[11,"fmt","","",54,{"inputs":[{"name":"convexhull"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",54,{"inputs":[{"name":"convexhull"},{"name":"convexhull"}],"output":{"name":"bool"}}],[11,"ne","","",54,{"inputs":[{"name":"convexhull"},{"name":"convexhull"}],"output":{"name":"bool"}}],[11,"new","","Creates a polytope from a set of point.",54,{"inputs":[{"name":"vec"}],"output":{"name":"convexhull"}}],[11,"points","","The list of points of this convex polytope.",54,null],[11,"support_point","","",54,null],[11,"aabb","ncollide_geometry::shape::triangle","",43,{"inputs":[{"name":"triangle"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",43,{"inputs":[{"name":"triangle"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",43,{"inputs":[{"name":"triangle"}],"output":{"name":"option"}}],[11,"as_point_query","","",43,{"inputs":[{"name":"triangle"}],"output":{"name":"option"}}],[11,"as_support_map","","",43,{"inputs":[{"name":"triangle"}],"output":{"name":"option"}}],[11,"is_support_map","","",43,{"inputs":[{"name":"triangle"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::segment","",42,{"inputs":[{"name":"segment"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",42,{"inputs":[{"name":"segment"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",42,{"inputs":[{"name":"segment"}],"output":{"name":"option"}}],[11,"as_point_query","","",42,{"inputs":[{"name":"segment"}],"output":{"name":"option"}}],[11,"as_support_map","","",42,{"inputs":[{"name":"segment"}],"output":{"name":"option"}}],[11,"is_support_map","","",42,{"inputs":[{"name":"segment"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::ball","",47,{"inputs":[{"name":"ball"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",47,{"inputs":[{"name":"ball"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",47,{"inputs":[{"name":"ball"}],"output":{"name":"option"}}],[11,"as_point_query","","",47,{"inputs":[{"name":"ball"}],"output":{"name":"option"}}],[11,"as_support_map","","",47,{"inputs":[{"name":"ball"}],"output":{"name":"option"}}],[11,"is_support_map","","",47,{"inputs":[{"name":"ball"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::cuboid","",39,{"inputs":[{"name":"cuboid"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",39,{"inputs":[{"name":"cuboid"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",39,{"inputs":[{"name":"cuboid"}],"output":{"name":"option"}}],[11,"as_point_query","","",39,{"inputs":[{"name":"cuboid"}],"output":{"name":"option"}}],[11,"as_support_map","","",39,{"inputs":[{"name":"cuboid"}],"output":{"name":"option"}}],[11,"is_support_map","","",39,{"inputs":[{"name":"cuboid"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::cylinder","",50,{"inputs":[{"name":"cylinder"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",50,{"inputs":[{"name":"cylinder"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",50,{"inputs":[{"name":"cylinder"}],"output":{"name":"option"}}],[11,"as_point_query","","",50,{"inputs":[{"name":"cylinder"}],"output":{"name":"option"}}],[11,"as_support_map","","",50,{"inputs":[{"name":"cylinder"}],"output":{"name":"option"}}],[11,"is_support_map","","",50,{"inputs":[{"name":"cylinder"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::cone","",49,{"inputs":[{"name":"cone"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",49,{"inputs":[{"name":"cone"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",49,{"inputs":[{"name":"cone"}],"output":{"name":"option"}}],[11,"as_point_query","","",49,{"inputs":[{"name":"cone"}],"output":{"name":"option"}}],[11,"as_support_map","","",49,{"inputs":[{"name":"cone"}],"output":{"name":"option"}}],[11,"is_support_map","","",49,{"inputs":[{"name":"cone"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::convex","",54,{"inputs":[{"name":"convexhull"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",54,{"inputs":[{"name":"convexhull"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",54,{"inputs":[{"name":"convexhull"}],"output":{"name":"option"}}],[11,"as_point_query","","",54,{"inputs":[{"name":"convexhull"}],"output":{"name":"option"}}],[11,"as_support_map","","",54,{"inputs":[{"name":"convexhull"}],"output":{"name":"option"}}],[11,"is_support_map","","",54,{"inputs":[{"name":"convexhull"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::compound","",53,{"inputs":[{"name":"compound"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",53,{"inputs":[{"name":"compound"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",53,{"inputs":[{"name":"compound"}],"output":{"name":"option"}}],[11,"as_point_query","","",53,{"inputs":[{"name":"compound"}],"output":{"name":"option"}}],[11,"as_composite_shape","","",53,{"inputs":[{"name":"compound"}],"output":{"name":"option"}}],[11,"is_composite_shape","","",53,{"inputs":[{"name":"compound"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::trimesh","",45,{"inputs":[{"name":"trimesh"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",45,{"inputs":[{"name":"trimesh"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"option"}}],[11,"as_point_query","","",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"option"}}],[11,"as_composite_shape","","",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"option"}}],[11,"is_composite_shape","","",45,{"inputs":[{"name":"trimesh"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::polyline","",46,{"inputs":[{"name":"polyline"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",46,{"inputs":[{"name":"polyline"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",46,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"as_point_query","","",46,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"as_composite_shape","","",46,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"is_composite_shape","","",46,{"inputs":[{"name":"polyline"}],"output":{"name":"bool"}}],[11,"aabb","ncollide_geometry::shape::plane","",38,{"inputs":[{"name":"plane"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","",38,{"inputs":[{"name":"plane"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","",38,{"inputs":[{"name":"plane"}],"output":{"name":"option"}}],[11,"as_point_query","","",38,{"inputs":[{"name":"plane"}],"output":{"name":"option"}}],[11,"new","ncollide_geometry::bounding_volume::bounding_volume_bvt","Creates a new `BoundingVolumeInterferencesCollector`.",55,{"inputs":[{"name":"bv"},{"name":"vec"}],"output":{"name":"boundingvolumeinterferencescollector"}}],[11,"visit_internal","","",55,{"inputs":[{"name":"boundingvolumeinterferencescollector"},{"name":"bv"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",55,null],[11,"decode","ncollide_geometry::bounding_volume::aabb","",56,{"inputs":[{"name":"__dp"}],"output":{"name":"result"}}],[11,"encode","","",56,{"inputs":[{"name":"aabb"},{"name":"__sp"}],"output":{"name":"result"}}],[11,"clone","","",56,{"inputs":[{"name":"aabb"}],"output":{"name":"aabb"}}],[11,"eq","","",56,{"inputs":[{"name":"aabb"},{"name":"aabb"}],"output":{"name":"bool"}}],[11,"ne","","",56,{"inputs":[{"name":"aabb"},{"name":"aabb"}],"output":{"name":"bool"}}],[11,"fmt","","",56,{"inputs":[{"name":"aabb"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new AABB.",56,{"inputs":[{"name":"p"},{"name":"p"}],"output":{"name":"aabb"}}],[11,"new_invalid","","Creates an invalid AABB with:\n* `mins = Bounded::max_value()`\n* `maxs = Bounded::max_value()`.\nThis is useful to build aabb using merges.",56,{"inputs":[],"output":{"name":"aabb"}}],[11,"mins","","Reference to the AABB point with the smallest components along each axis.",56,{"inputs":[{"name":"aabb"}],"output":{"name":"p"}}],[11,"maxs","","Reference to the AABB point with the biggest components along each axis.",56,{"inputs":[{"name":"aabb"}],"output":{"name":"p"}}],[11,"center","","The center of this AABB.",56,{"inputs":[{"name":"aabb"}],"output":{"name":"p"}}],[11,"half_extents","","The half extents of this AABB.",56,null],[11,"intersects","","",56,{"inputs":[{"name":"aabb"},{"name":"aabb"}],"output":{"name":"bool"}}],[11,"contains","","",56,{"inputs":[{"name":"aabb"},{"name":"aabb"}],"output":{"name":"bool"}}],[11,"merge","","",56,null],[11,"merged","","",56,{"inputs":[{"name":"aabb"},{"name":"aabb"}],"output":{"name":"aabb"}}],[11,"loosen","","",56,null],[11,"loosened","","",56,null],[11,"tighten","","",56,null],[11,"tightened","","",56,null],[11,"translation","","",56,null],[11,"inverse_translation","","",56,null],[11,"append_translation_mut","","",56,null],[11,"append_translation","","",56,null],[11,"prepend_translation_mut","","",56,null],[11,"prepend_translation","","",56,null],[11,"set_translation","","",56,null],[11,"bounding_volume","ncollide_geometry::shape::cuboid","",39,{"inputs":[{"name":"cuboid"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::cone","",49,{"inputs":[{"name":"cone"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::cylinder","",50,{"inputs":[{"name":"cylinder"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::capsule","",48,{"inputs":[{"name":"capsule"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::triangle","",43,{"inputs":[{"name":"triangle"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::segment","",42,{"inputs":[{"name":"segment"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::ball","",47,{"inputs":[{"name":"ball"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::plane","",38,{"inputs":[{"name":"plane"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::convex","",54,{"inputs":[{"name":"convexhull"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::compound","",53,{"inputs":[{"name":"compound"},{"name":"m2"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::base_mesh","",44,{"inputs":[{"name":"basemesh"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::trimesh","",45,{"inputs":[{"name":"trimesh"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_geometry::shape::polyline","",46,{"inputs":[{"name":"polyline"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide::shape","",36,{"inputs":[{"name":"shape"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"decode","ncollide_geometry::bounding_volume::bounding_sphere","",57,{"inputs":[{"name":"__dp"}],"output":{"name":"result"}}],[11,"encode","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"__sp"}],"output":{"name":"result"}}],[11,"clone","","",57,{"inputs":[{"name":"boundingsphere"}],"output":{"name":"boundingsphere"}}],[11,"eq","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"boundingsphere"}],"output":{"name":"bool"}}],[11,"ne","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"boundingsphere"}],"output":{"name":"bool"}}],[11,"fmt","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new bounding sphere.",57,null],[11,"center","","The bounding sphere center.",57,{"inputs":[{"name":"boundingsphere"}],"output":{"name":"p"}}],[11,"radius","","The bounding sphere radius.",57,null],[11,"transform_by","","Transforms this bounding sphere by `m`.",57,{"inputs":[{"name":"boundingsphere"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"intersects","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"boundingsphere"}],"output":{"name":"bool"}}],[11,"contains","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"boundingsphere"}],"output":{"name":"bool"}}],[11,"merge","","",57,null],[11,"merged","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"boundingsphere"}],"output":{"name":"boundingsphere"}}],[11,"loosen","","",57,null],[11,"loosened","","",57,null],[11,"tighten","","",57,null],[11,"tightened","","",57,null],[11,"translation","","",57,null],[11,"inverse_translation","","",57,null],[11,"append_translation_mut","","",57,null],[11,"append_translation","","",57,null],[11,"prepend_translation_mut","","",57,null],[11,"prepend_translation","","",57,null],[11,"set_translation","","",57,null],[11,"bounding_volume","ncollide_geometry::shape::cuboid","",39,{"inputs":[{"name":"cuboid"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::cone","",49,{"inputs":[{"name":"cone"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::ball","",47,{"inputs":[{"name":"ball"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::cylinder","",50,{"inputs":[{"name":"cylinder"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::capsule","",48,{"inputs":[{"name":"capsule"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::plane","",38,{"inputs":[{"name":"plane"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::convex","",54,{"inputs":[{"name":"convexhull"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::compound","",53,{"inputs":[{"name":"compound"},{"name":"m2"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::triangle","",43,{"inputs":[{"name":"triangle"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::segment","",42,{"inputs":[{"name":"segment"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::base_mesh","",44,{"inputs":[{"name":"basemesh"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::trimesh","",45,{"inputs":[{"name":"trimesh"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_geometry::shape::polyline","",46,{"inputs":[{"name":"polyline"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide::shape","",36,{"inputs":[{"name":"shape"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"new","ncollide_geometry::partitioning::dbvt","Creates a new Dynamic Bounding Volume Tree.",58,{"inputs":[],"output":{"name":"dbvt"}}],[11,"remove","","Removes a leaf from the tree. Fails if the tree is empty.",58,null],[11,"insert_new","","Creates, inserts, and returns a new leaf with the given content.",58,{"inputs":[{"name":"dbvt"},{"name":"b"},{"name":"bv"}],"output":{"name":"rc"}}],[11,"insert","","Inserts a leaf to the tree.",58,null],[11,"visit","","Traverses this tree using an object implementing the `BVTVisitor`trait.",58,null],[11,"clone","","",59,{"inputs":[{"name":"dbvtleaf"}],"output":{"name":"dbvtleaf"}}],[11,"new","","Creates a new leaf.",59,{"inputs":[{"name":"bv"},{"name":"b"}],"output":{"name":"dbvtleaf"}}],[11,"is_root","","Tests if this node is the root.",59,{"inputs":[{"name":"dbvtleaf"}],"output":{"name":"bool"}}],[11,"is_detached","","Tests if this node has no parent.",59,{"inputs":[{"name":"dbvtleaf"}],"output":{"name":"bool"}}],[11,"decode","ncollide_geometry::partitioning::bvt","",60,{"inputs":[{"name":"__dbbv"}],"output":{"name":"result"}}],[11,"encode","","",60,{"inputs":[{"name":"bvt"},{"name":"__sbbv"}],"output":{"name":"result"}}],[11,"clone","","",60,{"inputs":[{"name":"bvt"}],"output":{"name":"bvt"}}],[11,"decode","","",61,{"inputs":[{"name":"__dbbv"}],"output":{"name":"result"}}],[11,"encode","","",61,{"inputs":[{"name":"bvtnode"},{"name":"__sbbv"}],"output":{"name":"result"}}],[11,"clone","","",61,{"inputs":[{"name":"bvtnode"}],"output":{"name":"bvtnode"}}],[11,"new_with_partitioner","","Builds a bounding volume tree using an user-defined construction function.",60,{"inputs":[{"name":"vec"},{"name":"f"}],"output":{"name":"bvt"}}],[11,"visit","","Traverses this tree using an object implementing the `BVTVisitor`trait.",60,null],[11,"visit_bvtt","","Visits the bounding volume traversal tree implicitely formed with `other`.",60,null],[11,"best_first_search","","Performs a best-fist-search on the tree.",60,{"inputs":[{"name":"bvt"},{"name":"bfs"}],"output":{"name":"option"}}],[11,"root_bounding_volume","","Reference to the bounding volume of the tree root.",60,{"inputs":[{"name":"bvt"}],"output":{"name":"option"}}],[11,"depth","","Computes the depth of this tree.",60,{"inputs":[{"name":"bvt"}],"output":{"name":"usize"}}],[11,"new_balanced","","Creates a balanced `BVT`.",60,{"inputs":[{"name":"vec"}],"output":{"name":"bvt"}}],[11,"bounding_volume","","The bounding volume of this node.",61,{"inputs":[{"name":"bvtnode"}],"output":{"name":"bv"}}],[11,"new","ncollide_geometry::partitioning::bvt_visitor","Creates a new `BoundingVolumeInterferencesCollector`.",62,{"inputs":[{"name":"bv"},{"name":"vec"}],"output":{"name":"boundingvolumeinterferencescollector"}}],[11,"visit_internal","","",62,{"inputs":[{"name":"boundingvolumeinterferencescollector"},{"name":"bv"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",62,null],[11,"clone","ncollide_geometry::query::algorithms::johnson_simplex","",63,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"johnsonsimplex"}}],[11,"decode","","",64,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",64,{"inputs":[{"name":"recursiontemplate"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",64,{"inputs":[{"name":"recursiontemplate"}],"output":{"name":"recursiontemplate"}}],[11,"eq","","",64,{"inputs":[{"name":"recursiontemplate"},{"name":"recursiontemplate"}],"output":{"name":"bool"}}],[11,"ne","","",64,{"inputs":[{"name":"recursiontemplate"},{"name":"recursiontemplate"}],"output":{"name":"bool"}}],[11,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dimension`.",64,{"inputs":[{"name":"usize"}],"output":{"name":"arc"}}],[11,"new","","Creates a new, empty, Johnson simplex.",63,{"inputs":[{"name":"arc"}],"output":{"name":"johnsonsimplex"}}],[11,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",63,{"inputs":[],"output":{"name":"johnsonsimplex"}}],[11,"reset","","",63,null],[11,"dimension","","",63,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"usize"}}],[11,"max_sq_len","","",63,null],[11,"contains_point","","",63,{"inputs":[{"name":"johnsonsimplex"},{"name":"p"}],"output":{"name":"bool"}}],[11,"add_point","","",63,null],[11,"project_origin_and_reduce","","",63,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"p"}}],[11,"project_origin","","",63,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"p"}}],[11,"modify_pnts","","",63,null],[11,"clone","ncollide_geometry::query::algorithms::gjk","",65,{"inputs":[{"name":"gjkresult"}],"output":{"name":"gjkresult"}}],[11,"decode","","",65,{"inputs":[{"name":"__dpv"}],"output":{"name":"result"}}],[11,"encode","","",65,{"inputs":[{"name":"gjkresult"},{"name":"__spv"}],"output":{"name":"result"}}],[11,"decode","ncollide_geometry::query::contacts_internal::contact","",66,{"inputs":[{"name":"__dp"}],"output":{"name":"result"}}],[11,"encode","","",66,{"inputs":[{"name":"contact"},{"name":"__sp"}],"output":{"name":"result"}}],[11,"clone","","",66,{"inputs":[{"name":"contact"}],"output":{"name":"contact"}}],[11,"eq","","",66,{"inputs":[{"name":"contact"},{"name":"contact"}],"output":{"name":"bool"}}],[11,"ne","","",66,{"inputs":[{"name":"contact"},{"name":"contact"}],"output":{"name":"bool"}}],[11,"fmt","","",66,{"inputs":[{"name":"contact"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new contact.",66,null],[11,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",66,null],[11,"decode","ncollide_geometry::query::proximity_internal::proximity","",67,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",67,{"inputs":[{"name":"proximity"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",67,{"inputs":[{"name":"proximity"}],"output":{"name":"proximity"}}],[11,"eq","","",67,{"inputs":[{"name":"proximity"},{"name":"proximity"}],"output":{"name":"bool"}}],[11,"fmt","","",67,{"inputs":[{"name":"proximity"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","ncollide_geometry::query::ray_internal::ray","",68,{"inputs":[{"name":"ray"}],"output":{"name":"ray"}}],[11,"decode","","",68,{"inputs":[{"name":"__dp"}],"output":{"name":"result"}}],[11,"encode","","",68,{"inputs":[{"name":"ray"},{"name":"__sp"}],"output":{"name":"result"}}],[11,"fmt","","",68,{"inputs":[{"name":"ray"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new ray starting from `origin` and with the direction `dir`. `dir` must be\nnormalized.",68,null],[11,"new_with_uvs","","Creates a new `RayIntersection`.",69,null],[11,"new","","Creates a new `RayIntersection`.",69,null],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::plane","",38,{"inputs":[{"name":"plane"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::shape::ball","",47,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",47,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",47,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::shape::cuboid","",39,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",39,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",39,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::bounding_volume::aabb","",56,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",56,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",56,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::bounding_volume::bounding_sphere","",57,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::cylinder","",50,{"inputs":[{"name":"cylinder"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::cone","",49,{"inputs":[{"name":"cone"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::capsule","",48,{"inputs":[{"name":"capsule"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::convex","",54,{"inputs":[{"name":"convexhull"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::segment","",42,{"inputs":[{"name":"segment"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::minkowski_sum","",40,{"inputs":[{"name":"minkowskisum"},{"name":"m2"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","ncollide_geometry::shape::triangle","",43,{"inputs":[{"name":"triangle"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::shape::compound","",53,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",53,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::shape::base_mesh","",44,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",44,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",44,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::shape::trimesh","",45,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",45,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",45,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide_geometry::shape::polyline","",46,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",46,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",46,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide::shape","",36,{"inputs":[{"name":"shape"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",36,{"inputs":[{"name":"shape"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",36,{"inputs":[{"name":"shape"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","",36,{"inputs":[{"name":"shape"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[11,"new","ncollide_geometry::query::ray_internal::ray_bvt","Creates a new `BestRayInterferenceSearch`.",70,{"inputs":[{"name":"ray"},{"name":"bool"},{"name":"bool"}],"output":{"name":"rayintersectioncostfn"}}],[11,"compute_bv_cost","","",70,{"inputs":[{"name":"rayintersectioncostfn"},{"name":"bv"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",70,{"inputs":[{"name":"rayintersectioncostfn"},{"name":"b"}],"output":{"name":"option"}}],[11,"new","","Creates a new `RayInterferencesCollector`.",71,{"inputs":[{"name":"ray"},{"name":"vec"}],"output":{"name":"rayinterferencescollector"}}],[11,"visit_internal","","",71,{"inputs":[{"name":"rayinterferencescollector"},{"name":"bv"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",71,null],[11,"new","ncollide_geometry::query::point_internal::point_query","Initializes a new `PointProjection`.",72,{"inputs":[{"name":"bool"},{"name":"p"}],"output":{"name":"pointprojection"}}],[11,"project_point","ncollide_geometry::shape::plane","",38,{"inputs":[{"name":"plane"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",38,null],[11,"contains_point","","",38,{"inputs":[{"name":"plane"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::shape::ball","",47,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",47,null],[11,"contains_point","","",47,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::shape::cuboid","",39,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",39,null],[11,"contains_point","","",39,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::bounding_volume::aabb","",56,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",56,null],[11,"contains_point","","",56,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::bounding_volume::bounding_sphere","",57,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",57,null],[11,"contains_point","","",57,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::shape::cylinder","",50,{"inputs":[{"name":"cylinder"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","ncollide_geometry::shape::cone","",49,{"inputs":[{"name":"cone"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","ncollide_geometry::shape::capsule","",48,{"inputs":[{"name":"capsule"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","ncollide_geometry::shape::convex","",54,{"inputs":[{"name":"convexhull"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","ncollide_geometry::shape::segment","",42,{"inputs":[{"name":"segment"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","ncollide_geometry::shape::triangle","",43,{"inputs":[{"name":"triangle"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","ncollide_geometry::shape::compound","",53,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"contains_point","","",53,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::shape::base_mesh","",44,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"contains_point","","",44,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::shape::trimesh","",45,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",45,null],[11,"contains_point","","",45,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide_geometry::shape::polyline","",46,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",46,null],[11,"contains_point","","",46,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide::shape","",36,{"inputs":[{"name":"shape"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",36,null],[11,"contains_point","","",36,{"inputs":[{"name":"shape"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"new","ncollide_geometry::query::point_internal::point_bvt","Creates a new `PointInterferencesCollector`.",73,{"inputs":[{"name":"p"},{"name":"vec"}],"output":{"name":"pointinterferencescollector"}}],[11,"visit_internal","","",73,{"inputs":[{"name":"pointinterferencescollector"},{"name":"bv"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",73,null],[11,"bounding_sphere","ncollide::shape::shape","The bounding sphere of `self`.",36,{"inputs":[{"name":"shape"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","The `RayCast` implementation of `self`.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"as_point_query","","The `PointQuery` implementation of `self`.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"as_support_map","","The support mapping of `self` if applicable.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"as_composite_shape","","The composite shape representation of `self` if applicable.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"is_support_map","","Whether `self` uses a supportmapping-based representation.",36,{"inputs":[{"name":"shape"}],"output":{"name":"bool"}}],[11,"is_composite_shape","","Whether `self` uses a composite shape-based representation.",36,{"inputs":[{"name":"shape"}],"output":{"name":"bool"}}],[6,"Ball2","ncollide::shape","",null,null],[6,"Plane2","","",null,null],[6,"Cuboid2","","",null,null],[6,"Capsule2","","",null,null],[6,"Cone2","","",null,null],[6,"Cylinder2","","",null,null],[6,"ConvexHull2","","",null,null],[6,"Segment2","","",null,null],[6,"Triangle2","","",null,null],[6,"Polyline2","","",null,null],[6,"Compound2","","",null,null],[6,"CompositeShape2","","",null,null],[6,"SupportMap2","","",null,null],[6,"Shape2","","",null,null],[6,"ShapeHandle2","","",null,null],[6,"Ball3","","",null,null],[6,"Plane3","","",null,null],[6,"Cuboid3","","",null,null],[6,"Capsule3","","",null,null],[6,"Cone3","","",null,null],[6,"Cylinder3","","",null,null],[6,"ConvexHull3","","",null,null],[6,"Segment3","","",null,null],[6,"Triangle3","","",null,null],[6,"Polyline3","","",null,null],[6,"TriMesh3","","",null,null],[6,"Compound3","","",null,null],[6,"CompositeShape3","","",null,null],[6,"SupportMap3","","",null,null],[6,"Shape3","","",null,null],[6,"ShapeHandle3","","",null,null],[3,"Capsule","","SupportMap description of a capsule shape with its principal axis aligned with the `y` axis.",null,null],[8,"SupportMap","","Traits of convex shapes representable by a support mapping function.",null,null],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the shape point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\nshape-dependent. Use `support_point` to sample the complete shape.",74,null],[3,"Reflection","","SupportMap representation of the reflection of a shape.",null,null],[3,"Plane","","SupportMap description of a plane.",null,null],[8,"CompositeShape","","Trait implemented by shapes composed of multiple simpler shapes.",null,null],[10,"map_part_at","","Applies a function to each sub-shape of this concave shape.",75,null],[10,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-shape of this concave\nshape.",75,null],[10,"aabb_at","","Gets the AABB of the shape identified by the index `i`.",75,{"inputs":[{"name":"compositeshape"},{"name":"usize"}],"output":{"name":"aabb"}}],[10,"bvt","","Gets the acceleration structure of the concave shape.",75,{"inputs":[{"name":"compositeshape"}],"output":{"name":"bvt"}}],[3,"Compound","","A compound shape with an aabb bounding volume.",null,null],[3,"Cylinder","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis.",null,null],[3,"Cuboid","","Shape of a box.",null,null],[3,"ShapeHandle","","A shared immutable handle to an abstract shape.",null,null],[8,"BaseMeshElement","","Trait implemented by elements usable on the Mesh.",null,null],[10,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices.",76,null],[5,"cso_support_point","","Computes the support point of the CSO `g1 - g2` on a given direction.",null,null],[3,"ConvexHull","","The implicit convex hull of a set of points.",null,null],[3,"Ball","","A Ball shape.",null,null],[3,"Segment","","A segment shape.",null,null],[8,"Shape","","Trait implemented by all shapes supported by ncollide.",null,null],[10,"aabb","","The AABB of `self`.",36,{"inputs":[{"name":"shape"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_sphere","","The bounding sphere of `self`.",36,{"inputs":[{"name":"shape"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"as_ray_cast","","The `RayCast` implementation of `self`.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"as_point_query","","The `PointQuery` implementation of `self`.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"as_support_map","","The support mapping of `self` if applicable.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"as_composite_shape","","The composite shape representation of `self` if applicable.",36,{"inputs":[{"name":"shape"}],"output":{"name":"option"}}],[11,"is_support_map","","Whether `self` uses a supportmapping-based representation.",36,{"inputs":[{"name":"shape"}],"output":{"name":"bool"}}],[11,"is_composite_shape","","Whether `self` uses a composite shape-based representation.",36,{"inputs":[{"name":"shape"}],"output":{"name":"bool"}}],[3,"MinkowskiSum","","SupportMap representation of the Minkowski sum of two shapes.",null,null],[3,"Triangle","","A triangle shape.",null,null],[3,"TriMesh","","Shape commonly known as a 2d line strip or a 3d triangle mesh.",null,null],[3,"Polyline","","Shape commonly known as a 2d line strip or a 3d segment mesh.",null,null],[3,"Torus","","A torus.",null,null],[3,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped shapes.",null,null],[3,"Cone","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis.",null,null],[3,"BaseMesh","","A mesh generic wrt. the contained mesh elements characterized by vertices.",null,null],[0,"bounding_volume","ncollide","Bounding volumes.",null,null],[6,"BoundingSphere2","ncollide::bounding_volume","",null,null],[6,"AABB2","","",null,null],[6,"BoundingSphere3","","",null,null],[6,"AABB3","","",null,null],[5,"support_map_aabb","","Computes the AABB of an support mapped shape.",null,{"inputs":[{"name":"m"},{"name":"g"}],"output":{"name":"aabb"}}],[5,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point.",null,null],[3,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume.",null,null],[8,"BoundingVolume","","Trait of bounding volumes.",null,null],[10,"intersects","","Checks if this bounding volume intersect with another one.",77,{"inputs":[{"name":"boundingvolume"},{"name":"self"}],"output":{"name":"bool"}}],[10,"contains","","Checks if this bounding volume contains another one.",77,{"inputs":[{"name":"boundingvolume"},{"name":"self"}],"output":{"name":"bool"}}],[10,"merge","","Merges this bounding volume with another one. The merge is done in-place.",77,null],[10,"merged","","Merges this bounding volume with another one.",77,{"inputs":[{"name":"boundingvolume"},{"name":"self"}],"output":{"name":"self"}}],[10,"loosen","","Enlarges this bounding volume.",77,null],[10,"loosened","","Creates a new, enlarged version, of this bounding volume.",77,{"inputs":[{"name":"boundingvolume"},{"name":"n"}],"output":{"name":"self"}}],[10,"tighten","","Tighten this bounding volume.",77,null],[10,"tightened","","Creates a new, tightened version, of this bounding volume.",77,{"inputs":[{"name":"boundingvolume"},{"name":"n"}],"output":{"name":"self"}}],[5,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball.",null,null],[3,"BoundingSphere","","A Bounding Sphere.",null,null],[5,"bounding_sphere","","Computes the bounding sphere of a shape `g` transformed by `m`.",null,{"inputs":[{"name":"g"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[3,"AABB","","An Axis Aligned Bounding Box.",null,null],[5,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center.",null,null],[8,"HasBoundingVolume","","Traits of objects having a bounding volume.",null,null],[10,"bounding_volume","","The bounding volume of `self` transformed by `m`.",78,{"inputs":[{"name":"hasboundingvolume"},{"name":"m"}],"output":{"name":"bv"}}],[5,"aabb","","Computes the axis-aligned bounding box of a shape `g` transformed by `m`.",null,{"inputs":[{"name":"g"},{"name":"m"}],"output":{"name":"aabb"}}],[5,"point_cloud_aabb","","Computes the AABB of a set of point.",null,null],[0,"partitioning","ncollide","Spatial partitioning tools.",null,null],[3,"BoundingVolumeInterferencesCollector","ncollide::partitioning","Bounding Volume Tree visitor collecting interferences with a given bounding volume.",null,null],[3,"BVT","","A Boundig Volume Tree.",null,null],[3,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree.",null,null],[12,"bounding_volume","","The bounding volume of this node.",59,null],[12,"center","","The center of this node bounding volume.",59,null],[12,"object","","An user-defined object.",59,null],[8,"BVTCostFn","","Trait implemented by cost functions used by the best-first search on a `BVT`.",null,null],[16,"UserData","","User-defined data attached to each BVT leaf.",79,null],[10,"compute_bv_cost","","Computes the cost of a bounding volume.",79,{"inputs":[{"name":"bvtcostfn"},{"name":"bv"}],"output":{"name":"option"}}],[10,"compute_b_cost","","Computes the cost of an object, and the result to be returned if it is the best one.",79,{"inputs":[{"name":"bvtcostfn"},{"name":"b"}],"output":{"name":"option"}}],[4,"BVTNode","","A node of the bounding volume tree.",null,null],[13,"Internal","","An internal node.",61,null],[13,"Leaf","","A leaf.",61,null],[8,"BVTVisitor","","Visitor of Bounding Volume Trees.",null,null],[10,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",80,{"inputs":[{"name":"bvtvisitor"},{"name":"bv"}],"output":{"name":"bool"}}],[10,"visit_leaf","","Visits a leaf.",80,null],[5,"median_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`.",null,null],[3,"DBVT","","A Dynamic Bounding Volume Tree.",null,null],[8,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree.",null,null],[10,"visit_internal_internal","","Visit two internal nodes.",81,{"inputs":[{"name":"bvttvisitor"},{"name":"bv"},{"name":"bv"}],"output":{"name":"bool"}}],[10,"visit_leaf_leaf","","Visit two leaves.",81,null],[10,"visit_internal_leaf","","Visit one internal node and one leaf.",81,{"inputs":[{"name":"bvttvisitor"},{"name":"bv"},{"name":"b"},{"name":"bv"}],"output":{"name":"bool"}}],[10,"visit_leaf_internal","","Visit one leaf and on internal node.",81,{"inputs":[{"name":"bvttvisitor"},{"name":"b"},{"name":"bv"},{"name":"bv"}],"output":{"name":"bool"}}],[4,"BinaryPartition","","Result of a binary partition.",null,null],[13,"Part","","Result of the partitioning of one element.",82,null],[13,"Parts","","Result of the partitioning of several elements.",82,null],[5,"median_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`.",null,null],[0,"query","ncollide","Non-persistant pairwise geometric queries.",null,null],[0,"algorithms","ncollide::query","Algorithms needed for distance and penetration depth computation.",null,null],[0,"simplex","ncollide::query::algorithms","Abstract definition of a simplex usable by the GJK algorithm.",null,null],[8,"Simplex","ncollide::query::algorithms::simplex","Trait of a simplex usable by the GJK algorithm.",null,null],[10,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",83,null],[10,"add_point","","Adds a point to the simplex.",83,null],[10,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",83,{"inputs":[{"name":"simplex"}],"output":{"name":"p"}}],[10,"project_origin","","Projection the origin on the simplex. The simplex itself is unchanged, although it is\nmutable for optimization purpose.",83,{"inputs":[{"name":"simplex"}],"output":{"name":"p"}}],[10,"contains_point","","Checks whether a given point is already part of the simplex points.",83,{"inputs":[{"name":"simplex"},{"name":"p"}],"output":{"name":"bool"}}],[10,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",83,{"inputs":[{"name":"simplex"}],"output":{"name":"usize"}}],[10,"max_sq_len","","The maximum among the simplex point squared lengths.",83,null],[10,"modify_pnts","","Modifies the points contained by this simplex.",83,null],[0,"johnson_simplex","ncollide::query::algorithms","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex.",null,null],[3,"JohnsonSimplex","ncollide::query::algorithms::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex.",null,null],[3,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex.",null,null],[0,"gjk","ncollide::query::algorithms","The Gilbert–Johnson–Keerthi distance algorithm.",null,null],[4,"GJKResult","ncollide::query::algorithms::gjk","Results of the GJK algorithm.",null,null],[13,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",65,null],[13,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",65,null],[13,"Proximity","","Result of the GJK algorithm when the origin is to close to the polytope but not inside of it.",65,null],[13,"NoIntersection","","Result of the GJK algorithm when the origin is too far away from the polytope.",65,null],[5,"closest_points","","Computes the closest points between two convex shapes unsing the GJK\nalgorithm.",null,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"},{"name":"s"}],"output":{"name":"option"}}],[5,"closest_points_with_max_dist","","Computes the closest points between two convex shapes unsing the GJK algorithm.",null,null],[5,"distance","","Computes the exact distance separating two convex shapes unsing the GJK.\nalgorithm.",null,null],[5,"proximity","","Computes the closest points between two convex shapes unsing the GJK algorithm.",null,null],[5,"project_origin","","Projects the origin on a shape unsing the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"}],"output":{"name":"option"}}],[5,"project_origin_with_max_dist","","Projects the origin on a shape using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin.",null,null],[5,"cast_ray","","Casts a ray on a support map using the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"},{"name":"ray"}],"output":{"name":"option"}}],[0,"minkowski_sampling","ncollide::query::algorithms","Penetration depth computation algorithm approximating the Minkowskis sum.",null,null],[5,"closest_points","ncollide::query::algorithms::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"},{"name":"s"}],"output":{"name":"option"}}],[5,"project_origin","","Projects the origin on a support-mapped shape.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"}],"output":{"name":"option"}}],[0,"contacts_internal","ncollide::query","Implementation details of the `contact` and `contacts` functions.",null,null],[5,"shape_against_composite_shape","ncollide::query::contacts_internal","Best contact between a shape and a composite (`Mesh`, `Compound`) shape.",null,null],[5,"support_map_against_support_map_with_params","","Contact between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[3,"Contact","","Geometric description of a contact.",null,null],[12,"world1","","Position of the contact on the first object. The position is expressed in world space.",66,null],[12,"world2","","Position of the contact on the second object. The position is expressed in world space.",66,null],[12,"normal","","Contact normal",66,null],[12,"depth","","Penetration depth",66,null],[5,"composite_shape_against_shape","","Best contact between a composite shape (`Mesh`, `Compound`) and any other shape.",null,null],[5,"plane_against_support_map","","Contact between a plane and a support-mapped shape (Cuboid, ConvexHull, etc.)",null,null],[5,"support_map_against_support_map","","Contact between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[5,"shape_against_shape","","Computes one contact point between two shapes.",null,null],[5,"support_map_against_plane","","Contact between a support-mapped shape (Cuboid, ConvexHull, etc.) and a plane.",null,null],[5,"ball_against_ball","","Contact between balls.",null,null],[0,"distance_internal","ncollide::query","Implementation details of the `distance` function.",null,null],[5,"plane_against_support_map","ncollide::query::distance_internal","Distance between a plane and a support-mapped shape.",null,null],[5,"support_map_against_plane","","Distance between a support-mapped shape and a plane.",null,null],[5,"shape_against_composite_shape","","Smallest distance between a shape and a composite shape.",null,null],[5,"ball_against_ball","","Distance between balls.",null,null],[5,"shape_against_shape","","Computes the minimum distance separating two shapes.",null,null],[5,"composite_shape_against_shape","","Smallest distance between a composite shape and any other shape.",null,null],[5,"support_map_against_support_map_with_params","","Distance between support-mapped shapes.",null,null],[5,"support_map_against_support_map","","Distance between support-mapped shapes.",null,null],[0,"proximity_internal","ncollide::query","Implementation details of the `proximity` function.",null,null],[4,"Proximity","ncollide::query::proximity_internal","Proximity information.",null,null],[13,"Intersecting","","The two objects are intersecting.",67,null],[13,"WithinMargin","","The two objects are non-intersecting but closer than a given distance.",67,null],[13,"Disjoint","","The two objects are non-intersecting and further than a given distance.",67,null],[5,"support_map_against_plane","","Proximity between a support-mapped shape (Cuboid, ConvexHull, etc.) and a plane.",null,null],[5,"ball_against_ball","","Proximity between balls.",null,null],[5,"plane_against_support_map","","Proximity between a plane and a support-mapped shape (Cuboid, ConvexHull, etc.)",null,null],[5,"shape_against_shape","","Tests whether two shapes are in intersecting or separated by a distance smaller than `margin`.",null,null],[5,"support_map_against_support_map","","Proximity between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[5,"composite_shape_against_shape","","Proximity between a composite shape (`Mesh`, `Compound`) and any other shape.",null,null],[5,"shape_against_composite_shape","","Proximity between a shape and a composite (`Mesh`, `Compound`) shape.",null,null],[5,"support_map_against_support_map_with_params","","Proximity between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[0,"time_of_impact_internal","ncollide::query","Implementation details of the `time_of_impact` function.",null,null],[5,"composite_shape_against_shape","ncollide::query::time_of_impact_internal","Time Of Impact of a composite shape with any other shape, under translational movement.",null,null],[5,"support_map_against_plane","","Time Of Impact of a plane with a support-mapped shape under translational movement.",null,null],[5,"shape_against_composite_shape","","Time Of Impact of any shape with a composite shape, under translational movement.",null,null],[5,"plane_against_support_map","","Time Of Impact of a plane with a support-mapped shape under translational movement.",null,null],[5,"ball_against_ball","","Time Of Impact of two balls under translational movement.",null,null],[5,"shape_against_shape","","Computes the smallest time of impact of two shapes under translational movement.",null,null],[5,"support_map_against_support_map","","Time of impacts between two support-mapped shapes under translational movement.",null,null],[0,"ray_internal","ncollide::query","Ray-casting related definitions and implementations.",null,null],[11,"toi_with_ray","ncollide::query::ray_internal::ray","Computes the time of impact between this transform shape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\nshape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","Tests whether a ray intersects this transformed shape.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[6,"Ray3","ncollide::query::ray_internal","",null,null],[6,"Ray2","","",null,null],[6,"RayIntersection3","","",null,null],[6,"RayIntersection2","","",null,null],[3,"Ray","","A Ray.",null,null],[12,"origin","","Starting point of the ray.",68,null],[12,"dir","","Direction of the ray.",68,null],[3,"RayIntersection","","Structure containing the result of a successful ray cast.",null,null],[12,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `origin + dir * toi` where `origin` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",69,null],[12,"normal","","The normal at the intersection point.",69,null],[12,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",69,null],[5,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball.",null,null],[3,"RayIntersectionCostFn","","A search thet selects the objects that has the smallest time of impact with a given ray.",null,null],[8,"RayCast","","Traits of objects which can be transformed and tested for intersection with a ray.",null,null],[11,"toi_with_ray","","Computes the time of impact between this transform shape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[10,"toi_and_normal_with_ray","","Computes the time of impact, and normal between this transformed shape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\nshape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","Tests whether a ray intersects this transformed shape.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[5,"implicit_toi_and_normal_with_ray","","Cast a ray on a shape using the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[5,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"},{"name":"ray"}],"output":{"name":"option"}}],[5,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal.",null,null],[3,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray.",null,null],[0,"point_internal","ncollide::query","Point inclusion and projection.",null,null],[11,"distance_to_point","ncollide::query::point_internal::point_query","Computes the minimal distance between a point and `self` transformed by `m`.",85,null],[11,"contains_point","","Tests if the given point is inside of `self` transformed by `m`.",85,{"inputs":[{"name":"pointquery"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[3,"PointProjection","ncollide::query::point_internal","Description of the projection of a point on a shape.",null,null],[12,"is_inside","","Whether or not the point to project was inside of the shape.",72,null],[12,"point","","The projection result.",72,null],[8,"PointQuery","","Trait of objects that can be tested for point inclusion and projection.",null,null],[10,"project_point","","Projects a point on `self` transformed by `m`.",85,{"inputs":[{"name":"pointquery"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","Computes the minimal distance between a point and `self` transformed by `m`.",85,null],[11,"contains_point","","Tests if the given point is inside of `self` transformed by `m`.",85,{"inputs":[{"name":"pointquery"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[3,"PointInterferencesCollector","","Bounding Volume Tree visitor collecting nodes that may contain a given point.",null,null],[5,"shape_against_shape","ncollide::query","Computes the smallest time of impact of two shapes under translational movement.",null,null],[3,"PointInterferencesCollector","","Bounding Volume Tree visitor collecting nodes that may contain a given point.",null,null],[3,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray.",null,null],[3,"Contact","","Geometric description of a contact.",null,null],[12,"world1","","Position of the contact on the first object. The position is expressed in world space.",66,null],[12,"world2","","Position of the contact on the second object. The position is expressed in world space.",66,null],[12,"normal","","Contact normal",66,null],[12,"depth","","Penetration depth",66,null],[4,"Proximity","","Proximity information.",null,null],[13,"Intersecting","","The two objects are intersecting.",67,null],[13,"WithinMargin","","The two objects are non-intersecting but closer than a given distance.",67,null],[13,"Disjoint","","The two objects are non-intersecting and further than a given distance.",67,null],[3,"Ray","","A Ray.",null,null],[12,"origin","","Starting point of the ray.",68,null],[12,"dir","","Direction of the ray.",68,null],[3,"PointProjection","","Description of the projection of a point on a shape.",null,null],[12,"is_inside","","Whether or not the point to project was inside of the shape.",72,null],[12,"point","","The projection result.",72,null],[5,"shape_against_shape","","Tests whether two shapes are in intersecting or separated by a distance smaller than `margin`.",null,null],[3,"RayIntersectionCostFn","","A search thet selects the objects that has the smallest time of impact with a given ray.",null,null],[3,"RayIntersection","","Structure containing the result of a successful ray cast.",null,null],[12,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `origin + dir * toi` where `origin` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",69,null],[12,"normal","","The normal at the intersection point.",69,null],[12,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",69,null],[8,"RayCast","","Traits of objects which can be transformed and tested for intersection with a ray.",null,null],[11,"toi_with_ray","","Computes the time of impact between this transform shape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[10,"toi_and_normal_with_ray","","Computes the time of impact, and normal between this transformed shape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\nshape and a ray.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","Tests whether a ray intersects this transformed shape.",84,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[8,"PointQuery","","Trait of objects that can be tested for point inclusion and projection.",null,null],[10,"project_point","","Projects a point on `self` transformed by `m`.",85,{"inputs":[{"name":"pointquery"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","Computes the minimal distance between a point and `self` transformed by `m`.",85,null],[11,"contains_point","","Tests if the given point is inside of `self` transformed by `m`.",85,{"inputs":[{"name":"pointquery"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[5,"shape_against_shape","","Computes the minimum distance separating two shapes.",null,null],[5,"shape_against_shape","","Computes one contact point between two shapes.",null,null],[0,"narrow_phase","ncollide","Persistent collision detection algorithms to compute contact points.",null,null],[11,"new","ncollide_pipeline::broad_phase::brute_force_broad_phase","Creates a new brute-force broad phase.",86,{"inputs":[{"name":"n"},{"name":"bool"}],"output":{"name":"bruteforcebroadphase"}}],[11,"deferred_add","","",86,null],[11,"deferred_remove","","",86,null],[11,"deferred_set_bounding_volume","","",86,null],[11,"deferred_recompute_all_proximities","","",86,null],[11,"update","","",86,null],[11,"interferences_with_bounding_volume","","",86,null],[11,"interferences_with_ray","","",86,null],[11,"interferences_with_point","","",86,null],[11,"new","ncollide_pipeline::broad_phase::dbvt_broad_phase","Creates a new broad phase based on a Dynamic Bounding Volume Tree.",87,null],[11,"num_interferences","","Number of interferences detected by this broad phase.",87,{"inputs":[{"name":"dbvtbroadphase"}],"output":{"name":"usize"}}],[11,"deferred_add","","",87,null],[11,"deferred_remove","","",87,null],[11,"update","","",87,null],[11,"deferred_set_bounding_volume","","",87,null],[11,"deferred_recompute_all_proximities","","",87,null],[11,"interferences_with_bounding_volume","","",87,null],[11,"interferences_with_ray","","",87,null],[11,"interferences_with_point","","",87,null],[11,"new","ncollide_pipeline::broad_phase::broad_phase_pair_filter","Creates a new set of collision filters.",88,{"inputs":[],"output":{"name":"broadphasepairfilters"}}],[11,"register_collision_filter","","Registers a collision filter.",88,null],[11,"unregister_collision_filter","","Unregisters a collision filter.",88,{"inputs":[{"name":"broadphasepairfilters"},{"name":"str"}],"output":{"name":"bool"}}],[11,"is_pair_valid","","Tells if the collision between `b1` and `b2` is to be handled by the narrow-phase.",88,{"inputs":[{"name":"broadphasepairfilters"},{"name":"collisionobject"},{"name":"collisionobject"}],"output":{"name":"bool"}}],[11,"new","ncollide_pipeline::narrow_phase::contact_generator::default_contact_dispatcher","Creates a new basic collision dispatcher.",89,{"inputs":[],"output":{"name":"defaultcontactdispatcher"}}],[11,"get_contact_algorithm","","",89,{"inputs":[{"name":"defaultcontactdispatcher"},{"name":"shape"},{"name":"shape"}],"output":{"name":"option"}}],[11,"clone","ncollide_pipeline::narrow_phase::contact_generator::ball_ball_contact_generator","",90,{"inputs":[{"name":"ballballcontactgenerator"}],"output":{"name":"ballballcontactgenerator"}}],[11,"new","","Creates a new persistent collision detector between two balls.",90,{"inputs":[],"output":{"name":"ballballcontactgenerator"}}],[11,"update","","",90,null],[11,"num_contacts","","",90,{"inputs":[{"name":"ballballcontactgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",90,null],[11,"clone","ncollide_pipeline::narrow_phase::contact_generator::plane_support_map_contact_generator","",91,{"inputs":[{"name":"planesupportmapcontactgenerator"}],"output":{"name":"planesupportmapcontactgenerator"}}],[11,"new","","Creates a new persistent collision detector between a plane and a shape with a support\nmapping function.",91,{"inputs":[],"output":{"name":"planesupportmapcontactgenerator"}}],[11,"clone","","",92,{"inputs":[{"name":"supportmapplanecontactgenerator"}],"output":{"name":"supportmapplanecontactgenerator"}}],[11,"new","","Creates a new persistent collision detector between a plane and a shape with a support\nmapping function.",92,{"inputs":[],"output":{"name":"supportmapplanecontactgenerator"}}],[11,"update","","",91,null],[11,"num_contacts","","",91,{"inputs":[{"name":"planesupportmapcontactgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",91,null],[11,"update","","",92,null],[11,"num_contacts","","",92,{"inputs":[{"name":"supportmapplanecontactgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",92,null],[11,"clone","ncollide_pipeline::narrow_phase::contact_generator::support_map_support_map_contact_generator","",93,{"inputs":[{"name":"supportmapsupportmapcontactgenerator"}],"output":{"name":"supportmapsupportmapcontactgenerator"}}],[11,"new","","Creates a new persistant collision detector between two shapes with support mapping\nfunctions.",93,{"inputs":[{"name":"s"}],"output":{"name":"supportmapsupportmapcontactgenerator"}}],[11,"update","","",93,null],[11,"num_contacts","","",93,{"inputs":[{"name":"supportmapsupportmapcontactgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",93,null],[11,"clone","ncollide_pipeline::narrow_phase::contact_generator::incremental_contact_manifold_generator","",94,{"inputs":[{"name":"incrementalcontactmanifoldgenerator"}],"output":{"name":"incrementalcontactmanifoldgenerator"}}],[11,"decode","","",94,{"inputs":[{"name":"__dpmcd"}],"output":{"name":"result"}}],[11,"encode","","",94,{"inputs":[{"name":"incrementalcontactmanifoldgenerator"},{"name":"__spmcd"}],"output":{"name":"result"}}],[11,"new","","Creates a new incremental contact manifold generator.",94,{"inputs":[{"name":"cd"}],"output":{"name":"incrementalcontactmanifoldgenerator"}}],[11,"get_sub_collision","","Gets a collision from the sub-detector used by this manifold generator. This does not\nupdate the manifold itself.",94,null],[11,"add_new_contacts","","Updates the current manifold by adding one point.",94,null],[11,"update_contacts","","Updates the contacts already existing on this manifold.",94,null],[11,"update","","",94,null],[11,"num_contacts","","",94,{"inputs":[{"name":"incrementalcontactmanifoldgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",94,null],[11,"clone","ncollide_pipeline::narrow_phase::contact_generator::one_shot_contact_manifold_generator","",95,{"inputs":[{"name":"oneshotcontactmanifoldgenerator"}],"output":{"name":"oneshotcontactmanifoldgenerator"}}],[11,"decode","","",95,{"inputs":[{"name":"__dpmcd"}],"output":{"name":"result"}}],[11,"encode","","",95,{"inputs":[{"name":"oneshotcontactmanifoldgenerator"},{"name":"__spmcd"}],"output":{"name":"result"}}],[11,"new","","Creates a new one shot contact manifold generator.",95,{"inputs":[{"name":"cd"}],"output":{"name":"oneshotcontactmanifoldgenerator"}}],[11,"update","","",95,null],[11,"num_contacts","","",95,{"inputs":[{"name":"oneshotcontactmanifoldgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",95,null],[11,"new","ncollide_pipeline::narrow_phase::contact_generator::composite_shape_shape_contact_generator","Creates a new collision detector between a concave shape and another shape.",96,{"inputs":[],"output":{"name":"compositeshapeshapecontactgenerator"}}],[11,"new","","Creates a new collision detector between a shape and a concave shape.",97,{"inputs":[],"output":{"name":"shapecompositeshapecontactgenerator"}}],[11,"update","","",96,null],[11,"num_contacts","","",96,{"inputs":[{"name":"compositeshapeshapecontactgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",96,null],[11,"update","","",97,null],[11,"num_contacts","","",97,{"inputs":[{"name":"shapecompositeshapecontactgenerator"}],"output":{"name":"usize"}}],[11,"contacts","","",97,null],[11,"clone","ncollide_pipeline::narrow_phase::proximity_detector::ball_ball_proximity_detector","",98,{"inputs":[{"name":"ballballproximitydetector"}],"output":{"name":"ballballproximitydetector"}}],[11,"new","","Creates a new persistent collision detector between two balls.",98,{"inputs":[],"output":{"name":"ballballproximitydetector"}}],[11,"update","","",98,null],[11,"proximity","","",98,{"inputs":[{"name":"ballballproximitydetector"}],"output":{"name":"proximity"}}],[11,"clone","ncollide_pipeline::narrow_phase::proximity_detector::plane_support_map_proximity_detector","",99,{"inputs":[{"name":"planesupportmapproximitydetector"}],"output":{"name":"planesupportmapproximitydetector"}}],[11,"new","","Creates a new persistent proximity detector between a plane and a shape with a support\nmapping function.",99,{"inputs":[],"output":{"name":"planesupportmapproximitydetector"}}],[11,"clone","","",100,{"inputs":[{"name":"supportmapplaneproximitydetector"}],"output":{"name":"supportmapplaneproximitydetector"}}],[11,"new","","Creates a new persistent proximity detector between a plane and a shape with a support\nmapping function.",100,{"inputs":[],"output":{"name":"supportmapplaneproximitydetector"}}],[11,"update","","",99,null],[11,"proximity","","",99,{"inputs":[{"name":"planesupportmapproximitydetector"}],"output":{"name":"proximity"}}],[11,"update","","",100,null],[11,"proximity","","",100,{"inputs":[{"name":"supportmapplaneproximitydetector"}],"output":{"name":"proximity"}}],[11,"clone","ncollide_pipeline::narrow_phase::proximity_detector::support_map_support_map_proximity_detector","",101,{"inputs":[{"name":"supportmapsupportmapproximitydetector"}],"output":{"name":"supportmapsupportmapproximitydetector"}}],[11,"new","","Creates a new persistant proximity detector between two shapes with support mapping\nfunctions.",101,{"inputs":[{"name":"s"}],"output":{"name":"supportmapsupportmapproximitydetector"}}],[11,"update","","",101,null],[11,"proximity","","",101,{"inputs":[{"name":"supportmapsupportmapproximitydetector"}],"output":{"name":"proximity"}}],[11,"new","ncollide_pipeline::narrow_phase::proximity_detector::composite_shape_shape_proximity_detector","Creates a new proximity detector between a concave shape and another shape.",102,{"inputs":[],"output":{"name":"compositeshapeshapeproximitydetector"}}],[11,"new","","Creates a new collision detector between a shape and a concave shape.",103,{"inputs":[],"output":{"name":"shapecompositeshapeproximitydetector"}}],[11,"update","","",102,null],[11,"proximity","","",102,{"inputs":[{"name":"compositeshapeshapeproximitydetector"}],"output":{"name":"proximity"}}],[11,"update","","",103,null],[11,"proximity","","",103,{"inputs":[{"name":"shapecompositeshapeproximitydetector"}],"output":{"name":"proximity"}}],[11,"new","ncollide_pipeline::narrow_phase::proximity_detector::default_proximity_dispatcher","Creates a new basic proximity dispatcher.",104,{"inputs":[],"output":{"name":"defaultproximitydispatcher"}}],[11,"get_proximity_algorithm","","",104,{"inputs":[{"name":"defaultproximitydispatcher"},{"name":"shape"},{"name":"shape"}],"output":{"name":"option"}}],[11,"new","ncollide_pipeline::narrow_phase::narrow_phase","",105,{"inputs":[{"name":"uidremap"},{"name":"iter"}],"output":{"name":"contactpairs"}}],[11,"contacts","","Transforms contact-pairs iterator to an iterator through each individual contact.",105,{"inputs":[{"name":"contactpairs"}],"output":{"name":"contacts"}}],[11,"next","","",105,{"inputs":[{"name":"contactpairs"}],"output":{"name":"option"}}],[11,"next","","",106,{"inputs":[{"name":"contacts"}],"output":{"name":"option"}}],[11,"new","","",107,{"inputs":[{"name":"uidremap"},{"name":"iter"}],"output":{"name":"proximitypairs"}}],[11,"next","","",107,{"inputs":[{"name":"proximitypairs"}],"output":{"name":"option"}}],[11,"new","ncollide_pipeline::narrow_phase::default_narrow_phase","Creates a new `DefaultNarrowPhase`.",108,{"inputs":[{"name":"box"},{"name":"box"}],"output":{"name":"defaultnarrowphase"}}],[11,"update","","",108,null],[11,"handle_interaction","","",108,null],[11,"contact_pairs","","",108,{"inputs":[{"name":"defaultnarrowphase"},{"name":"uidremap"}],"output":{"name":"contactpairs"}}],[11,"proximity_pairs","","",108,{"inputs":[{"name":"defaultnarrowphase"},{"name":"uidremap"}],"output":{"name":"proximitypairs"}}],[11,"new","ncollide_pipeline::narrow_phase::contact_signal","Creates a new `ContactSignal` with no event handler registered.",109,{"inputs":[],"output":{"name":"contactsignal"}}],[11,"register_contact_handler","","Registers an event handler.",109,null],[11,"unregister_contact_handler","","Unregisters an event handler.",109,null],[11,"trigger_contact_started_signal","","Activates the contact started signal, executing all the event handlers.",109,null],[11,"trigger_contact_stopped_signal","","Activates the contact stopped signal, executing all the event handlers.",109,null],[11,"new","ncollide_pipeline::narrow_phase::proximity_signal","Creates a new `ProximitySignal` with no event handler registered.",110,{"inputs":[],"output":{"name":"proximitysignal"}}],[11,"register_proximity_handler","","Registers an event handler.",110,null],[11,"unregister_proximity_handler","","Unregisters an event handler.",110,null],[11,"trigger_proximity_signal","","Activates the proximity signal, executing all the event handlers.",110,null],[11,"decode","ncollide_pipeline::world::collision_object","",111,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",111,{"inputs":[{"name":"geometricquerytype"},{"name":"__sn"}],"output":{"name":"result"}}],[11,"clone","","",111,{"inputs":[{"name":"geometricquerytype"}],"output":{"name":"geometricquerytype"}}],[11,"eq","","",111,{"inputs":[{"name":"geometricquerytype"},{"name":"geometricquerytype"}],"output":{"name":"bool"}}],[11,"ne","","",111,{"inputs":[{"name":"geometricquerytype"},{"name":"geometricquerytype"}],"output":{"name":"bool"}}],[11,"fmt","","",111,{"inputs":[{"name":"geometricquerytype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"query_limit","","The numerical limit of relevance for this query.",111,{"inputs":[{"name":"geometricquerytype"}],"output":{"name":"n"}}],[11,"is_contacts_query","","Returns `true` if this is a contacts query type.",111,{"inputs":[{"name":"geometricquerytype"}],"output":{"name":"bool"}}],[11,"is_proximity_query","","Returns `true` if this is a proximity query type.",111,{"inputs":[{"name":"geometricquerytype"}],"output":{"name":"bool"}}],[11,"new","","Creates a new collision object.",112,{"inputs":[{"name":"usize"},{"name":"m"},{"name":"shapehandle"},{"name":"collisiongroups"},{"name":"geometricquerytype"},{"name":"t"}],"output":{"name":"collisionobject"}}],[11,"fmt","ncollide_pipeline::world::collision_groups","",113,{"inputs":[{"name":"collisiongroups"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",113,{"inputs":[{"name":"collisiongroups"}],"output":{"name":"collisiongroups"}}],[11,"decode","","",113,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",113,{"inputs":[{"name":"collisiongroups"},{"name":"__s"}],"output":{"name":"result"}}],[11,"new","","Creates a new `CollisionGroups` that enables interactions with everything except\nself-interaction.",113,{"inputs":[],"output":{"name":"collisiongroups"}}],[11,"max_group_id","","The maximum allowed group identifier.",113,{"inputs":[],"output":{"name":"usize"}}],[11,"modify_membership","","Adds or removes this entity from the given group.",113,null],[11,"modify_whitelist","","Adds or removes the given group from this entity whitelist.",113,null],[11,"modify_blacklist","","Adds or removes this entity from the given group.",113,null],[11,"set_membership","","Make this object member of the given groups only.",113,null],[11,"set_whitelist","","Whitelists the given groups only (others will be un-whitelisted).",113,null],[11,"set_blacklist","","Blacklists the given groups only (others will be un-blacklisted).",113,null],[11,"copy_membership","","Copies the membership of another collision groups.",113,null],[11,"copy_whitelist","","Copies the whitelist of another collision groups.",113,null],[11,"copy_blacklist","","Copies the blacklist of another collision groups.",113,null],[11,"enable_self_interaction","","Allows the object to interact with itself.",113,null],[11,"disable_self_interaction","","Prevents the object from interacting with itself.",113,null],[11,"is_member_of","","Tests if this entity is part of the given group.",113,{"inputs":[{"name":"collisiongroups"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"is_group_whitelisted","","Tests if the given group is whitelisted.",113,{"inputs":[{"name":"collisiongroups"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"is_group_blacklisted","","Tests if the given group is blacklisted.",113,{"inputs":[{"name":"collisiongroups"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"can_interact_with","","Tests whether interactinos with a given group is possible.",113,{"inputs":[{"name":"collisiongroups"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"can_interact_with_groups","","Tests whether two collision groups have at least one group in common.",113,{"inputs":[{"name":"collisiongroups"},{"name":"collisiongroups"}],"output":{"name":"bool"}}],[11,"can_interact_with_self","","Tests whether self-interaction is enabled.",113,{"inputs":[{"name":"collisiongroups"}],"output":{"name":"bool"}}],[11,"new","","Creates a new collision filter based collision groups.",114,{"inputs":[],"output":{"name":"collisiongroupspairfilter"}}],[11,"is_pair_valid","","",114,{"inputs":[{"name":"collisiongroupspairfilter"},{"name":"collisionobject"},{"name":"collisionobject"}],"output":{"name":"bool"}}],[11,"new","ncollide_pipeline::world::collision_world","Creates a new collision world.",115,null],[11,"add","","Adds a collision object to the world.",115,null],[11,"update","","Updates the collision world.",115,null],[11,"deferred_remove","","Marks a collision object for removal from the world during the next update.",115,null],[11,"deferred_set_position","","Sets the position the collision object attached to the specified object will have during\nthe next update.",115,null],[11,"register_broad_phase_pair_filter","","Adds a filter that tells if a potential collision pair should be ignored or not.",115,null],[11,"unregister_broad_phase_pair_filter","","Removes the pair filter named `name`.",115,null],[11,"register_contact_handler","","Registers a handler for contact start/stop events.",115,null],[11,"unregister_contact_handler","","Unregisters a handler for contact start/stop events.",115,null],[11,"register_proximity_handler","","Registers a handler for proximity status change events.",115,null],[11,"unregister_proximity_handler","","Unregisters a handler for proximity status change events.",115,null],[11,"perform_position_update","","Executes the position updates.",115,null],[11,"perform_removals_and_broad_phase","","Actually removes all the objects marked by `.deferred_remove(...)` and updates the broad\nphase.",115,null],[11,"perform_broad_phase","","Executes the broad phase of the collision detection pipeline.",115,null],[11,"perform_narrow_phase","","Executes the narrow phase of the collision detection pipeline.",115,null],[11,"set_narrow_phase","","Sets a new narrow phase and returns the previous one.",115,{"inputs":[{"name":"collisionworld"},{"name":"box"}],"output":{"name":"box"}}],[11,"contact_pairs","","Iterates through all the contact pairs detected since the last update.",115,{"inputs":[{"name":"collisionworld"}],"output":{"name":"contactpairs"}}],[11,"proximity_pairs","","Iterates through all the proximity pairs detected since the last update.",115,{"inputs":[{"name":"collisionworld"}],"output":{"name":"proximitypairs"}}],[11,"contacts","","Iterates through every contact detected since the last update.",115,{"inputs":[{"name":"collisionworld"}],"output":{"name":"contacts"}}],[11,"collision_objects","","Iterates through all collision objects.",115,{"inputs":[{"name":"collisionworld"}],"output":{"name":"values"}}],[11,"collision_object","","Returns a reference to the collision object identified by `uid`.",115,{"inputs":[{"name":"collisionworld"},{"name":"usize"}],"output":{"name":"option"}}],[11,"interferences_with_ray","","Computes the interferences between every rigid bodies on this world and a ray.",115,{"inputs":[{"name":"collisionworld"},{"name":"ray"},{"name":"collisiongroups"}],"output":{"name":"interferenceswithray"}}],[11,"interferences_with_point","","Computes the interferences between every rigid bodies of a given broad phase, and a point.",115,{"inputs":[{"name":"collisionworld"},{"name":"p"},{"name":"collisiongroups"}],"output":{"name":"interferenceswithpoint"}}],[11,"interferences_with_aabb","","Computes the interferences between every rigid bodies of a given broad phase, and a aabb.",115,{"inputs":[{"name":"collisionworld"},{"name":"aabb"},{"name":"collisiongroups"}],"output":{"name":"interferenceswithaabb"}}],[6,"ContactAlgorithm2","ncollide::narrow_phase","",null,null],[6,"ContactAlgorithm3","","",null,null],[3,"ShapeCompositeShapeContactGenerator","","Collision detector between a shape and a concave shape.",null,null],[3,"DefaultContactDispatcher","","Collision dispatcher for shapes defined by `ncollide_entities`.",null,null],[3,"ShapeCompositeShapeProximityDetector","","Proximity detector between a shape and a concave shape.",null,null],[3,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts.",null,null],[6,"ProximityAlgorithm","","",null,null],[3,"SupportMapPlaneProximityDetector","","Proximity detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"Contacts","","An iterator through contacts.",null,null],[8,"ContactDispatcher","","",null,null],[10,"get_contact_algorithm","","Allocate a collision algorithm corresponding to the given pair of shapes.",116,{"inputs":[{"name":"contactdispatcher"},{"name":"shape"},{"name":"shape"}],"output":{"name":"option"}}],[8,"ContactGenerator","","Trait implemented algorithms that compute contact points, normals and penetration depths.",null,null],[10,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",117,null],[10,"num_contacts","","The number of contacts generated the last update.",117,{"inputs":[{"name":"contactgenerator"}],"output":{"name":"usize"}}],[10,"contacts","","Collects the contacts generated during the last update.",117,null],[3,"SupportMapSupportMapProximityDetector","","Persistent proximity detector between two shapes having a support mapping function.",null,null],[3,"SupportMapPlaneContactGenerator","","Collision detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"SupportMapSupportMapContactGenerator","","Persistent collision detector between two shapes having a support mapping function.",null,null],[3,"DefaultProximityDispatcher","","Proximity dispatcher for shapes defined by `ncollide_entities`.",null,null],[3,"PlaneSupportMapProximityDetector","","Proximity detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"PlaneSupportMapContactGenerator","","Collision detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"CompositeShapeShapeContactGenerator","","Collision detector between a concave shape and another shape.",null,null],[3,"ProximityPairs","","Iterator through proximity pairs.",null,null],[3,"BallBallProximityDetector","","Proximity detector between two balls.",null,null],[3,"BallBallContactGenerator","","Collision detector between two balls.",null,null],[3,"DefaultNarrowPhase","","Collision detector dispatcher for collision objects.",null,null],[3,"CompositeShapeShapeProximityDetector","","Proximity detector between a concave shape and another shape.",null,null],[8,"ProximityHandler","","A signal handler for proximity detection.",null,null],[10,"handle_proximity","","Activate an action for when two objects start or stop to be close to each other.",118,null],[6,"ContactAlgorithm","","",null,null],[3,"ProximitySignal","","Signal for proximity start/stop.",null,null],[3,"ContactPairs","","Iterator through contact pairs.",null,null],[8,"ContactHandler","","A signal handler for contact detection.",null,null],[10,"handle_contact_started","","Activate an action for when two objects start being in contact.",119,null],[10,"handle_contact_stopped","","Activate an action for when two objects stop being in contact.",119,null],[8,"ProximityDispatcher","","",null,null],[10,"get_proximity_algorithm","","Allocate a collision algorithm corresponding to the given pair of shapes.",120,{"inputs":[{"name":"proximitydispatcher"},{"name":"shape"},{"name":"shape"}],"output":{"name":"option"}}],[8,"NarrowPhase","","Trait implemented by the narrow phase manager.",null,null],[10,"update","","Updates this narrow phase.",121,null],[10,"handle_interaction","","Called when the broad phase detects that two objects are, or stop to be, in close proximity.",121,null],[10,"contact_pairs","","Returns all the potential contact pairs found during the broad phase, and validated by the\nnarrow phase.",121,{"inputs":[{"name":"narrowphase"},{"name":"uidremap"}],"output":{"name":"contactpairs"}}],[10,"proximity_pairs","","Returns all the potential proximity pairs found during the broad phase, and validated by\nthe narrow phase.",121,{"inputs":[{"name":"narrowphase"},{"name":"uidremap"}],"output":{"name":"proximitypairs"}}],[8,"ProximityDetector","","Trait implemented by algorithms that determine if two objects are in close proximity.",null,null],[10,"update","","Runs the proximity detection on two objects. It is assumed that the same proximity detector\n(the same structure) is always used with the same pair of object.",122,null],[10,"proximity","","The number of collision detected during the last update.",122,{"inputs":[{"name":"proximitydetector"}],"output":{"name":"proximity"}}],[3,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update.",null,null],[3,"ContactSignal","","Signal for contact start/stop.",null,null],[0,"broad_phase","ncollide","Broad phases.",null,null],[8,"BroadPhasePairFilter","ncollide::broad_phase","A signal handler for contact detection.",null,null],[10,"is_pair_valid","","Activate an action for when two objects start or stop to be close to each other.",123,{"inputs":[{"name":"broadphasepairfilter"},{"name":"collisionobject"},{"name":"collisionobject"}],"output":{"name":"bool"}}],[8,"BroadPhase","","Trait all broad phase must implement.",null,null],[10,"deferred_add","","Tells the broad phase to add an element during the next update.",124,null],[10,"deferred_remove","","Tells the broad phase to remove an element during the next update.",124,null],[10,"deferred_set_bounding_volume","","Sets the next bounding volume to be used during the update of this broad phase.",124,null],[10,"deferred_recompute_all_proximities","","Forces the broad-phase to recompute and re-report all the proximities.",124,null],[10,"update","","Updates the object additions, removals, and interferences detection.",124,null],[10,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",124,null],[10,"interferences_with_ray","","Collects every object which might intersect a given ray.",124,null],[10,"interferences_with_point","","Collects every object which might contain a given point.",124,null],[3,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree.",null,null],[3,"BroadPhasePairFilters","","Filters deciding whether a proximity is to be further investigated by the narrow phase or not.",null,null],[3,"BruteForceBroadPhase","","A broad phase testing explicitly all bounding volume pairs.",null,null],[0,"world","ncollide","High level API to detect collisions in large, complex scenes.",null,null],[6,"CollisionWorld3","ncollide::world","",null,null],[6,"CollisionWorld2","","",null,null],[6,"CollisionObject3","","",null,null],[6,"CollisionObject2","","",null,null],[3,"CollisionGroups","","Groups of collision used to filter which object interact with which other one.",null,null],[3,"CollisionGroupsPairFilter","","A collision filter based collision groups.",null,null],[3,"CollisionWorld","","A world that handles collision objects.",null,null],[3,"CollisionObject","","A stand-alone object that has a position and a shape.",null,null],[12,"uid","","The collsion object unique identifier.",112,null],[12,"position","","The collision object position.",112,null],[12,"shape","","The collision object shape.",112,null],[12,"collision_groups","","The collision groups of the collision object.",112,null],[12,"query_type","","The kind of queries this collision object is expected to .",112,null],[12,"data","","The user-defined data associated to this object.",112,null],[6,"BroadPhaseObject","","",null,null],[4,"GeometricQueryType","","The kind of query a CollisionObject may be involved on.",null,null],[13,"Contacts","","This objects can respond to both contact point computation and proximity queries.",111,null],[13,"Proximity","","This object can respond to proximity tests only.",111,null],[0,"utils","ncollide::procedural","Utilities useful for various generations tasks.",null,null],[5,"push_circle","ncollide::procedural::utils","Pushes a discretized counterclockwise circle to a buffer.",null,null],[5,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis.",null,null],[5,"push_ring_indices","","Creates the faces from two circles with the same discretization.",null,null],[5,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.",null,null],[5,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle.",null,null],[5,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle.",null,null],[5,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`.",null,null],[5,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`.",null,null],[5,"reverse_clockwising","","Reverses the clockwising of a set of faces.",null,null],[5,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer.",null,null],[5,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex.",null,null],[5,"compute_normals","","Computes the normals of a set of vertices.",null,null],[0,"path","ncollide::procedural","Path generation.",null,null],[11,"new","ncollide_procedural::path::no_cap","Creates a new `NoCap`.",125,{"inputs":[],"output":{"name":"nocap"}}],[11,"gen_start_cap","","",125,null],[11,"gen_end_cap","","",125,null],[11,"new","ncollide_procedural::path::arrowhead_cap","Creates a cap that looks like an arrow.",126,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"arrowheadcap"}}],[11,"gen_end_cap","","",126,null],[11,"gen_start_cap","","",126,null],[11,"new","ncollide_procedural::path::polyline_pattern","Creates a new polyline pattern.",127,{"inputs":[{"name":"polyline"},{"name":"bool"},{"name":"c1"},{"name":"c2"}],"output":{"name":"polylinepattern"}}],[11,"stroke","","",127,{"inputs":[{"name":"polylinepattern"},{"name":"c"}],"output":{"name":"trimesh"}}],[11,"new","ncollide_procedural::path::polyline_path","Creates a new polyline-based path.",128,{"inputs":[{"name":"polyline"}],"output":{"name":"polylinepath"}}],[11,"next","","",128,{"inputs":[{"name":"polylinepath"}],"output":{"name":"pathsample"}}],[11,"fmt","ncollide_procedural::trimesh","",129,{"inputs":[{"name":"indexbuffer"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",129,{"inputs":[{"name":"indexbuffer"}],"output":{"name":"indexbuffer"}}],[11,"unwrap_unified","","Returns the unified index buffer data or fails.",129,{"inputs":[{"name":"indexbuffer"}],"output":{"name":"vec"}}],[11,"unwrap_split","","Returns the split index buffer data or fails.",129,{"inputs":[{"name":"indexbuffer"}],"output":{"name":"vec"}}],[11,"fmt","","",130,{"inputs":[{"name":"trimesh"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",130,{"inputs":[{"name":"trimesh"}],"output":{"name":"trimesh"}}],[11,"new","","Creates a new `TriMesh`.",130,{"inputs":[{"name":"vec"},{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"trimesh"}}],[11,"has_normals","","Whether or not this triangle mesh has normals.",130,{"inputs":[{"name":"trimesh"}],"output":{"name":"bool"}}],[11,"has_uvs","","Whether or not this triangle mesh has texture coordinates.",130,{"inputs":[{"name":"trimesh"}],"output":{"name":"bool"}}],[11,"translate_by","","Translates each vertex of this mesh.",130,null],[11,"transform_by","","Transforms each vertex and rotates each normal of this mesh.",130,null],[11,"num_triangles","","The number of triangles on this mesh.",130,{"inputs":[{"name":"trimesh"}],"output":{"name":"usize"}}],[11,"rotate_by","","Rotates each vertex and normal of this mesh.",130,null],[11,"recompute_normals","","Recomputes the mesh normals using its vertex coordinates and adjascency informations\ninfered from the index buffer.",130,null],[11,"scale_by","","Scales each vertex of this mesh.",130,null],[11,"scale_by_scalar","","Scales each vertex of this mesh.",130,null],[11,"unify_index_buffer","","Force the mesh to use the same index for vertices, normals and uvs.",130,null],[11,"split_index_buffer","","Forces the mesh to use a different index for the vertices, normals and uvs.",130,null],[11,"clone","ncollide_procedural::polyline","",131,{"inputs":[{"name":"polyline"}],"output":{"name":"polyline"}}],[11,"new","","Creates a new polyline.",131,{"inputs":[{"name":"vec"},{"name":"option"}],"output":{"name":"polyline"}}],[11,"unwrap","","Moves the polyline data out of it.",131,null],[11,"coords","","The coordinates of this polyline vertices.",131,null],[11,"coords_mut","","The mutable coordinates of this polyline vertices.",131,null],[11,"normals","","The normals of this polyline vertices.",131,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"normals_mut","","The mutable normals of this polyline vertices.",131,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"translate_by","","Translates each vertex of this polyline.",131,null],[11,"rotate_by","","Rotates each vertex and normal of this polyline.",131,null],[11,"transform_by","","Transforms each vertex and rotates each normal of this polyline.",131,null],[11,"scale_by_scalar","","Scales each vertex of this polyline.",131,null],[11,"scale_by","","Scales each vertex of this mesh.",131,null],[3,"NoCap","ncollide::procedural::path","A cap that renders nothing.",null,null],[3,"PolylinePath","","A path with its sample points given by a polyline.",null,null],[8,"StrokePattern","","A pattern that is replicated along a path.",null,null],[10,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",132,{"inputs":[{"name":"strokepattern"},{"name":"c"}],"output":{"name":"trimesh"}}],[8,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`.",null,null],[10,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",133,null],[10,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",133,null],[3,"PolylinePattern","","A pattern composed of polyline and two caps.",null,null],[4,"PathSample","","A sample point and its associated tangent.",null,null],[13,"StartPoint","","A point that starts a new path.",134,null],[13,"InnerPoint","","A point that is inside of the path currently generated.",134,null],[13,"EndPoint","","A point that ends the path currently generated.",134,null],[13,"EndOfSample","","Used when the sampler does not have any other points to generate.",134,null],[8,"CurveSampler","","A curve sampler.",null,null],[10,"next","","Returns the next sample point.",135,{"inputs":[{"name":"curvesampler"}],"output":{"name":"pathsample"}}],[3,"ArrowheadCap","","A cap that looks like an arrow.",null,null],[6,"TriMesh3","ncollide::procedural","",null,null],[6,"Polyline3","","",null,null],[6,"TriMesh2","","",null,null],[6,"Polyline2","","",null,null],[5,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface.",null,null],[5,"unit_hemisphere","","Creates an hemisphere with a diameter of 1.",null,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"trimesh"}}],[3,"Polyline","","Shapeetric description of a polyline.",null,null],[5,"circle","","Creates a circle lying on the `(x,y)` plane.",null,null],[5,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve.",null,null],[5,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane.",null,{"inputs":[],"output":{"name":"polyline"}}],[5,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices.",null,null],[5,"cylinder","","Generates a cylinder with a given height and diameter.",null,{"inputs":[{"name":"n"},{"name":"n"},{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"sphere","","Generates a UV sphere.",null,{"inputs":[{"name":"n"},{"name":"u32"},{"name":"u32"},{"name":"bool"}],"output":{"name":"trimesh"}}],[5,"capsule","","Generates a capsule.",null,{"inputs":[{"name":"n"},{"name":"n"},{"name":"u32"},{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"rectangle","","The contour of a cuboid lying on the x-y plane.",null,null],[5,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter.",null,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"bool"}],"output":{"name":"trimesh"}}],[5,"unit_cylinder","","Generates a cylinder with unit height and diameter.",null,{"inputs":[{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"unit_quad","","Adds a double-sided quad with unit size to the scene.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"trimesh"}}],[5,"cuboid","","Generates a cuboid shape with a split index buffer.",null,{"inputs":[{"name":"vector3"}],"output":{"name":"trimesh"}}],[5,"unit_cone","","Generates a cone with unit height and diameter.",null,{"inputs":[{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"unit_circle","","Creates a circle lying on the `(x,y)` plane.",null,{"inputs":[{"name":"u32"}],"output":{"name":"polyline"}}],[4,"IndexBuffer","","Different representations of the index buffer.",null,null],[13,"Unified","","The vertex, normal, and uvs share the same indices.",129,null],[13,"Split","","The vertex, normal, and uvs have different indices.",129,null],[5,"unit_cuboid","","Generates a cuboid shape with a split index buffer.",null,{"inputs":[],"output":{"name":"trimesh"}}],[3,"TriMesh","","Shapeetric description of a mesh.",null,null],[12,"coords","","Coordinates of the mesh vertices.",130,null],[12,"normals","","Coordinates of the mesh normals.",130,null],[12,"uvs","","Textures coordinates of the mesh.",130,null],[12,"indices","","Index buffer of the mesh.",130,null],[5,"cone","","Generates a cone with a given height and diameter.",null,{"inputs":[{"name":"n"},{"name":"n"},{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"quad","","Adds a double-sided quad to the scene.",null,null],[11,"to_trimesh","ncollide::shape","",47,null],[11,"to_trimesh","","",48,null],[11,"to_trimesh","","",49,{"inputs":[{"name":"cone"},{"name":"u32"}],"output":{"name":"trimesh"}}],[11,"to_trimesh","","",39,null],[11,"to_trimesh","","",50,{"inputs":[{"name":"cylinder"},{"name":"u32"}],"output":{"name":"trimesh"}}],[11,"to_trimesh","","",45,null],[11,"to_trimesh","","",40,null],[11,"to_trimesh","","",51,{"inputs":[{"name":"reflection"},{"name":"i"}],"output":{"name":"trimesh"}}],[11,"to_trimesh","","",43,null],[11,"to_polyline","","",47,{"inputs":[{"name":"ball"},{"name":"u32"}],"output":{"name":"polyline"}}],[11,"to_polyline","","",48,{"inputs":[{"name":"capsule"},{"name":"u32"}],"output":{"name":"polyline"}}],[11,"to_polyline","","",49,null],[11,"to_polyline","","",39,null],[11,"to_polyline","","",50,null],[11,"to_polyline","","",40,null],[11,"to_polyline","","",51,{"inputs":[{"name":"reflection"},{"name":"i"}],"output":{"name":"polyline"}}],[11,"to_polyline","","",42,null],[11,"to_polyline","","",43,null],[8,"ToPolyline","ncollide::transformation","Trait implemented by shapes that can be approximated by a triangle mesh.",null,null],[10,"to_polyline","","Builds a triangle mesh from this shape.",136,{"inputs":[{"name":"topolyline"},{"name":"i"}],"output":{"name":"polyline"}}],[5,"convex_hull2","","Computes the convex hull of a set of 2d points.",null,null],[8,"ToTriMesh","","Trait implemented by shapes that can be approximated by a triangle mesh.",null,null],[10,"to_trimesh","","Builds a triangle mesh from this shape.",137,{"inputs":[{"name":"totrimesh"},{"name":"i"}],"output":{"name":"trimesh"}}],[5,"hacd","","Approximate convex decomposition of a triangle mesh.",null,null],[5,"convex_hull3","","Computes the convex hull of a set of 3d points.",null,null],[5,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane.",null,null],[5,"convex_hull2_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices.",null,null]],"paths":[[8,"FloatError"],[8,"Point"],[8,"Vector"],[3,"Pair"],[3,"PairTWHash"],[3,"UintPairTWHash"],[3,"UintTWHash"],[3,"Entry"],[3,"HashMap"],[3,"OwnedAllocationCache"],[3,"VecSlice"],[3,"VecSliceMut"],[3,"RefWithCost"],[3,"FastKey"],[3,"UidRemap"],[3,"FastKeys"],[3,"FastKeysAndValues"],[3,"FastKeysAndValuesMut"],[3,"VecMap"],[4,"Entry"],[3,"VacantEntry"],[3,"OccupiedEntry"],[3,"Iter"],[3,"IterMut"],[3,"Keys"],[3,"Values"],[3,"IntoIter"],[3,"BacktrackingLineSearch"],[3,"HashablePartialEq"],[3,"Vector2"],[3,"Point2"],[3,"Vector3"],[3,"Point3"],[8,"HashFun"],[8,"LineSearch"],[8,"AsBytes"],[8,"Shape"],[3,"ShapeHandle"],[3,"Plane"],[3,"Cuboid"],[3,"MinkowskiSum"],[3,"AnnotatedMinkowskiSum"],[3,"Segment"],[3,"Triangle"],[3,"BaseMesh"],[3,"TriMesh"],[3,"Polyline"],[3,"Ball"],[3,"Capsule"],[3,"Cone"],[3,"Cylinder"],[3,"Reflection"],[3,"Torus"],[3,"Compound"],[3,"ConvexHull"],[3,"BoundingVolumeInterferencesCollector"],[3,"AABB"],[3,"BoundingSphere"],[3,"DBVT"],[3,"DBVTLeaf"],[3,"BVT"],[4,"BVTNode"],[3,"BoundingVolumeInterferencesCollector"],[3,"JohnsonSimplex"],[3,"RecursionTemplate"],[4,"GJKResult"],[3,"Contact"],[4,"Proximity"],[3,"Ray"],[3,"RayIntersection"],[3,"RayIntersectionCostFn"],[3,"RayInterferencesCollector"],[3,"PointProjection"],[3,"PointInterferencesCollector"],[8,"SupportMap"],[8,"CompositeShape"],[8,"BaseMeshElement"],[8,"BoundingVolume"],[8,"HasBoundingVolume"],[8,"BVTCostFn"],[8,"BVTVisitor"],[8,"BVTTVisitor"],[4,"BinaryPartition"],[8,"Simplex"],[8,"RayCast"],[8,"PointQuery"],[3,"BruteForceBroadPhase"],[3,"DBVTBroadPhase"],[3,"BroadPhasePairFilters"],[3,"DefaultContactDispatcher"],[3,"BallBallContactGenerator"],[3,"PlaneSupportMapContactGenerator"],[3,"SupportMapPlaneContactGenerator"],[3,"SupportMapSupportMapContactGenerator"],[3,"IncrementalContactManifoldGenerator"],[3,"OneShotContactManifoldGenerator"],[3,"CompositeShapeShapeContactGenerator"],[3,"ShapeCompositeShapeContactGenerator"],[3,"BallBallProximityDetector"],[3,"PlaneSupportMapProximityDetector"],[3,"SupportMapPlaneProximityDetector"],[3,"SupportMapSupportMapProximityDetector"],[3,"CompositeShapeShapeProximityDetector"],[3,"ShapeCompositeShapeProximityDetector"],[3,"DefaultProximityDispatcher"],[3,"ContactPairs"],[3,"Contacts"],[3,"ProximityPairs"],[3,"DefaultNarrowPhase"],[3,"ContactSignal"],[3,"ProximitySignal"],[4,"GeometricQueryType"],[3,"CollisionObject"],[3,"CollisionGroups"],[3,"CollisionGroupsPairFilter"],[3,"CollisionWorld"],[8,"ContactDispatcher"],[8,"ContactGenerator"],[8,"ProximityHandler"],[8,"ContactHandler"],[8,"ProximityDispatcher"],[8,"NarrowPhase"],[8,"ProximityDetector"],[8,"BroadPhasePairFilter"],[8,"BroadPhase"],[3,"NoCap"],[3,"ArrowheadCap"],[3,"PolylinePattern"],[3,"PolylinePath"],[4,"IndexBuffer"],[3,"TriMesh"],[3,"Polyline"],[8,"StrokePattern"],[8,"PolylineCompatibleCap"],[4,"PathSample"],[8,"CurveSampler"],[8,"ToPolyline"],[8,"ToTriMesh"]]};
initSearch(searchIndex);
