var searchIndex = {};
searchIndex["ncollide"] = {"doc":"ncollide\n========","items":[[8,"FloatError","ncollide::math","Trait for constant helping handling floating point computations.",null,null],[10,"epsilon","","Epsilon value used to perform fuzzy comparisons with zero.",0,{"inputs":[],"output":{"name":"self"}}],[8,"Scalar","","Trait implemented by scalar types.",null,null],[8,"Point","","Trait implemented by point types.",null,null],[16,"Vect","","Type of a point&#39;s tangent space element, i.e., the vector type.",1,null],[8,"Vector","","Trait implemented by vector types.",null,null],[16,"Scalar","","",2,null],[8,"Isometry","","Trait implemented by transformation matrices types.",null,null],[8,"HasInertiaMatrix","","Trait implement by vectors that are transformable by the inertia matrix `I`.",null,null],[0,"data","ncollide::utils","Data structure utilities.",null,null],[0,"pair","ncollide::utils::data","Hashable pair of objects implementing `HasUid`.",null,null],[11,"new","ncollide_utils::data::pair","Builds a new `Pair`.",3,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"pair"}}],[11,"decode","","",3,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",3,{"inputs":[{"name":"pair"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"pair"}],"output":{"name":"pair"}}],[11,"eq","","",3,{"inputs":[{"name":"pair"},{"name":"pair"}],"output":{"name":"bool"}}],[11,"decode","","",4,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",4,{"inputs":[{"name":"pairtwhash"},{"name":"__s"}],"output":{"name":"result"}}],[11,"new","","Creates a new PairTWHash",4,{"inputs":[],"output":{"name":"pairtwhash"}}],[11,"hash","","",4,{"inputs":[{"name":"pairtwhash"},{"name":"pair"}],"output":{"name":"usize"}}],[11,"decode","ncollide_utils::data::hash","",5,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",5,{"inputs":[{"name":"uintpairtwhash"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"uintpairtwhash"}],"output":{"name":"uintpairtwhash"}}],[11,"new","","Creates a new UintPairTWHash.",5,{"inputs":[],"output":{"name":"uintpairtwhash"}}],[11,"hash","","",5,null],[11,"decode","","",6,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",6,{"inputs":[{"name":"uinttwhash"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"uinttwhash"}],"output":{"name":"uinttwhash"}}],[11,"new","","Creates a new UintTWHash.",6,{"inputs":[],"output":{"name":"uinttwhash"}}],[11,"hash","","",6,{"inputs":[{"name":"uinttwhash"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"decode","ncollide_utils::data::hash_map","",7,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",7,{"inputs":[{"name":"entry"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"entry"}],"output":{"name":"entry"}}],[11,"decode","","",8,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",8,{"inputs":[{"name":"hashmap"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"hashmap"}],"output":{"name":"hashmap"}}],[11,"new","","Creates a new hash map.",8,{"inputs":[{"name":"h"}],"output":{"name":"hashmap"}}],[11,"new_with_capacity","","Creates a new hash map with a given capacity.",8,{"inputs":[{"name":"usize"},{"name":"h"}],"output":{"name":"hashmap"}}],[11,"elements","","The elements added to this hash map.",8,null],[11,"elements_mut","","The elements added to this hash map.",8,null],[11,"len","","The number of elements contained by this hashmap.",8,{"inputs":[{"name":"hashmap"}],"output":{"name":"usize"}}],[11,"is_empty","","Whether or not this hashmap is empty.",8,{"inputs":[{"name":"hashmap"}],"output":{"name":"bool"}}],[11,"clear","","Removes everything from this hashmap.",8,null],[11,"remove_elem_at","","Removes the element at the specified position of the element array.",8,{"inputs":[{"name":"hashmap"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"get_and_remove","","Removes an element and returns its value if it existed.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"option"}}],[11,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",8,{"inputs":[{"name":"hashmap"},{"name":"k"},{"name":"f"}],"output":{"name":"option"}}],[11,"insert_or_replace","","Inserts or replace an element.",8,{"inputs":[{"name":"hashmap"},{"name":"k"},{"name":"v"},{"name":"bool"}],"output":{"name":"v"}}],[11,"contains_key","","Checks whether this hashmap contains a specific key.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"bool"}}],[11,"find","","Finds a reference to the element with a given key.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"option"}}],[11,"insert","","Inserts an element on the hash map.",8,{"inputs":[{"name":"hashmap"},{"name":"k"},{"name":"v"}],"output":{"name":"bool"}}],[11,"remove","","Remove an element from the hash map.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"bool"}}],[11,"find_mut","","Gets a mutable reference to an element of the hashmap.",8,{"inputs":[{"name":"hashmap"},{"name":"k"}],"output":{"name":"option"}}],[11,"new","ncollide_utils::data::owned_allocation_cache","Initializes the cache.",9,{"inputs":[],"output":{"name":"ownedallocationcache"}}],[11,"alloc","","Box a value into a potentially already allocated box.",9,{"inputs":[{"name":"ownedallocationcache"},{"name":"t"}],"output":{"name":"box"}}],[11,"retain","","Retains a box which can be re-used by the `box` method.",9,null],[11,"clear","","Clears the cache, destroying any stored pointer.",9,null],[11,"new","ncollide_utils::data::vec_slice","Creates a new immutable slice.",10,null],[11,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",10,null],[11,"len","","The length of this slice.",10,{"inputs":[{"name":"vecslice"}],"output":{"name":"usize"}}],[11,"is_empty","","Whether or not this slice is empty.",10,{"inputs":[{"name":"vecslice"}],"output":{"name":"bool"}}],[11,"get","","Gets the i-th element of the slice.",10,{"inputs":[{"name":"vecslice"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",10,{"inputs":[{"name":"vecslice"},{"name":"usize"}],"output":{"name":"t"}}],[11,"new","","Creates a new mutable slice.",11,null],[11,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",11,null],[11,"len","","The length of this slice.",11,{"inputs":[{"name":"vecslicemut"}],"output":{"name":"usize"}}],[11,"is_empty","","Whether or not this slice is empty.",11,{"inputs":[{"name":"vecslicemut"}],"output":{"name":"bool"}}],[11,"as_slice","","Creates an immutable slice from this mutable slice.",11,{"inputs":[{"name":"vecslicemut"}],"output":{"name":"vecslice"}}],[11,"get","","Gets the i-th element of the slice.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_unchecked_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",11,{"inputs":[{"name":"vecslicemut"},{"name":"usize"}],"output":{"name":"t"}}],[11,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",11,null],[11,"new","ncollide_utils::data::ref_with_cost","Creates a new reference packed with a cost value.",12,{"inputs":[{"name":"t"},{"name":"n"}],"output":{"name":"refwithcost"}}],[11,"eq","","",12,{"inputs":[{"name":"refwithcost"},{"name":"refwithcost"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",12,{"inputs":[{"name":"refwithcost"},{"name":"refwithcost"}],"output":{"name":"option"}}],[11,"cmp","","",12,{"inputs":[{"name":"refwithcost"},{"name":"refwithcost"}],"output":{"name":"ordering"}}],[11,"decode","ncollide_utils::data::uid_remap","",13,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",13,{"inputs":[{"name":"fastkey"},{"name":"__s"}],"output":{"name":"result"}}],[11,"cmp","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"option"}}],[11,"lt","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"le","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"gt","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"ge","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"eq","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"fastkey"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"hash","","",13,null],[11,"clone","","",13,{"inputs":[{"name":"fastkey"}],"output":{"name":"fastkey"}}],[11,"fmt","","",13,{"inputs":[{"name":"fastkey"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new_invalid","","Creates a new invalid key that won&#39;t be used by the `UidRemap` structure, ever.",13,{"inputs":[],"output":{"name":"fastkey"}}],[11,"uid","","The small uid contained by this key.",13,{"inputs":[{"name":"fastkey"}],"output":{"name":"usize"}}],[11,"decode","","",14,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",14,{"inputs":[{"name":"lookupdata"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"lookupdata"}],"output":{"name":"lookupdata"}}],[11,"fmt","","",14,{"inputs":[{"name":"lookupdata"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"uidremap"}],"output":{"name":"uidremap"}}],[11,"fmt","","",15,{"inputs":[{"name":"uidremap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"uidremap"}}],[11,"new","","Creates an empty `UidRemap`.",15,{"inputs":[{"name":"bool"}],"output":{"name":"uidremap"}}],[11,"get_fast_key","","Gets the fast key associated to the given key.",15,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"len","","Return the number of elements in the map.",15,{"inputs":[{"name":"uidremap"}],"output":{"name":"usize"}}],[11,"is_empty","","Return true if the map contains no elements.",15,{"inputs":[{"name":"uidremap"}],"output":{"name":"bool"}}],[11,"clear","","Clears the map, removing all key-value pairs.",15,null],[11,"get","","Returns a reference to the value corresponding to the key.",15,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get_fast","","Returns a reference to the value corresponding to the fast key.",15,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"option"}}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",15,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"contains_fast_key","","Returns true if the map contains a value for the specified fast key.",15,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",15,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get_fast_mut","","Returns a mutable reference to the value corresponding to the fast key.",15,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair to the map. If the key already had a value\npresent in the map, that value and its fast key are returned. Otherwise, `None` is\nreturned.",15,null],[11,"remove","","Removes a key from the map, returning the value at the key if the key exists.",15,{"inputs":[{"name":"uidremap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"keys","","Returns an iterator visiting all keys.",15,{"inputs":[{"name":"uidremap"}],"output":{"name":"fastkeys"}}],[11,"values","","Returns an iterator visiting all values.\nThe iterator&#39;s element type is `&amp;&#39;r O`.",15,{"inputs":[{"name":"uidremap"}],"output":{"name":"values"}}],[11,"iter","","Returns an iterator visiting all key-value pairs.",15,{"inputs":[{"name":"uidremap"}],"output":{"name":"fastkeysandvalues"}}],[11,"iter_mut","","Returns an iterator visiting all key-value pairs with mutable references to the values.",15,{"inputs":[{"name":"uidremap"}],"output":{"name":"fastkeysandvaluesmut"}}],[11,"next","","",16,{"inputs":[{"name":"fastkeys"}],"output":{"name":"option"}}],[11,"next","","",17,{"inputs":[{"name":"fastkeysandvalues"}],"output":{"name":"option"}}],[11,"next","","",18,{"inputs":[{"name":"fastkeysandvaluesmut"}],"output":{"name":"option"}}],[11,"update","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",15,{"inputs":[{"name":"uidremap"},{"name":"usize"},{"name":"o"},{"name":"f"}],"output":{"name":"bool"}}],[11,"update_with_key","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `key, oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",15,{"inputs":[{"name":"uidremap"},{"name":"usize"},{"name":"o"},{"name":"f"}],"output":{"name":"bool"}}],[11,"from_iter","","",15,{"inputs":[{"name":"i"}],"output":{"name":"uidremap"}}],[11,"extend","","",15,null],[11,"index","","",15,{"inputs":[{"name":"uidremap"},{"name":"fastkey"}],"output":{"name":"o"}}],[11,"default","ncollide_utils::data::vec_map","",19,{"inputs":[],"output":{"name":"vecmap"}}],[11,"clone","","",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"vecmap"}}],[11,"clone_from","","",19,null],[11,"hash","","",19,null],[11,"new","","Creates an empty `VecMap`.",19,{"inputs":[],"output":{"name":"vecmap"}}],[11,"with_capacity","","Creates an empty `VecMap` with space for at least `capacity`\nelements before resizing.",19,{"inputs":[{"name":"usize"}],"output":{"name":"vecmap"}}],[11,"capacity","","Returns the number of elements the `VecMap` can hold without\nreallocating.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"usize"}}],[11,"reserve_len","","Reserves capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long\nas all inserted keys are less than `len`.",19,null],[11,"reserve_len_exact","","Reserves the minimum capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long as all inserted\nkeys are less than `len`.",19,null],[11,"keys","","Returns an iterator visiting all keys in ascending order of the keys.\nThe iterator&#39;s element type is `usize`.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"keys"}}],[11,"values","","Returns an iterator visiting all values in ascending order of the keys.\nThe iterator&#39;s element type is `&amp;&#39;r V`.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"values"}}],[11,"iter","","Returns an iterator visiting all key-value pairs in ascending order of the keys.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r V)`.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns an iterator visiting all key-value pairs in ascending order of the keys,\nwith mutable references to the values.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r mut V)`.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"itermut"}}],[11,"split_off","","Splits the collection into two at the given key.",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"vecmap"}}],[11,"len","","Returns the number of elements in the map.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if the map contains no elements.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"bool"}}],[11,"clear","","Clears the map, removing all key-value pairs.",19,null],[11,"get","","Returns a reference to the value corresponding to the key.",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair into the map. If the key already had a value\npresent in the map, that value is returned. Otherwise, `None` is returned.",19,{"inputs":[{"name":"vecmap"},{"name":"usize"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"entry","","Gets the given key&#39;s corresponding entry in the map for in-place manipulation.",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"entry"}}],[11,"get","","Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant",20,{"inputs":[{"name":"entry"}],"output":{"name":"result"}}],[11,"or_insert","","Ensures a value is in the entry by inserting the default if empty, and returns\na mutable reference to the value in the entry.",20,{"inputs":[{"name":"entry"},{"name":"v"}],"output":{"name":"v"}}],[11,"or_insert_with","","Ensures a value is in the entry by inserting the result of the default function if empty,\nand returns a mutable reference to the value in the entry.",20,{"inputs":[{"name":"entry"},{"name":"f"}],"output":{"name":"v"}}],[11,"insert","","Sets the value of the entry with the VacantEntry&#39;s key,\nand returns a mutable reference to it.",21,{"inputs":[{"name":"vacantentry"},{"name":"v"}],"output":{"name":"v"}}],[11,"get","","Gets a reference to the value in the entry.",22,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"get_mut","","Gets a mutable reference to the value in the entry.",22,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"into_mut","","Converts the entry into a mutable reference to its value.",22,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"insert","","Sets the value of the entry with the OccupiedEntry&#39;s key,\nand returns the entry&#39;s old value.",22,{"inputs":[{"name":"occupiedentry"},{"name":"v"}],"output":{"name":"v"}}],[11,"remove","","Takes the value of the entry out of the map, and returns it.",22,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"fmt","","",19,{"inputs":[{"name":"vecmap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_iter","","",19,{"inputs":[{"name":"i"}],"output":{"name":"vecmap"}}],[11,"into_iter","","Returns an iterator visiting all key-value pairs in ascending order of\nthe keys, consuming the original `VecMap`.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r V)`.",19,{"inputs":[{"name":"vecmap"}],"output":{"name":"intoiter"}}],[11,"extend","","",19,null],[11,"index","","",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index","","",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index_mut","","",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index_mut","","",19,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"clone","","",23,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"next","","",23,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",23,null],[11,"next_back","","",23,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",24,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"size_hint","","",24,null],[11,"next_back","","",24,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"clone","","",25,{"inputs":[{"name":"keys"}],"output":{"name":"keys"}}],[11,"clone","","",26,{"inputs":[{"name":"values"}],"output":{"name":"values"}}],[11,"next","","",25,{"inputs":[{"name":"keys"}],"output":{"name":"option"}}],[11,"size_hint","","",25,null],[11,"next_back","","",25,{"inputs":[{"name":"keys"}],"output":{"name":"option"}}],[11,"next","","",26,{"inputs":[{"name":"values"}],"output":{"name":"option"}}],[11,"size_hint","","",26,null],[11,"next_back","","",26,{"inputs":[{"name":"values"}],"output":{"name":"option"}}],[11,"next","","",27,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",27,null],[11,"next_back","","",27,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"new","ncollide_utils::optimization","Creates a new backtracking line search methods.",28,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"usize"}],"output":{"name":"backtrackinglinesearch"}}],[11,"step_size","","",28,{"inputs":[{"name":"backtrackinglinesearch"},{"name":"f"},{"name":"v"},{"name":"v"},{"name":"v"}],"output":{"name":"n"}}],[11,"fmt","ncollide_utils::hashable_partial_eq","",29,{"inputs":[{"name":"hashablepartialeq"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"hashablepartialeq"}],"output":{"name":"hashablepartialeq"}}],[11,"decode","","",29,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",29,{"inputs":[{"name":"hashablepartialeq"},{"name":"__s"}],"output":{"name":"result"}}],[11,"eq","","",29,{"inputs":[{"name":"hashablepartialeq"},{"name":"hashablepartialeq"}],"output":{"name":"bool"}}],[11,"ne","","",29,{"inputs":[{"name":"hashablepartialeq"},{"name":"hashablepartialeq"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `HashablePartialEq`. This is unsafe because you must be sure that you really\nwant to transform the wrapped object&#39;s partial equality to an equivalence relation.",29,{"inputs":[{"name":"t"}],"output":{"name":"hashablepartialeq"}}],[11,"unwrap","","Gets the wrapped value.",29,{"inputs":[{"name":"hashablepartialeq"}],"output":{"name":"t"}}],[11,"hash","","",29,null],[3,"Pair","ncollide::utils::data::pair","An unordered pair of elements implementing `HasUid`.",null,null],[12,"first","","first object of the pair",3,null],[12,"second","","second object of the pair",3,null],[3,"PairTWHash","","Tomas Wang based hash function for a `Pair` object.",null,null],[0,"hash","ncollide::utils::data","Trait for hash functions.",null,null],[8,"HashFun","ncollide::utils::data::hash","Hash function.",null,null],[10,"hash","","Hash function.",30,{"inputs":[{"name":"hashfun"},{"name":"k"}],"output":{"name":"usize"}}],[3,"UintPairTWHash","","Hash function for pairs of `usize`, using the Tomas Wang hash.",null,null],[3,"UintTWHash","","Hash function for `usize`.",null,null],[5,"key_from_pair","","Combines two `usize` on a single one.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"tomas_wang_hash","","Tomas Wang integer hash function.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[0,"hash_map","ncollide::utils::data","An hash map with a customizable hash function.",null,null],[3,"Entry","ncollide::utils::data::hash_map","Entry of an `HashMap`.",null,null],[12,"key","","The key of the entry.",7,null],[12,"value","","The value of the entry.",7,null],[3,"HashMap","","Alternative implementation of `HashMap`.",null,null],[0,"owned_allocation_cache","ncollide::utils::data","Allocation cache for owned objects.",null,null],[3,"OwnedAllocationCache","ncollide::utils::data::owned_allocation_cache","Cache for owned objects.",null,null],[0,"vec_slice","ncollide::utils::data","Slicing on non-contiguous data.",null,null],[3,"VecSlice","ncollide::utils::data::vec_slice","A vector slice with a specific length and stride.",null,null],[3,"VecSliceMut","","A mutable vector slice with a specific length and stride.",null,null],[0,"ref_with_cost","ncollide::utils::data","A reference packed with a cost value.",null,null],[3,"RefWithCost","ncollide::utils::data::ref_with_cost","A reference packed with a cost value.",null,null],[12,"object","","The reference to an object.",12,null],[12,"cost","","The cost of the object.",12,null],[0,"uid_remap","ncollide::utils::data","A map allowing a slow lookup for arbitrary `usize` and fast lookup for small ones.",null,null],[3,"FastKey","ncollide::utils::data::uid_remap","A special type of key used by `UidRemap` to perform faster lookups than with the user-defined\nid of type `usize`.",null,null],[3,"UidRemap","","A set of values having large usize key.",null,null],[3,"FastKeys","","An iterator through a `UidRemap` fast keys in use.",null,null],[3,"FastKeysAndValues","","An iterator through a `UidRemap` fast keys and values.",null,null],[3,"FastKeysAndValuesMut","","An iterator through a `UidRemap` fast keys and values.",null,null],[0,"vec_map","ncollide::utils::data","A simple map based on a vector for small integer keys. Space requirements\nare O(highest integer key).",null,null],[3,"VecMap","ncollide::utils::data::vec_map","A map optimized for small integer keys.",null,null],[4,"Entry","","A view into a single entry in a map, which may either be vacant or occupied.",null,null],[13,"Vacant","","A vacant Entry",20,null],[13,"Occupied","","An occupied Entry",20,null],[3,"VacantEntry","","A vacant Entry.",null,null],[3,"OccupiedEntry","","An occupied Entry.",null,null],[3,"Iter","","An iterator over the key-value pairs of a map.",null,null],[3,"IterMut","","An iterator over the key-value pairs of a map, with the\nvalues being mutable.",null,null],[3,"Keys","","An iterator over the keys of a map.",null,null],[3,"Values","","An iterator over the values of a map.",null,null],[3,"IntoIter","","A consuming iterator over the key-value pairs of a map.",null,null],[5,"center","ncollide::utils","Computes the center of a set of point.",null,null],[5,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component.",null,null],[5,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component.",null,null],[5,"circumcircle","","Computes the circumcircle of a triangle.",null,null],[5,"is_affinely_dependent_triangle3","","Tests if three 3D points are exactly aligned without the need of the `Cross` trait.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"bool"}}],[5,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"bool"}}],[5,"is_point_in_triangle","","Tests if a point is inside of a triangle.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"bool"}}],[5,"triangle_area","","Computes the area of a triangle.",null,null],[5,"triangle_center","","Computes the center of a triangle.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"p"}}],[5,"triangle_perimeter","","Computes the perimeter of a triangle.",null,null],[5,"tetrahedron_volume","","Computes the volume of a tetrahedron.",null,null],[5,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron.",null,null],[5,"tetrahedron_center","","Computes the center of a tetrahedron.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"p"}}],[5,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed.",null,null],[5,"dcos","","Computes the n-th derivative of the cosinus function.",null,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"n"}}],[5,"dsin","","Computes the n-th derivative of the sinus function.",null,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"n"}}],[5,"binom","","Computes the binomial coefficient C^k_n (&quot;k among n&quot;).",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"maximize_with_newton","","Maximizes a real function using the Newton method.",null,null],[5,"newton","","Finds the root of a function using the Newton method.",null,null],[5,"minimize_with_bfgs","","Minimizes a function using the bfgs method.",null,null],[5,"bfgs","","Minimizes a function using the quasi-newton BFGS method.",null,null],[8,"LineSearch","","Trait for line search methods.",null,null],[10,"step_size","","Gets a near-optimal step size for the next descent.",31,{"inputs":[{"name":"linesearch"},{"name":"f"},{"name":"v"},{"name":"v"},{"name":"v"}],"output":{"name":"n"}}],[3,"BacktrackingLineSearch","","The backtracking line search method.",null,null],[3,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`.",null,null],[8,"AsBytes","","Trait that transforms thing to a slice of u8.",null,null],[10,"as_bytes","","",32,null],[5,"cov","","Computes the convariance matrix of a set of points.",null,null],[5,"cov_and_center","","Computes the covariance matrix and center of a set of points.",null,null],[5,"center_reduce","","Centers and reduces a set of data.",null,null],[5,"median","","Computes the median of a set of values.",null,null],[5,"sort3","","Sorts a set of three values in increasing order.",null,null],[5,"cross3","","A 3d cross product that do not require the `Cross&lt;Self, Self&gt;` trait impl.",null,{"inputs":[{"name":"v"},{"name":"v"}],"output":{"name":"v"}}],[0,"shape","ncollide","Collision shapes supported by ncollide.",null,null],[11,"decode","ncollide_entities::shape::plane","",33,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",33,{"inputs":[{"name":"plane"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",33,{"inputs":[{"name":"plane"}],"output":{"name":"plane"}}],[11,"fmt","","",33,{"inputs":[{"name":"plane"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",33,{"inputs":[{"name":"plane"},{"name":"plane"}],"output":{"name":"bool"}}],[11,"ne","","",33,{"inputs":[{"name":"plane"},{"name":"plane"}],"output":{"name":"bool"}}],[11,"new","","Builds a new plane from its center and its normal.",33,{"inputs":[{"name":"v"}],"output":{"name":"plane"}}],[11,"new_normalized","","Builds a new plane from its center and its normal.",33,{"inputs":[{"name":"v"}],"output":{"name":"plane"}}],[11,"normal","","The plane normal.",33,{"inputs":[{"name":"plane"}],"output":{"name":"v"}}],[11,"repr","","",33,{"inputs":[{"name":"plane"}],"output":{"name":"reprdesc"}}],[11,"decode","ncollide_entities::shape::cuboid","",34,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",34,{"inputs":[{"name":"cuboid"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",34,{"inputs":[{"name":"cuboid"}],"output":{"name":"cuboid"}}],[11,"fmt","","",34,{"inputs":[{"name":"cuboid"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",34,{"inputs":[{"name":"cuboid"},{"name":"cuboid"}],"output":{"name":"bool"}}],[11,"ne","","",34,{"inputs":[{"name":"cuboid"},{"name":"cuboid"}],"output":{"name":"bool"}}],[11,"new","","Creates a new box from its half-extents. Half-extents are the box half-width along each\naxis. Each half-extent must be greater than 0.04.",34,{"inputs":[{"name":"v"}],"output":{"name":"cuboid"}}],[11,"half_extents","","The half-extents of this box. Half-extents are the box half-width along each axis.",34,{"inputs":[{"name":"cuboid"}],"output":{"name":"v"}}],[11,"fmt","ncollide_entities::shape::minkowski_sum","",35,{"inputs":[{"name":"minkowskisum"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",35,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"}],"output":{"name":"minkowskisum"}}],[11,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",35,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"m"}}],[11,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",35,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"m"}}],[11,"g1","","The first shape of this Minkowski Sum.",35,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"g1"}}],[11,"g2","","The second shape of this Minkowski Sum.",35,{"inputs":[{"name":"minkowskisum"}],"output":{"name":"g2"}}],[11,"fmt","","",36,{"inputs":[{"name":"annotatedminkowskisum"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",36,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"}],"output":{"name":"annotatedminkowskisum"}}],[11,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",36,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"m"}}],[11,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",36,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"m"}}],[11,"g1","","The first shape of this Minkowski Sum.",36,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"g1"}}],[11,"g2","","The second shape of this Minkowski Sum.",36,{"inputs":[{"name":"annotatedminkowskisum"}],"output":{"name":"g2"}}],[11,"decode","ncollide_entities::shape::segment","",37,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",37,{"inputs":[{"name":"segment"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",37,{"inputs":[{"name":"segment"}],"output":{"name":"segment"}}],[11,"fmt","","",37,{"inputs":[{"name":"segment"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",37,{"inputs":[{"name":"segment"},{"name":"segment"}],"output":{"name":"bool"}}],[11,"ne","","",37,{"inputs":[{"name":"segment"},{"name":"segment"}],"output":{"name":"bool"}}],[11,"new","","Creates a new segment from two points.",37,{"inputs":[{"name":"p"},{"name":"p"}],"output":{"name":"segment"}}],[11,"a","","The first point of this segment.",37,{"inputs":[{"name":"segment"}],"output":{"name":"p"}}],[11,"b","","The second point of this segment.",37,{"inputs":[{"name":"segment"}],"output":{"name":"p"}}],[11,"new_with_vertices_and_indices","","",37,null],[11,"decode","ncollide_entities::shape::triangle","",38,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",38,{"inputs":[{"name":"triangle"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"triangle"}],"output":{"name":"triangle"}}],[11,"fmt","","",38,{"inputs":[{"name":"triangle"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",38,{"inputs":[{"name":"triangle"},{"name":"triangle"}],"output":{"name":"bool"}}],[11,"ne","","",38,{"inputs":[{"name":"triangle"},{"name":"triangle"}],"output":{"name":"bool"}}],[11,"new","","Creates a triangle from three points.",38,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"}],"output":{"name":"triangle"}}],[11,"a","","The fist point of this triangle.",38,{"inputs":[{"name":"triangle"}],"output":{"name":"p"}}],[11,"b","","The second point of this triangle.",38,{"inputs":[{"name":"triangle"}],"output":{"name":"p"}}],[11,"c","","The third point of this triangle.",38,{"inputs":[{"name":"triangle"}],"output":{"name":"p"}}],[11,"new_with_vertices_and_indices","","",38,null],[11,"clone","ncollide_entities::shape::base_mesh","",39,{"inputs":[{"name":"basemesh"}],"output":{"name":"basemesh"}}],[11,"new","","Builds a new mesh.",39,{"inputs":[{"name":"arc"},{"name":"arc"},{"name":"option"},{"name":"option"}],"output":{"name":"basemesh"}}],[11,"vertices","","The vertices of this mesh.",39,{"inputs":[{"name":"basemesh"}],"output":{"name":"arc"}}],[11,"len","","The number of primitives on thes mesh.",39,{"inputs":[{"name":"basemesh"}],"output":{"name":"usize"}}],[11,"bounding_volumes","","Bounding volumes of the subsimplices.",39,null],[11,"indices","","The indices of this mesh.",39,{"inputs":[{"name":"basemesh"}],"output":{"name":"arc"}}],[11,"uvs","","The texture coordinates of this mesh.",39,{"inputs":[{"name":"basemesh"}],"output":{"name":"option"}}],[11,"normals","","The normals of this mesh.",39,{"inputs":[{"name":"basemesh"}],"output":{"name":"option"}}],[11,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",39,{"inputs":[{"name":"basemesh"}],"output":{"name":"bvt"}}],[11,"element_at","","Gets the i-th mesh element.",39,{"inputs":[{"name":"basemesh"},{"name":"usize"}],"output":{"name":"e"}}],[11,"clone","ncollide_entities::shape::trimesh","",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"trimesh"}}],[11,"new","","Builds a new mesh.",40,{"inputs":[{"name":"arc"},{"name":"arc"},{"name":"option"},{"name":"option"}],"output":{"name":"trimesh"}}],[11,"base_mesh","","The base representation of this mesh.",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"basemesh"}}],[11,"vertices","","The vertices of this mesh.",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"arc"}}],[11,"bounding_volumes","","Bounding volumes of the subsimplices.",40,null],[11,"indices","","The indices of this mesh.",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"arc"}}],[11,"uvs","","The texture coordinates of this mesh.",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"option"}}],[11,"normals","","The normals of this mesh.",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"option"}}],[11,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"bvt"}}],[11,"triangle_at","","Gets the i-th mesh element.",40,{"inputs":[{"name":"trimesh"},{"name":"usize"}],"output":{"name":"triangle"}}],[11,"clone","ncollide_entities::shape::polyline","",41,{"inputs":[{"name":"polyline"}],"output":{"name":"polyline"}}],[11,"new","","Builds a new mesh.",41,{"inputs":[{"name":"arc"},{"name":"arc"},{"name":"option"},{"name":"option"}],"output":{"name":"polyline"}}],[11,"base_mesh","","The base representation of this mesh.",41,{"inputs":[{"name":"polyline"}],"output":{"name":"basemesh"}}],[11,"vertices","","The vertices of this mesh.",41,{"inputs":[{"name":"polyline"}],"output":{"name":"arc"}}],[11,"bounding_volumes","","Bounding volumes of the subsimplices.",41,null],[11,"indices","","The indices of this mesh.",41,{"inputs":[{"name":"polyline"}],"output":{"name":"arc"}}],[11,"uvs","","The texture coordinates of this mesh.",41,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"normals","","The normals of this mesh.",41,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",41,{"inputs":[{"name":"polyline"}],"output":{"name":"bvt"}}],[11,"segment_at","","Gets the i-th mesh element.",41,{"inputs":[{"name":"polyline"},{"name":"usize"}],"output":{"name":"segment"}}],[11,"decode","ncollide_entities::shape::ball","",42,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",42,{"inputs":[{"name":"ball"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",42,{"inputs":[{"name":"ball"}],"output":{"name":"ball"}}],[11,"fmt","","",42,{"inputs":[{"name":"ball"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",42,{"inputs":[{"name":"ball"},{"name":"ball"}],"output":{"name":"bool"}}],[11,"ne","","",42,{"inputs":[{"name":"ball"},{"name":"ball"}],"output":{"name":"bool"}}],[11,"new","","Creates a new ball from its radius and center.",42,{"inputs":[{"name":"n"}],"output":{"name":"ball"}}],[11,"radius","","The ball radius.",42,{"inputs":[{"name":"ball"}],"output":{"name":"n"}}],[11,"decode","ncollide_entities::shape::capsule","",43,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",43,{"inputs":[{"name":"capsule"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",43,{"inputs":[{"name":"capsule"}],"output":{"name":"capsule"}}],[11,"fmt","","",43,{"inputs":[{"name":"capsule"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",43,{"inputs":[{"name":"capsule"},{"name":"capsule"}],"output":{"name":"bool"}}],[11,"ne","","",43,{"inputs":[{"name":"capsule"},{"name":"capsule"}],"output":{"name":"bool"}}],[11,"new","","Creates a new capsule.",43,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"capsule"}}],[11,"half_height","","The capsule half length along the `y` axis.",43,{"inputs":[{"name":"capsule"}],"output":{"name":"n"}}],[11,"radius","","The radius of the capsule&#39;s rounded part.",43,{"inputs":[{"name":"capsule"}],"output":{"name":"n"}}],[11,"decode","ncollide_entities::shape::cone","",44,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",44,{"inputs":[{"name":"cone"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",44,{"inputs":[{"name":"cone"}],"output":{"name":"cone"}}],[11,"fmt","","",44,{"inputs":[{"name":"cone"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",44,{"inputs":[{"name":"cone"},{"name":"cone"}],"output":{"name":"bool"}}],[11,"ne","","",44,{"inputs":[{"name":"cone"},{"name":"cone"}],"output":{"name":"bool"}}],[11,"new","","Creates a new cone.",44,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"cone"}}],[11,"half_height","","The cone half length along the `y` axis.",44,{"inputs":[{"name":"cone"}],"output":{"name":"n"}}],[11,"radius","","The radius of the cone along all but the `y` axis.",44,{"inputs":[{"name":"cone"}],"output":{"name":"n"}}],[11,"decode","ncollide_entities::shape::cylinder","",45,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",45,{"inputs":[{"name":"cylinder"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",45,{"inputs":[{"name":"cylinder"}],"output":{"name":"cylinder"}}],[11,"fmt","","",45,{"inputs":[{"name":"cylinder"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",45,{"inputs":[{"name":"cylinder"},{"name":"cylinder"}],"output":{"name":"bool"}}],[11,"ne","","",45,{"inputs":[{"name":"cylinder"},{"name":"cylinder"}],"output":{"name":"bool"}}],[11,"new","","Creates a new cylinder.",45,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"cylinder"}}],[11,"half_height","","The cylinder half length along the `y` axis.",45,{"inputs":[{"name":"cylinder"}],"output":{"name":"n"}}],[11,"radius","","The radius of the cylinder along all but the `y` axis.",45,{"inputs":[{"name":"cylinder"}],"output":{"name":"n"}}],[11,"fmt","ncollide_entities::shape::reflection","",46,{"inputs":[{"name":"reflection"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Build the reflection of a shape. Since the representation is implicit,\nthe reflection computation is done in constant time.",46,{"inputs":[{"name":"g"}],"output":{"name":"reflection"}}],[11,"shape","","The reflected shape.",46,{"inputs":[{"name":"reflection"}],"output":{"name":"g"}}],[11,"decode","ncollide_entities::shape::torus","",47,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",47,{"inputs":[{"name":"torus"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",47,{"inputs":[{"name":"torus"}],"output":{"name":"torus"}}],[11,"fmt","","",47,{"inputs":[{"name":"torus"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",47,{"inputs":[{"name":"torus"},{"name":"torus"}],"output":{"name":"bool"}}],[11,"ne","","",47,{"inputs":[{"name":"torus"},{"name":"torus"}],"output":{"name":"bool"}}],[11,"new","","Creates a new torus with the given radiuses.",47,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"torus"}}],[11,"minor_radius","","The torus minor radius.",47,{"inputs":[{"name":"torus"}],"output":{"name":"n"}}],[11,"major_radius","","The torus major radius.",47,{"inputs":[{"name":"torus"}],"output":{"name":"n"}}],[11,"clone","ncollide_entities::shape::compound","",48,{"inputs":[{"name":"compound"}],"output":{"name":"compound"}}],[11,"new","","Builds a new compound shape.",48,{"inputs":[{"name":"vec"}],"output":{"name":"compound"}}],[11,"shapes","","The shapes of this compound shape.",48,null],[11,"bvt","","The optimization structure used by this compound shape.",48,{"inputs":[{"name":"compound"}],"output":{"name":"bvt"}}],[11,"bounding_volumes","","The shapes bounding volumes.",48,null],[11,"aabb_at","","The AABB of the i-th shape compositing this compound.",48,{"inputs":[{"name":"compound"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"decode","ncollide_entities::shape::convex","",49,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",49,{"inputs":[{"name":"convexhull"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",49,{"inputs":[{"name":"convexhull"}],"output":{"name":"convexhull"}}],[11,"fmt","","",49,{"inputs":[{"name":"convexhull"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",49,{"inputs":[{"name":"convexhull"},{"name":"convexhull"}],"output":{"name":"bool"}}],[11,"ne","","",49,{"inputs":[{"name":"convexhull"},{"name":"convexhull"}],"output":{"name":"bool"}}],[11,"new","","Creates a polytope from a set of point.",49,{"inputs":[{"name":"vec"}],"output":{"name":"convexhull"}}],[11,"points","","The list of points of this convex polytope.",49,null],[11,"len","ncollide_entities::shape::compound","",48,{"inputs":[{"name":"compound"}],"output":{"name":"usize"}}],[11,"map_part_at","","",48,null],[11,"map_transformed_part_at","","",48,null],[11,"aabb_at","","",48,{"inputs":[{"name":"compound"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"bvt","","",48,{"inputs":[{"name":"compound"}],"output":{"name":"bvt"}}],[11,"len","ncollide_entities::shape::trimesh","",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"usize"}}],[11,"map_part_at","","",40,null],[11,"map_transformed_part_at","","",40,null],[11,"aabb_at","","",40,{"inputs":[{"name":"trimesh"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"bvt","","",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"bvt"}}],[11,"len","ncollide_entities::shape::polyline","",41,{"inputs":[{"name":"polyline"}],"output":{"name":"usize"}}],[11,"map_part_at","","",41,null],[11,"map_transformed_part_at","","",41,null],[11,"aabb_at","","",41,{"inputs":[{"name":"polyline"},{"name":"usize"}],"output":{"name":"aabb"}}],[11,"bvt","","",41,{"inputs":[{"name":"polyline"}],"output":{"name":"bvt"}}],[11,"clone","ncollide_entities::shape::shape","",50,{"inputs":[{"name":"shapehandle"}],"output":{"name":"shapehandle"}}],[11,"new","","Creates a sharable shape handle from a shape.",50,{"inputs":[{"name":"s"}],"output":{"name":"shapehandle"}}],[11,"as_ref","","",50,{"inputs":[{"name":"shapehandle"}],"output":{"name":"repr"}}],[11,"deref","","",50,{"inputs":[{"name":"shapehandle"}],"output":{"name":"repr"}}],[11,"support_point","ncollide_entities::shape::cuboid","",34,null],[11,"support_point","ncollide_entities::shape::ball","",42,null],[11,"support_point","ncollide_entities::shape::capsule","",43,null],[11,"support_point","ncollide_entities::shape::cone","",44,null],[11,"support_point","ncollide_entities::shape::cylinder","",45,null],[11,"support_point","ncollide_entities::shape::convex","",49,null],[11,"support_point","ncollide_entities::shape::reflection","",46,null],[11,"support_point","ncollide_entities::shape::triangle","",38,null],[11,"support_point","ncollide_entities::shape::segment","",37,null],[11,"support_point","ncollide_entities::shape::minkowski_sum","",35,null],[11,"support_point","","",36,null],[11,"new","ncollide_entities::bounding_volume::bounding_volume_bvt","Creates a new `BoundingVolumeInterferencesCollector`.",51,{"inputs":[{"name":"bv"},{"name":"vec"}],"output":{"name":"boundingvolumeinterferencescollector"}}],[11,"visit_internal","","",51,{"inputs":[{"name":"boundingvolumeinterferencescollector"},{"name":"bv"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",51,null],[11,"bounding_volume","ncollide_entities::shape::cuboid","",34,{"inputs":[{"name":"cuboid"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::cone","",44,{"inputs":[{"name":"cone"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::cylinder","",45,{"inputs":[{"name":"cylinder"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::capsule","",43,{"inputs":[{"name":"capsule"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::triangle","",38,{"inputs":[{"name":"triangle"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::segment","",37,{"inputs":[{"name":"segment"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::ball","",42,{"inputs":[{"name":"ball"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::plane","",33,{"inputs":[{"name":"plane"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::convex","",49,{"inputs":[{"name":"convexhull"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::compound","",48,{"inputs":[{"name":"compound"},{"name":"m2"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::base_mesh","",39,{"inputs":[{"name":"basemesh"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::trimesh","",40,{"inputs":[{"name":"trimesh"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::polyline","",41,{"inputs":[{"name":"polyline"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide","",52,{"inputs":[{"name":"repr"},{"name":"m"}],"output":{"name":"aabb"}}],[11,"bounding_volume","ncollide_entities::shape::cuboid","",34,{"inputs":[{"name":"cuboid"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::cone","",44,{"inputs":[{"name":"cone"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::ball","",42,{"inputs":[{"name":"ball"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::cylinder","",45,{"inputs":[{"name":"cylinder"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::capsule","",43,{"inputs":[{"name":"capsule"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::plane","",33,{"inputs":[{"name":"plane"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::convex","",49,{"inputs":[{"name":"convexhull"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::compound","",48,{"inputs":[{"name":"compound"},{"name":"m2"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::triangle","",38,{"inputs":[{"name":"triangle"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::segment","",37,{"inputs":[{"name":"segment"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::base_mesh","",39,{"inputs":[{"name":"basemesh"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::trimesh","",40,{"inputs":[{"name":"trimesh"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide_entities::shape::polyline","",41,{"inputs":[{"name":"polyline"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"bounding_volume","ncollide","",52,{"inputs":[{"name":"repr"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[11,"decode","ncollide_entities::partitioning::dbvt","",53,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",53,{"inputs":[{"name":"updatestate"},{"name":"__s"}],"output":{"name":"result"}}],[11,"new","","Creates a new Dynamic Bounding Volume Tree.",54,{"inputs":[],"output":{"name":"dbvt"}}],[11,"remove","","Removes a leaf from the tree. Fails if the tree is empty.",54,null],[11,"insert_new","","Creates, inserts, and returns a new leaf with the given content.",54,{"inputs":[{"name":"dbvt"},{"name":"b"},{"name":"bv"}],"output":{"name":"rc"}}],[11,"insert","","Inserts a leaf to the tree.",54,null],[11,"visit","","Traverses this tree using an object implementing the `BVTVisitor`trait.",54,null],[11,"clone","","",55,{"inputs":[{"name":"dbvtleafstate"}],"output":{"name":"dbvtleafstate"}}],[11,"is_root","","Indicates whether this leaf is the root.",55,{"inputs":[{"name":"dbvtleafstate"}],"output":{"name":"bool"}}],[11,"is_detached","","Indicates whether this leaf is detached.",55,{"inputs":[{"name":"dbvtleafstate"}],"output":{"name":"bool"}}],[11,"clone","","",56,{"inputs":[{"name":"dbvtleaf"}],"output":{"name":"dbvtleaf"}}],[11,"new","","Creates a new leaf.",56,{"inputs":[{"name":"bv"},{"name":"b"}],"output":{"name":"dbvtleaf"}}],[11,"is_root","","Tests if this node is the root.",56,{"inputs":[{"name":"dbvtleaf"}],"output":{"name":"bool"}}],[11,"is_detached","","Tests if this node has no parent.",56,{"inputs":[{"name":"dbvtleaf"}],"output":{"name":"bool"}}],[11,"decode","ncollide_entities::partitioning::bvt","",57,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",57,{"inputs":[{"name":"bvt"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",57,{"inputs":[{"name":"bvt"}],"output":{"name":"bvt"}}],[11,"decode","","",58,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",58,{"inputs":[{"name":"bvtnode"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",58,{"inputs":[{"name":"bvtnode"}],"output":{"name":"bvtnode"}}],[11,"new_with_partitioner","","Builds a bounding volume tree using an user-defined construction function.",57,{"inputs":[{"name":"vec"},{"name":"f"}],"output":{"name":"bvt"}}],[11,"visit","","Traverses this tree using an object implementing the `BVTVisitor`trait.",57,null],[11,"visit_bvtt","","Visits the bounding volume traversal tree implicitely formed with `other`.",57,null],[11,"best_first_search","","Performs a best-fist-search on the tree.",57,{"inputs":[{"name":"bvt"},{"name":"bfs"}],"output":{"name":"option"}}],[11,"root_bounding_volume","","Reference to the bounding volume of the tree root.",57,{"inputs":[{"name":"bvt"}],"output":{"name":"option"}}],[11,"depth","","Computes the depth of this tree.",57,{"inputs":[{"name":"bvt"}],"output":{"name":"usize"}}],[11,"new_balanced","","Creates a balanced `BVT`.",57,{"inputs":[{"name":"vec"}],"output":{"name":"bvt"}}],[11,"bounding_volume","","The bounding volume of this node.",58,{"inputs":[{"name":"bvtnode"}],"output":{"name":"bv"}}],[11,"repr","ncollide_entities::shape::compound","",48,{"inputs":[{"name":"compound"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::trimesh","",40,{"inputs":[{"name":"trimesh"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::polyline","",41,{"inputs":[{"name":"polyline"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::ball","",42,{"inputs":[{"name":"ball"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::capsule","",43,{"inputs":[{"name":"capsule"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::cone","",44,{"inputs":[{"name":"cone"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::convex","",49,{"inputs":[{"name":"convexhull"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::cuboid","",34,{"inputs":[{"name":"cuboid"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::cylinder","",45,{"inputs":[{"name":"cylinder"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::segment","",37,{"inputs":[{"name":"segment"}],"output":{"name":"reprdesc"}}],[11,"repr","ncollide_entities::shape::triangle","",38,{"inputs":[{"name":"triangle"}],"output":{"name":"reprdesc"}}],[6,"Ball2","ncollide::shape","",null,null],[6,"Plane2","","",null,null],[6,"Cuboid2","","",null,null],[6,"Capsule2","","",null,null],[6,"Cone2","","",null,null],[6,"Cylinder2","","",null,null],[6,"ConvexHull2","","",null,null],[6,"Segment2","","",null,null],[6,"Triangle2","","",null,null],[6,"Polyline2","","",null,null],[6,"Compound2","","",null,null],[6,"ShapeHandle2","","",null,null],[6,"Ball3","","",null,null],[6,"Plane3","","",null,null],[6,"Cuboid3","","",null,null],[6,"Capsule3","","",null,null],[6,"Cone3","","",null,null],[6,"Cylinder3","","",null,null],[6,"ConvexHull3","","",null,null],[6,"Segment3","","",null,null],[6,"Triangle3","","",null,null],[6,"Polyline3","","",null,null],[6,"TriMesh3","","",null,null],[6,"Compound3","","",null,null],[6,"ShapeHandle3","","",null,null],[3,"Ball","","A Ball shape.",null,null],[3,"Plane","","SupportMap description of a plane.",null,null],[3,"Cuboid","","Shape of a box.",null,null],[3,"Capsule","","SupportMap description of a capsule shape with its principal axis aligned with the `y` axis.",null,null],[3,"Cone","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis.",null,null],[3,"Cylinder","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis.",null,null],[3,"ConvexHull","","The implicit convex hull of a set of points.",null,null],[3,"MinkowskiSum","","SupportMap representation of the Minkowski sum of two shapes.",null,null],[3,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped shapes.",null,null],[3,"Reflection","","SupportMap representation of the reflection of a shape.",null,null],[3,"Compound","","A compound shape with an aabb bounding volume.",null,null],[3,"BaseMesh","","A mesh generic wrt. the contained mesh elements characterized by vertices.",null,null],[8,"BaseMeshElement","","Trait implemented by elements usable on the Mesh.",null,null],[10,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices.",59,null],[3,"TriMesh","","Shape commonly known as a 2d line strip or a 3d triangle mesh.",null,null],[3,"Polyline","","Shape commonly known as a 2d line strip or a 3d segment mesh.",null,null],[3,"Segment","","A segment shape.",null,null],[3,"Triangle","","A triangle shape.",null,null],[3,"Torus","","A torus.",null,null],[8,"CompositeShape","","Trait implemented by shapes composed of multiple simpler shapes.",null,null],[10,"len","","The number of parts on this composite shapes.",60,{"inputs":[{"name":"compositeshape"}],"output":{"name":"usize"}}],[10,"map_part_at","","Applies a function to each sub-shape of this concave shape.",60,null],[10,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-shape of this concave\nshape.",60,null],[10,"aabb_at","","Gets the AABB of the shape identified by the index `i`.",60,{"inputs":[{"name":"compositeshape"},{"name":"usize"}],"output":{"name":"aabb"}}],[10,"bvt","","Gets the acceleration structure of the concave shape.",60,{"inputs":[{"name":"compositeshape"}],"output":{"name":"bvt"}}],[3,"ShapeHandle","","A shared immutable handle to an abstract shape.",null,null],[0,"inspection","ncollide","Traits and methods to inspect and retrieve the capabilities and representations of shapes at runtime.",null,null],[6,"Repr2","ncollide::inspection","",null,null],[6,"Repr3","","",null,null],[6,"ReprDesc2","","",null,null],[6,"ReprDesc3","","",null,null],[3,"ReprDesc","","",null,null],[8,"Repr","","An object with a unique runtime geometric representation.",null,null],[10,"repr","","Gets a reference to this object&#39;s main representation.",52,{"inputs":[{"name":"repr"}],"output":{"name":"reprdesc"}}],[5,"maybe_as_composite_shape","","Converts a shape to a composite shape if possible.",null,{"inputs":[{"name":"g"}],"output":{"name":"option"}}],[5,"maybe_repr_desc_as_composite_shape","","Converts a shape to a composite shape if possible.",null,{"inputs":[{"name":"reprdesc"}],"output":{"name":"option"}}],[5,"composite_shape_repr_id","","Gets the id associated with the `CompositeShape` trait.",null,{"inputs":[],"output":{"name":"typeid"}}],[5,"maybe_as_support_map","","Converts a shape to a support map if possible.",null,{"inputs":[{"name":"g"}],"output":{"name":"option"}}],[5,"maybe_repr_desc_as_support_map","","Converts a shape descriptor to a support map if possible.",null,{"inputs":[{"name":"reprdesc"}],"output":{"name":"option"}}],[5,"support_map_repr_id","","Gets the id associated with the `SupportMap` trait.",null,{"inputs":[],"output":{"name":"typeid"}}],[0,"bounding_volume","ncollide","Bounding volumes.",null,null],[6,"BoundingSphere2","ncollide::bounding_volume","",null,null],[6,"AABB2","","",null,null],[6,"BoundingSphere3","","",null,null],[6,"AABB3","","",null,null],[8,"HasBoundingVolume","","Traits of objects having a bounding volume.",null,null],[10,"bounding_volume","","The bounding volume of `self` transformed by `m`.",61,{"inputs":[{"name":"hasboundingvolume"},{"name":"m"}],"output":{"name":"bv"}}],[8,"BoundingVolume","","Trait of bounding volumes.",null,null],[10,"intersects","","Checks if this bounding volume intersect with another one.",62,{"inputs":[{"name":"boundingvolume"},{"name":"self"}],"output":{"name":"bool"}}],[10,"contains","","Checks if this bounding volume contains another one.",62,{"inputs":[{"name":"boundingvolume"},{"name":"self"}],"output":{"name":"bool"}}],[10,"merge","","Merges this bounding volume with another one. The merge is done in-place.",62,null],[10,"merged","","Merges this bounding volume with another one.",62,{"inputs":[{"name":"boundingvolume"},{"name":"self"}],"output":{"name":"self"}}],[10,"loosen","","Enlarges this bounding volume.",62,null],[10,"loosened","","Creates a new, enlarged version, of this bounding volume.",62,{"inputs":[{"name":"boundingvolume"},{"name":"n"}],"output":{"name":"self"}}],[10,"tighten","","Tighten this bounding volume.",62,null],[10,"tightened","","Creates a new, tightened version, of this bounding volume.",62,{"inputs":[{"name":"boundingvolume"},{"name":"n"}],"output":{"name":"self"}}],[3,"AABB","","An Axis Aligned Bounding Box.",null,null],[5,"aabb","","Computes the axis-aligned bounding box of a shape `g` transformed by `m`.",null,{"inputs":[{"name":"g"},{"name":"m"}],"output":{"name":"aabb"}}],[3,"BoundingSphere","","A Bounding Sphere.",null,null],[5,"bounding_sphere","","Computes the bounding sphere of a shape `g` transformed by `m`.",null,{"inputs":[{"name":"g"},{"name":"m"}],"output":{"name":"boundingsphere"}}],[5,"support_map_aabb","","Computes the AABB of an support mapped shape.",null,{"inputs":[{"name":"m"},{"name":"g"}],"output":{"name":"aabb"}}],[5,"point_cloud_aabb","","Computes the AABB of a set of point.",null,null],[5,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball.",null,null],[5,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center.",null,null],[5,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point.",null,null],[3,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume.",null,null],[0,"partitioning","ncollide","Spatial partitioning tools.",null,null],[3,"DBVT","ncollide::partitioning","A Dynamic Bounding Volume Tree.",null,null],[3,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree.",null,null],[12,"bounding_volume","","The bounding volume of this node.",56,null],[12,"center","","The center of this node bounding volume.",56,null],[12,"object","","An user-defined object.",56,null],[3,"BVT","","A Boundig Volume Tree.",null,null],[5,"median_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`.",null,null],[5,"median_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`.",null,null],[4,"BinaryPartition","","Result of a binary partition.",null,null],[13,"Part","","Result of the partitioning of one element.",63,null],[13,"Parts","","Result of the partitioning of several elements.",63,null],[4,"BVTNode","","A node of the bounding volume tree.",null,null],[13,"Internal","","An internal node.",58,null],[13,"Leaf","","A leaf.",58,null],[8,"BVTVisitor","","Visitor of Bounding Volume Trees.",null,null],[10,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",64,{"inputs":[{"name":"bvtvisitor"},{"name":"bv"}],"output":{"name":"bool"}}],[10,"visit_leaf","","Visits a leaf.",64,null],[3,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume.",null,null],[8,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree.",null,null],[10,"visit_internal_internal","","Visit two internal nodes.",65,{"inputs":[{"name":"bvttvisitor"},{"name":"bv"},{"name":"bv"}],"output":{"name":"bool"}}],[10,"visit_leaf_leaf","","Visit two leaves.",65,null],[10,"visit_internal_leaf","","Visit one internal node and one leaf.",65,{"inputs":[{"name":"bvttvisitor"},{"name":"bv"},{"name":"b"},{"name":"bv"}],"output":{"name":"bool"}}],[10,"visit_leaf_internal","","Visit one leaf and on internal node.",65,{"inputs":[{"name":"bvttvisitor"},{"name":"b"},{"name":"bv"},{"name":"bv"}],"output":{"name":"bool"}}],[8,"BVTCostFn","","Trait implemented by cost functions used by the best-first search on a `BVT`.",null,null],[16,"UserData","","User-defined data attached to each BVT leaf.",66,null],[10,"compute_bv_cost","","Computes the cost of a bounding volume.",66,{"inputs":[{"name":"bvtcostfn"},{"name":"bv"}],"output":{"name":"option"}}],[10,"compute_b_cost","","Computes the cost of an object, and the result to be returned if it is the best one.",66,{"inputs":[{"name":"bvtcostfn"},{"name":"b"}],"output":{"name":"option"}}],[0,"support_map","ncollide","Definition of support functions.",null,null],[8,"SupportMap","ncollide::support_map","Traits of convex shapes representable by a support mapping function.",null,null],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the shape point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\nshape-dependent. Use `support_point` to sample the complete shape.",67,null],[5,"cso_support_point","","Computes the support point of the CSO `g1 - g2` on a given direction.",null,null],[5,"point_cloud_support_point","","Computes the support point of a cloud of points.",null,null],[0,"geometry","ncollide","Non-persistant pairwise geometric queries.",null,null],[0,"algorithms","ncollide::geometry","Algorithms needed for distance and penetration depth computation.",null,null],[0,"simplex","ncollide::geometry::algorithms","Abstract definition of a simplex usable by the GJK algorithm.",null,null],[8,"Simplex","ncollide::geometry::algorithms::simplex","Trait of a simplex usable by the GJK algorithm.",null,null],[10,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",68,null],[10,"add_point","","Adds a point to the simplex.",68,null],[10,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",68,{"inputs":[{"name":"simplex"}],"output":{"name":"p"}}],[10,"project_origin","","Projection the origin on the simplex. The simplex itself is unchanged, although it is\nmutable for optimization purpose.",68,{"inputs":[{"name":"simplex"}],"output":{"name":"p"}}],[10,"contains_point","","Checks whether a given point is already part of the simplex points.",68,{"inputs":[{"name":"simplex"},{"name":"p"}],"output":{"name":"bool"}}],[10,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",68,{"inputs":[{"name":"simplex"}],"output":{"name":"usize"}}],[10,"max_sq_len","","The maximum among the simplex point squared lengths.",68,null],[10,"modify_pnts","","Modifies the points contained by this simplex.",68,null],[0,"johnson_simplex","ncollide::geometry::algorithms","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex.",null,null],[11,"new","ncollide_queries::geometry::algorithms::johnson_simplex","Creates a new, empty, Johnson simplex.",69,{"inputs":[{"name":"arc"}],"output":{"name":"johnsonsimplex"}}],[11,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",69,{"inputs":[],"output":{"name":"johnsonsimplex"}}],[11,"clone","","",69,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"johnsonsimplex"}}],[11,"decode","","",70,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",70,{"inputs":[{"name":"recursiontemplate"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",70,{"inputs":[{"name":"recursiontemplate"}],"output":{"name":"recursiontemplate"}}],[11,"eq","","",70,{"inputs":[{"name":"recursiontemplate"},{"name":"recursiontemplate"}],"output":{"name":"bool"}}],[11,"ne","","",70,{"inputs":[{"name":"recursiontemplate"},{"name":"recursiontemplate"}],"output":{"name":"bool"}}],[11,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dimension`.",70,{"inputs":[{"name":"usize"}],"output":{"name":"arc"}}],[11,"reset","","",69,null],[11,"dimension","","",69,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"usize"}}],[11,"max_sq_len","","",69,null],[11,"contains_point","","",69,{"inputs":[{"name":"johnsonsimplex"},{"name":"p"}],"output":{"name":"bool"}}],[11,"add_point","","",69,null],[11,"project_origin_and_reduce","","",69,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"p"}}],[11,"project_origin","","",69,{"inputs":[{"name":"johnsonsimplex"}],"output":{"name":"p"}}],[11,"modify_pnts","","",69,null],[11,"clone","ncollide_queries::geometry::algorithms::gjk","",71,{"inputs":[{"name":"gjkresult"}],"output":{"name":"gjkresult"}}],[11,"decode","","",71,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",71,{"inputs":[{"name":"gjkresult"},{"name":"__s"}],"output":{"name":"result"}}],[11,"decode","ncollide_queries::geometry::contacts_internal::contact","",72,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",72,{"inputs":[{"name":"contact"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",72,{"inputs":[{"name":"contact"}],"output":{"name":"contact"}}],[11,"eq","","",72,{"inputs":[{"name":"contact"},{"name":"contact"}],"output":{"name":"bool"}}],[11,"ne","","",72,{"inputs":[{"name":"contact"},{"name":"contact"}],"output":{"name":"bool"}}],[11,"fmt","","",72,{"inputs":[{"name":"contact"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new contact.",72,null],[11,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",72,null],[11,"new","ncollide_queries::geometry::distance_internal::composite_shape_against_any","",73,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"}],"output":{"name":"compositeshapeagainstanydistcostfn"}}],[11,"compute_bv_cost","","",73,{"inputs":[{"name":"compositeshapeagainstanydistcostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",73,{"inputs":[{"name":"compositeshapeagainstanydistcostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"decode","ncollide_queries::geometry::proximity_internal::proximity","",74,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",74,{"inputs":[{"name":"proximity"},{"name":"__s"}],"output":{"name":"result"}}],[11,"clone","","",74,{"inputs":[{"name":"proximity"}],"output":{"name":"proximity"}}],[11,"eq","","",74,{"inputs":[{"name":"proximity"},{"name":"proximity"}],"output":{"name":"bool"}}],[11,"ne","","",74,{"inputs":[{"name":"proximity"},{"name":"proximity"}],"output":{"name":"bool"}}],[11,"fmt","","",74,{"inputs":[{"name":"proximity"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","ncollide_queries::geometry::proximity_internal::composite_shape_against_any","",75,null],[11,"compute_bv_cost","","",75,{"inputs":[{"name":"compositeshapeagainstanyinterfcostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",75,{"inputs":[{"name":"compositeshapeagainstanyinterfcostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"new","ncollide_queries::geometry::time_of_impact_internal::composite_shape_against_any","",76,null],[11,"compute_bv_cost","","",76,{"inputs":[{"name":"compositeshapeagainstanytoicostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",76,{"inputs":[{"name":"compositeshapeagainstanytoicostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"project_point","ncollide::shape","",33,{"inputs":[{"name":"plane"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",33,null],[11,"contains_point","","",33,{"inputs":[{"name":"plane"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","","",42,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",42,null],[11,"contains_point","","",42,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","","",34,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",34,null],[11,"contains_point","","",34,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide::bounding_volume","",77,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",77,null],[11,"contains_point","","",77,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","","",78,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",78,null],[11,"contains_point","","",78,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide::shape","",45,{"inputs":[{"name":"cylinder"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","","",44,{"inputs":[{"name":"cone"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","","",43,{"inputs":[{"name":"capsule"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","","",49,{"inputs":[{"name":"convexhull"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","","",37,{"inputs":[{"name":"segment"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","","",38,{"inputs":[{"name":"triangle"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"project_point","","",48,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"contains_point","","",48,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"compute_bv_cost","ncollide_queries::point::point_compound","",79,{"inputs":[{"name":"compoundpointprojcostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",79,{"inputs":[{"name":"compoundpointprojcostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"visit_internal","","",80,{"inputs":[{"name":"pointcontainementtest"},{"name":"aabb"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",80,null],[11,"project_point","ncollide::shape","",39,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"contains_point","","",39,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"compute_bv_cost","ncollide_queries::point::point_mesh","",81,{"inputs":[{"name":"basemeshpointprojcostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",81,{"inputs":[{"name":"basemeshpointprojcostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"visit_internal","","",82,{"inputs":[{"name":"pointcontainementtest"},{"name":"aabb"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",82,null],[11,"project_point","ncollide::shape","",40,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",40,null],[11,"contains_point","","",40,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","","",41,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",41,null],[11,"contains_point","","",41,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"project_point","ncollide::geometry::algorithms","",52,{"inputs":[{"name":"repr"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","",52,null],[11,"contains_point","","",52,{"inputs":[{"name":"repr"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[11,"new","ncollide_queries::point::point_bvt","Creates a new `PointInterferencesCollector`.",83,{"inputs":[{"name":"p"},{"name":"vec"}],"output":{"name":"pointinterferencescollector"}}],[11,"visit_internal","","",83,{"inputs":[{"name":"pointinterferencescollector"},{"name":"bv"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",83,null],[11,"toi_and_normal_with_ray","ncollide::shape","",33,{"inputs":[{"name":"plane"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","","",42,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",42,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",42,{"inputs":[{"name":"ball"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","","",34,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",34,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",34,{"inputs":[{"name":"cuboid"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide::bounding_volume","",77,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",77,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",77,{"inputs":[{"name":"aabb"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","","",78,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",78,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",78,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","",78,{"inputs":[{"name":"boundingsphere"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[11,"toi_and_normal_with_ray","ncollide::shape","",45,{"inputs":[{"name":"cylinder"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",44,{"inputs":[{"name":"cone"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",43,{"inputs":[{"name":"capsule"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",49,{"inputs":[{"name":"convexhull"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",37,{"inputs":[{"name":"segment"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",35,{"inputs":[{"name":"minkowskisum"},{"name":"m2"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",38,{"inputs":[{"name":"triangle"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","","",48,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",48,{"inputs":[{"name":"compound"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"compute_bv_cost","ncollide_queries::ray::ray_compound","",84,{"inputs":[{"name":"compoundraytoicostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",84,{"inputs":[{"name":"compoundraytoicostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"compute_bv_cost","","",85,{"inputs":[{"name":"compoundraytoiandnormalcostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",85,{"inputs":[{"name":"compoundraytoiandnormalcostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide::shape","",39,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",39,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",39,{"inputs":[{"name":"basemesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"compute_bv_cost","ncollide_queries::ray::ray_mesh","",86,{"inputs":[{"name":"basemeshraytoicostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",86,{"inputs":[{"name":"basemeshraytoicostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"compute_bv_cost","","",87,{"inputs":[{"name":"basemeshraytoiandnormalcostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",87,{"inputs":[{"name":"basemeshraytoiandnormalcostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"compute_bv_cost","","",88,{"inputs":[{"name":"basemeshraytoiandnormalanduvscostfn"},{"name":"aabb"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",88,{"inputs":[{"name":"basemeshraytoiandnormalanduvscostfn"},{"name":"usize"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide::shape","",40,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",40,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",40,{"inputs":[{"name":"trimesh"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","","",41,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",41,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",41,{"inputs":[{"name":"polyline"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_with_ray","ncollide::geometry::algorithms","",52,{"inputs":[{"name":"repr"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_with_ray","","",52,{"inputs":[{"name":"repr"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","",52,{"inputs":[{"name":"repr"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","",52,{"inputs":[{"name":"repr"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[11,"new","ncollide_queries::ray::ray_bvt","Creates a new `BestRayInterferenceSearch`.",89,{"inputs":[{"name":"ray"},{"name":"bool"},{"name":"bool"}],"output":{"name":"rayintersectioncostfn"}}],[11,"compute_bv_cost","","",89,{"inputs":[{"name":"rayintersectioncostfn"},{"name":"bv"}],"output":{"name":"option"}}],[11,"compute_b_cost","","",89,{"inputs":[{"name":"rayintersectioncostfn"},{"name":"b"}],"output":{"name":"option"}}],[11,"new","","Creates a new `RayInterferencesCollector`.",90,{"inputs":[{"name":"ray"},{"name":"vec"}],"output":{"name":"rayinterferencescollector"}}],[11,"visit_internal","","",90,{"inputs":[{"name":"rayinterferencescollector"},{"name":"bv"}],"output":{"name":"bool"}}],[11,"visit_leaf","","",90,null],[3,"JohnsonSimplex","ncollide::geometry::algorithms::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex.",null,null],[3,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex.",null,null],[0,"gjk","ncollide::geometry::algorithms","The Gilbert–Johnson–Keerthi distance algorithm.",null,null],[4,"GJKResult","ncollide::geometry::algorithms::gjk","Results of the GJK algorithm.",null,null],[13,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",71,null],[13,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",71,null],[13,"Proximity","","Result of the GJK algorithm when the origin is to close to the polytope but not inside of it.",71,null],[13,"NoIntersection","","Result of the GJK algorithm when the origin is too far away from the polytope.",71,null],[5,"closest_points","","Computes the closest points between two convex shapes unsing the GJK\nalgorithm.",null,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"},{"name":"s"}],"output":{"name":"option"}}],[5,"closest_points_with_max_dist","","Computes the closest points between two convex shapes unsing the GJK algorithm.",null,null],[5,"distance","","Computes the exact distance separating two convex shapes unsing the GJK.\nalgorithm.",null,null],[5,"proximity","","Computes the closest points between two convex shapes unsing the GJK algorithm.",null,null],[5,"project_origin","","Projects the origin on a shape unsing the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"}],"output":{"name":"option"}}],[5,"project_origin_with_max_dist","","Projects the origin on a shape using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin.",null,null],[5,"cast_ray","","Casts a ray on a support map using the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"},{"name":"ray"}],"output":{"name":"option"}}],[0,"minkowski_sampling","ncollide::geometry::algorithms","Penetration depth computation algorithm approximating the Minkowskis sum.",null,null],[5,"closest_points","ncollide::geometry::algorithms::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g1"},{"name":"m"},{"name":"g2"},{"name":"s"}],"output":{"name":"option"}}],[5,"project_origin","","Projects the origin on a support-mapped shape.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"}],"output":{"name":"option"}}],[0,"contacts_internal","ncollide::geometry","Implementation details of the `contact` and `contacts` functions.",null,null],[3,"Contact","ncollide::geometry::contacts_internal","Geometric description of a contact.",null,null],[12,"world1","","Position of the contact on the first object. The position is expressed in world space.",72,null],[12,"world2","","Position of the contact on the second object. The position is expressed in world space.",72,null],[12,"normal","","Contact normal",72,null],[12,"depth","","Penetration depth",72,null],[5,"ball_against_ball","","Contact between balls.",null,null],[5,"support_map_against_support_map","","Contact between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[5,"support_map_against_support_map_with_params","","Contact between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[5,"plane_against_support_map","","Contact between a plane and a support-mapped shape (Cuboid, ConvexHull, etc.)",null,null],[5,"support_map_against_plane","","Contact between a support-mapped shape (Cuboid, ConvexHull, etc.) and a plane.",null,null],[5,"any_against_any","","Computes one contact point between two shapes.",null,null],[5,"composite_shape_against_any","","Best contact between a composite shape (`Mesh`, `Compound`) and any other shape.",null,null],[5,"any_against_composite_shape","","Best contact between a shape and a composite (`Mesh`, `Compound`) shape.",null,null],[0,"distance_internal","ncollide::geometry","Implementation details of the `distance` function.",null,null],[5,"ball_against_ball","ncollide::geometry::distance_internal","Distance between balls.",null,null],[5,"support_map_against_support_map","","Distance between support-mapped shapes.",null,null],[5,"support_map_against_support_map_with_params","","Distance between support-mapped shapes.",null,null],[5,"plane_against_support_map","","Distance between a plane and a support-mapped shape.",null,null],[5,"support_map_against_plane","","Distance between a support-mapped shape and a plane.",null,null],[5,"any_against_any","","Computes the minimum distance separating two shapes.",null,null],[5,"composite_shape_against_any","","Smallest distance between a composite shape and any other shape.",null,null],[5,"any_against_composite_shape","","Smallest distance between a shape and a composite shape.",null,null],[0,"proximity_internal","ncollide::geometry","Implementation details of the `proximity` function.",null,null],[4,"Proximity","ncollide::geometry::proximity_internal","Proximity information.",null,null],[13,"Intersecting","","The two objects are intersecting.",74,null],[13,"WithinMargin","","The two objects are non-intersecting but closer than a given distance.",74,null],[13,"Disjoint","","The two objects are non-intersecting and further than a given distance.",74,null],[5,"ball_against_ball","","Proximity between balls.",null,null],[5,"support_map_against_support_map","","Proximity between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[5,"support_map_against_support_map_with_params","","Proximity between support-mapped shapes (`Cuboid`, `ConvexHull`, etc.)",null,null],[5,"plane_against_support_map","","Proximity between a plane and a support-mapped shape (Cuboid, ConvexHull, etc.)",null,null],[5,"support_map_against_plane","","Proximity between a support-mapped shape (Cuboid, ConvexHull, etc.) and a plane.",null,null],[5,"any_against_any","","Tests whether two shapes are in intersecting or separated by a distance smaller than `margin`.",null,null],[5,"composite_shape_against_any","","Proximity between a composite shape (`Mesh`, `Compound`) and any other shape.",null,null],[5,"any_against_composite_shape","","Proximity between a shape and a composite (`Mesh`, `Compound`) shape.",null,null],[0,"time_of_impact_internal","ncollide::geometry","Implementation details of the `time_of_impact` function.",null,null],[5,"ball_against_ball","ncollide::geometry::time_of_impact_internal","Time Of Impact of two balls under translational movement.",null,null],[5,"support_map_against_support_map","","Time of impacts between two support-mapped shapes under translational movement.",null,null],[5,"plane_against_support_map","","Time Of Impact of a plane with a support-mapped shape under translational movement.",null,null],[5,"support_map_against_plane","","Time Of Impact of a plane with a support-mapped shape under translational movement.",null,null],[5,"any_against_any","","Computes the smallest time of impact of two shapes under translational movement.",null,null],[5,"composite_shape_against_any","","Time Of Impact of a composite shape with any other shape, under translational movement.",null,null],[5,"any_against_composite_shape","","Time Of Impact of any shape with a composite shape, under translational movement.",null,null],[3,"Contact","ncollide::geometry","Geometric description of a contact.",null,null],[12,"world1","","Position of the contact on the first object. The position is expressed in world space.",72,null],[12,"world2","","Position of the contact on the second object. The position is expressed in world space.",72,null],[12,"normal","","Contact normal",72,null],[12,"depth","","Penetration depth",72,null],[5,"any_against_any","","Computes one contact point between two shapes.",null,null],[4,"Proximity","","Proximity information.",null,null],[13,"Intersecting","","The two objects are intersecting.",74,null],[13,"WithinMargin","","The two objects are non-intersecting but closer than a given distance.",74,null],[13,"Disjoint","","The two objects are non-intersecting and further than a given distance.",74,null],[5,"any_against_any","","Tests whether two shapes are in intersecting or separated by a distance smaller than `margin`.",null,null],[5,"any_against_any","","Computes the minimum distance separating two shapes.",null,null],[5,"any_against_any","","Computes the smallest time of impact of two shapes under translational movement.",null,null],[0,"point","ncollide","Point inclusion and projection.",null,null],[8,"PointQuery","ncollide::point","Trait of objects that can be tested for point inclusion and projection.",null,null],[10,"project_point","","Projects a point on `self` transformed by `m`.",91,{"inputs":[{"name":"pointquery"},{"name":"m"},{"name":"p"},{"name":"bool"}],"output":{"name":"pointprojection"}}],[11,"distance_to_point","","Computes the minimal distance between a point and `self` transformed by `m`.",91,null],[11,"contains_point","","Tests if the given point is inside of `self` transformed by `m`.",91,{"inputs":[{"name":"pointquery"},{"name":"m"},{"name":"p"}],"output":{"name":"bool"}}],[3,"PointProjection","","Description of the projection of a point on a shape.",null,null],[12,"is_inside","","Whether or not the point to project was inside of the shape.",92,null],[12,"point","","The projection result.",92,null],[3,"PointInterferencesCollector","","Bounding Volume Tree visitor collecting nodes that may contain a given point.",null,null],[0,"ray","ncollide","Ray-casting related definitions and implementations.",null,null],[6,"Ray3","ncollide::ray","",null,null],[6,"Ray2","","",null,null],[6,"RayIntersection3","","",null,null],[6,"RayIntersection2","","",null,null],[3,"Ray","","A Ray.",null,null],[12,"origin","","Starting point of the ray.",93,null],[12,"dir","","Direction of the ray.",93,null],[8,"RayCast","","Traits of objects which can be transformed and tested for intersection with a ray.",null,null],[11,"toi_with_ray","","Computes the time of impact between this transform shape and a ray.",94,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[10,"toi_and_normal_with_ray","","Computes the time of impact, and normal between this transformed shape and a ray.",94,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"toi_and_normal_and_uv_with_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\nshape and a ray.",94,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[11,"intersects_ray","","Tests whether a ray intersects this transformed shape.",94,{"inputs":[{"name":"raycast"},{"name":"m"},{"name":"ray"}],"output":{"name":"bool"}}],[3,"RayIntersection","","Structure containing the result of a successful ray cast.",null,null],[12,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `origin + dir * toi` where `origin` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",95,null],[12,"normal","","The normal at the intersection point.",95,null],[12,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",95,null],[5,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal.",null,null],[5,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray.",null,{"inputs":[{"name":"p"},{"name":"p"},{"name":"p"},{"name":"ray"}],"output":{"name":"option"}}],[5,"implicit_toi_and_normal_with_ray","","Cast a ray on a shape using the GJK algorithm.",null,{"inputs":[{"name":"m"},{"name":"g"},{"name":"s"},{"name":"ray"},{"name":"bool"}],"output":{"name":"option"}}],[5,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball.",null,null],[3,"RayIntersectionCostFn","","A search thet selects the objects that has the smallest time of impact with a given ray.",null,null],[3,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray.",null,null],[0,"narrow_phase","ncollide","Persistant collision detection algorithms to compute contact points.",null,null],[8,"NarrowPhase","ncollide::narrow_phase","Trait implemented by the narrow phase manager.",null,null],[10,"update","","Updates this narrow phase.",96,null],[10,"handle_proximity","","Called when the broad phase detects that two objects are, or stop to be, in close proximity.",96,null],[10,"contact_pairs","","Returns all the potential contact pairs found during the broad phase, and validated by the\nnarrow phase.",96,{"inputs":[{"name":"narrowphase"},{"name":"uidremap"}],"output":{"name":"contactpairs"}}],[3,"ContactPairs","","Iterator through contact pairs.",null,null],[3,"Contacts","","An iterator through contacts.",null,null],[3,"DefaultNarrowPhase","","Collision detector dispatcher for collision objects.",null,null],[3,"ContactSignal","","Signal for contact start/stop.",null,null],[8,"ContactSignalHandler","","A signal handler for contact detection.",null,null],[10,"handle_contact","","Activate an action for when two objects start or stop to be close to each other.",97,null],[3,"ProximitySignal","","Signal for proximity start/stop.",null,null],[8,"ProximitySignalHandler","","A signal handler for proximity detection.",null,null],[10,"handle_proximity","","Activate an action for when two objects start or stop to be close to each other.",98,null],[8,"CollisionDetector","","Trait implemented algorithms that compute contact points, normals and penetration depths.",null,null],[10,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",99,null],[10,"num_colls","","The number of collision detected during the last update.",99,{"inputs":[{"name":"collisiondetector"}],"output":{"name":"usize"}}],[10,"colls","","Collects the collisions detected during the last update.",99,null],[8,"CollisionDispatcher","","",null,null],[10,"get_collision_algorithm","","Allocate a collision algorithm corresponding to the given pair of shapes.",100,{"inputs":[{"name":"collisiondispatcher"},{"name":"reprdesc"},{"name":"reprdesc"}],"output":{"name":"option"}}],[6,"CollisionAlgorithm","","",null,null],[3,"DefaultCollisionDispatcher","","Collision dispatcher for shapes defined by `ncollide_entities`.",null,null],[3,"BallBallCollisionDetector","","Collision detector between two balls.",null,null],[3,"PlaneSupportMapCollisionDetector","","Collision detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"SupportMapPlaneCollisionDetector","","Collision detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"SupportMapSupportMapCollisionDetector","","Persistent collision detector between two shapes having a support mapping function.",null,null],[3,"CompositeShapeReprCollisionDetector","","Collision detector between a concave shape and another shape.",null,null],[3,"ReprCompositeShapeCollisionDetector","","Collision detector between a shape and a concave shape.",null,null],[3,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts.",null,null],[3,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update.",null,null],[8,"ProximityDetector","","Trait implemented by algorithms that determine if two objects are in close proximity.",null,null],[10,"update","","Runs the proximity detection on two objects. It is assumed that the same proximity detector\n(the same structure) is always used with the same pair of object.",101,null],[10,"proximity","","The number of collision detected during the last update.",101,{"inputs":[{"name":"proximitydetector"}],"output":{"name":"proximity"}}],[8,"ProximityDispatcher","","",null,null],[10,"get_proximity_algorithm","","Allocate a collision algorithm corresponding to the given pair of shapes.",102,{"inputs":[{"name":"proximitydispatcher"},{"name":"reprdesc"},{"name":"reprdesc"}],"output":{"name":"option"}}],[6,"ProximityAlgorithm","","",null,null],[3,"DefaultProximityDispatcher","","Proximity dispatcher for shapes defined by `ncollide_entities`.",null,null],[3,"BallBallProximityDetector","","Proximity detector between two balls.",null,null],[3,"PlaneSupportMapProximityDetector","","Proximity detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"SupportMapPlaneProximityDetector","","Proximity detector between a plane and a shape implementing the `SupportMap` trait.",null,null],[3,"SupportMapSupportMapProximityDetector","","Persistent proximity detector between two shapes having a support mapping function.",null,null],[3,"CompositeShapeReprProximityDetector","","Proximity detector between a concave shape and another shape.",null,null],[3,"ReprCompositeShapeProximityDetector","","Proximity detector between a shape and a concave shape.",null,null],[0,"broad_phase","ncollide","Broad phases.",null,null],[8,"BroadPhase","ncollide::broad_phase","Trait all broad phase must implement.",null,null],[10,"deferred_add","","Tells the broad phase to add an element during the next update.",103,null],[10,"deferred_remove","","Tells the broad phase to remove an element during the next update.",103,null],[10,"deferred_set_bounding_volume","","Sets the next bounding volume to be used during the update of this broad phase.",103,null],[10,"defered_recompute_all_proximities","","Forces the broad-phase to recompute and re-report all the proximities.",103,null],[10,"update","","Updates the object additions, removals, and interferences detection.",103,null],[10,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",103,null],[10,"interferences_with_ray","","Collects every object which might intersect a given ray.",103,null],[10,"interferences_with_point","","Collects every object which might contain a given point.",103,null],[3,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree.",null,null],[8,"BroadPhasePairFilter","","A signal handler for contact detection.",null,null],[10,"is_pair_valid","","Activate an action for when two objects start or stop to be close to each other.",104,{"inputs":[{"name":"broadphasepairfilter"},{"name":"b"},{"name":"b"}],"output":{"name":"bool"}}],[3,"BroadPhasePairFilters","","Filters deciding whether a proximity is to be further investigated by the narrow phase or not.",null,null],[0,"world","ncollide","High level API to detect collisions in large, complex scenes.",null,null],[6,"CollisionWorld3","ncollide::world","",null,null],[6,"CollisionWorld2","","",null,null],[4,"CollisionQueryType","","The kind of query a CollisionObject may be involved on.",null,null],[13,"Contacts","","This objects can respond to both contact point computation and proximity queries.",105,null],[13,"Proximity","","This object can respond to proximity tests only.",105,null],[3,"CollisionObject","","A stand-alone object that has a position and a shape.",null,null],[12,"position","","The collision object position.",106,null],[12,"shape","","The collision object shape.",106,null],[12,"collision_groups","","The collision groups of the collision object.",106,null],[12,"query_type","","The kind of queries this collision object is expected to .",106,null],[12,"data","","The user-defined data associated to this object.",106,null],[3,"CollisionGroups","","Groups of collision used to filter which object collide with which other one.",null,null],[3,"CollisionGroupsPairFilter","","A collision filter based collision groups.",null,null],[6,"BroadPhaseObject","","",null,null],[3,"CollisionWorld","","A world that handles collision objects.",null,null],[0,"utils","ncollide::procedural","Utilities useful for various generations tasks.",null,null],[5,"push_circle","ncollide::procedural::utils","Pushes a discretized counterclockwise circle to a buffer.",null,null],[5,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis.",null,null],[5,"push_ring_indices","","Creates the faces from two circles with the same discretization.",null,null],[5,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.",null,null],[5,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle.",null,null],[5,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle.",null,null],[5,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`.",null,null],[5,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`.",null,null],[5,"reverse_clockwising","","Reverses the clockwising of a set of faces.",null,null],[5,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer.",null,null],[5,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex.",null,null],[5,"compute_normals","","Computes the normals of a set of vertices.",null,null],[0,"path","ncollide::procedural","Path generation.",null,null],[11,"new","ncollide_procedural::path::no_cap","Creates a new `NoCap`.",107,{"inputs":[],"output":{"name":"nocap"}}],[11,"gen_start_cap","","",107,null],[11,"gen_end_cap","","",107,null],[11,"new","ncollide_procedural::path::arrowhead_cap","Creates a cap that looks like an arrow.",108,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"arrowheadcap"}}],[11,"gen_end_cap","","",108,null],[11,"gen_start_cap","","",108,null],[11,"new","ncollide_procedural::path::polyline_pattern","Creates a new polyline pattern.",109,{"inputs":[{"name":"polyline"},{"name":"bool"},{"name":"c1"},{"name":"c2"}],"output":{"name":"polylinepattern"}}],[11,"stroke","","",109,{"inputs":[{"name":"polylinepattern"},{"name":"c"}],"output":{"name":"trimesh"}}],[11,"new","ncollide_procedural::path::polyline_path","Creates a new polyline-based path.",110,{"inputs":[{"name":"polyline"}],"output":{"name":"polylinepath"}}],[11,"next","","",110,{"inputs":[{"name":"polylinepath"}],"output":{"name":"pathsample"}}],[11,"fmt","ncollide_procedural::trimesh","",111,{"inputs":[{"name":"indexbuffer"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",111,{"inputs":[{"name":"indexbuffer"}],"output":{"name":"indexbuffer"}}],[11,"unwrap_unified","","Returns the unified index buffer data or fails.",111,{"inputs":[{"name":"indexbuffer"}],"output":{"name":"vec"}}],[11,"unwrap_split","","Returns the split index buffer data or fails.",111,{"inputs":[{"name":"indexbuffer"}],"output":{"name":"vec"}}],[11,"fmt","","",112,{"inputs":[{"name":"trimesh"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",112,{"inputs":[{"name":"trimesh"}],"output":{"name":"trimesh"}}],[11,"new","","Creates a new `TriMesh`.",112,{"inputs":[{"name":"vec"},{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"trimesh"}}],[11,"has_normals","","Whether or not this triangle mesh has normals.",112,{"inputs":[{"name":"trimesh"}],"output":{"name":"bool"}}],[11,"has_uvs","","Whether or not this triangle mesh has texture coordinates.",112,{"inputs":[{"name":"trimesh"}],"output":{"name":"bool"}}],[11,"translate_by","","Translates each vertex of this mesh.",112,null],[11,"transform_by","","Transforms each vertex and rotates each normal of this mesh.",112,null],[11,"num_triangles","","The number of triangles on this mesh.",112,{"inputs":[{"name":"trimesh"}],"output":{"name":"usize"}}],[11,"rotate_by","","Rotates each vertex and normal of this mesh.",112,null],[11,"recompute_normals","","Recomputes the mesh normals using its vertex coordinates and adjascency informations\ninfered from the index buffer.",112,null],[11,"scale_by","","Scales each vertex of this mesh.",112,null],[11,"scale_by_scalar","","Scales each vertex of this mesh.",112,null],[11,"unify_index_buffer","","Force the mesh to use the same index for vertices, normals and uvs.",112,null],[11,"split_index_buffer","","Forces the mesh to use a different index for the vertices, normals and uvs.",112,null],[11,"clone","ncollide_procedural::polyline","",113,{"inputs":[{"name":"polyline"}],"output":{"name":"polyline"}}],[11,"new","","Creates a new polyline.",113,{"inputs":[{"name":"vec"},{"name":"option"}],"output":{"name":"polyline"}}],[11,"unwrap","","Moves the polyline data out of it.",113,null],[11,"coords","","The coordinates of this polyline vertices.",113,null],[11,"coords_mut","","The mutable coordinates of this polyline vertices.",113,null],[11,"normals","","The normals of this polyline vertices.",113,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"normals_mut","","The mutable normals of this polyline vertices.",113,{"inputs":[{"name":"polyline"}],"output":{"name":"option"}}],[11,"translate_by","","Translates each vertex of this polyline.",113,null],[11,"rotate_by","","Rotates each vertex and normal of this polyline.",113,null],[11,"transform_by","","Transforms each vertex and rotates each normal of this polyline.",113,null],[11,"scale_by_scalar","","Scales each vertex of this polyline.",113,null],[11,"scale_by","","Scales each vertex of this mesh.",113,null],[4,"PathSample","ncollide::procedural::path","A sample point and its associated tangent.",null,null],[13,"StartPoint","","A point that starts a new path.",114,null],[13,"InnerPoint","","A point that is inside of the path currently generated.",114,null],[13,"EndPoint","","A point that ends the path currently generated.",114,null],[13,"EndOfSample","","Used when the sampler does not have any other points to generate.",114,null],[8,"CurveSampler","","A curve sampler.",null,null],[10,"next","","Returns the next sample point.",115,{"inputs":[{"name":"curvesampler"}],"output":{"name":"pathsample"}}],[8,"StrokePattern","","A pattern that is replicated along a path.",null,null],[10,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",116,{"inputs":[{"name":"strokepattern"},{"name":"c"}],"output":{"name":"trimesh"}}],[3,"PolylinePattern","","A pattern composed of polyline and two caps.",null,null],[8,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`.",null,null],[10,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",117,null],[10,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",117,null],[3,"PolylinePath","","A path with its sample points given by a polyline.",null,null],[3,"ArrowheadCap","","A cap that looks like an arrow.",null,null],[3,"NoCap","","A cap that renders nothing.",null,null],[6,"TriMesh3","ncollide::procedural","",null,null],[6,"Polyline3","","",null,null],[6,"TriMesh2","","",null,null],[6,"Polyline2","","",null,null],[3,"TriMesh","","Shapeetric description of a mesh.",null,null],[12,"coords","","Coordinates of the mesh vertices.",112,null],[12,"normals","","Coordinates of the mesh normals.",112,null],[12,"uvs","","Textures coordinates of the mesh.",112,null],[12,"indices","","Index buffer of the mesh.",112,null],[4,"IndexBuffer","","Different representations of the index buffer.",null,null],[13,"Unified","","The vertex, normal, and uvs share the same indices.",111,null],[13,"Split","","The vertex, normal, and uvs have different indices.",111,null],[3,"Polyline","","Shapeetric description of a polyline.",null,null],[5,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface.",null,null],[5,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve.",null,null],[5,"capsule","","Generates a capsule.",null,{"inputs":[{"name":"n"},{"name":"n"},{"name":"u32"},{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"unit_cone","","Generates a cone with unit height and diameter.",null,{"inputs":[{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"cone","","Generates a cone with a given height and diameter.",null,{"inputs":[{"name":"n"},{"name":"n"},{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"cuboid","","Generates a cuboid shape with a split index buffer.",null,{"inputs":[{"name":"vector3"}],"output":{"name":"trimesh"}}],[5,"unit_cuboid","","Generates a cuboid shape with a split index buffer.",null,{"inputs":[],"output":{"name":"trimesh"}}],[5,"rectangle","","The contour of a cuboid lying on the x-y plane.",null,null],[5,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane.",null,{"inputs":[],"output":{"name":"polyline"}}],[5,"unit_cylinder","","Generates a cylinder with unit height and diameter.",null,{"inputs":[{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"cylinder","","Generates a cylinder with a given height and diameter.",null,{"inputs":[{"name":"n"},{"name":"n"},{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"quad","","Adds a double-sided quad to the scene.",null,null],[5,"unit_quad","","Adds a double-sided quad with unit size to the scene.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"trimesh"}}],[5,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices.",null,null],[5,"sphere","","Generates a UV sphere.",null,{"inputs":[{"name":"n"},{"name":"u32"},{"name":"u32"},{"name":"bool"}],"output":{"name":"trimesh"}}],[5,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter.",null,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"bool"}],"output":{"name":"trimesh"}}],[5,"circle","","Creates a circle lying on the `(x,y)` plane.",null,null],[5,"unit_circle","","Creates a circle lying on the `(x,y)` plane.",null,{"inputs":[{"name":"u32"}],"output":{"name":"polyline"}}],[5,"unit_hemisphere","","Creates an hemisphere with a diameter of 1.",null,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"trimesh"}}],[5,"hacd","ncollide::transformation","Approximate convex decomposition of a triangle mesh.",null,null],[5,"convex_hull3","","Computes the convex hull of a set of 3d points.",null,null],[5,"convex_hull2","","Computes the convex hull of a set of 2d points.",null,null],[5,"convex_hull2_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices.",null,null],[5,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane.",null,null],[8,"ToTriMesh","","Trait implemented by shapes that can be approximated by a triangle mesh.",null,null],[10,"to_trimesh","","Builds a triangle mesh from this shape.",118,{"inputs":[{"name":"totrimesh"},{"name":"i"}],"output":{"name":"trimesh"}}],[8,"ToPolyline","","Trait implemented by shapes that can be approximated by a triangle mesh.",null,null],[10,"to_polyline","","Builds a triangle mesh from this shape.",119,{"inputs":[{"name":"topolyline"},{"name":"i"}],"output":{"name":"polyline"}}]],"paths":[[8,"FloatError"],[8,"Point"],[8,"Vector"],[3,"Pair"],[3,"PairTWHash"],[3,"UintPairTWHash"],[3,"UintTWHash"],[3,"Entry"],[3,"HashMap"],[3,"OwnedAllocationCache"],[3,"VecSlice"],[3,"VecSliceMut"],[3,"RefWithCost"],[3,"FastKey"],[3,"LookupData"],[3,"UidRemap"],[3,"FastKeys"],[3,"FastKeysAndValues"],[3,"FastKeysAndValuesMut"],[3,"VecMap"],[4,"Entry"],[3,"VacantEntry"],[3,"OccupiedEntry"],[3,"Iter"],[3,"IterMut"],[3,"Keys"],[3,"Values"],[3,"IntoIter"],[3,"BacktrackingLineSearch"],[3,"HashablePartialEq"],[8,"HashFun"],[8,"LineSearch"],[8,"AsBytes"],[3,"Plane"],[3,"Cuboid"],[3,"MinkowskiSum"],[3,"AnnotatedMinkowskiSum"],[3,"Segment"],[3,"Triangle"],[3,"BaseMesh"],[3,"TriMesh"],[3,"Polyline"],[3,"Ball"],[3,"Capsule"],[3,"Cone"],[3,"Cylinder"],[3,"Reflection"],[3,"Torus"],[3,"Compound"],[3,"ConvexHull"],[3,"ShapeHandle"],[3,"BoundingVolumeInterferencesCollector"],[8,"Repr"],[4,"UpdateState"],[3,"DBVT"],[4,"DBVTLeafState"],[3,"DBVTLeaf"],[3,"BVT"],[4,"BVTNode"],[8,"BaseMeshElement"],[8,"CompositeShape"],[8,"HasBoundingVolume"],[8,"BoundingVolume"],[4,"BinaryPartition"],[8,"BVTVisitor"],[8,"BVTTVisitor"],[8,"BVTCostFn"],[8,"SupportMap"],[8,"Simplex"],[3,"JohnsonSimplex"],[3,"RecursionTemplate"],[4,"GJKResult"],[3,"Contact"],[3,"CompositeShapeAgainstAnyDistCostFn"],[4,"Proximity"],[3,"CompositeShapeAgainstAnyInterfCostFn"],[3,"CompositeShapeAgainstAnyTOICostFn"],[3,"AABB"],[3,"BoundingSphere"],[3,"CompoundPointProjCostFn"],[3,"PointContainementTest"],[3,"BaseMeshPointProjCostFn"],[3,"PointContainementTest"],[3,"PointInterferencesCollector"],[3,"CompoundRayToiCostFn"],[3,"CompoundRayToiAndNormalCostFn"],[3,"BaseMeshRayToiCostFn"],[3,"BaseMeshRayToiAndNormalCostFn"],[3,"BaseMeshRayToiAndNormalAndUVsCostFn"],[3,"RayIntersectionCostFn"],[3,"RayInterferencesCollector"],[8,"PointQuery"],[3,"PointProjection"],[3,"Ray"],[8,"RayCast"],[3,"RayIntersection"],[8,"NarrowPhase"],[8,"ContactSignalHandler"],[8,"ProximitySignalHandler"],[8,"CollisionDetector"],[8,"CollisionDispatcher"],[8,"ProximityDetector"],[8,"ProximityDispatcher"],[8,"BroadPhase"],[8,"BroadPhasePairFilter"],[4,"CollisionQueryType"],[3,"CollisionObject"],[3,"NoCap"],[3,"ArrowheadCap"],[3,"PolylinePattern"],[3,"PolylinePath"],[4,"IndexBuffer"],[3,"TriMesh"],[3,"Polyline"],[4,"PathSample"],[8,"CurveSampler"],[8,"StrokePattern"],[8,"PolylineCompatibleCap"],[8,"ToTriMesh"],[8,"ToPolyline"]]};
initSearch(searchIndex);
