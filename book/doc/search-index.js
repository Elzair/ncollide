var searchIndex = {};
searchIndex['ncollide4df32'] = {"items":[[0,"","ncollide4df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide4df32::bounding_volume","An Axis Aligned Bounding Box."],[11,"mins","","",0],[11,"maxs","","",0],[1,"BoundingSphere","","A Bounding Sphere."],[11,"center","","",1],[11,"radius","","",1],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",2],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",3],[9,"contains","","Checks if this bounding volume contains another one.",3],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",3],[9,"merged","","Merges this bounding volume with another one.",3],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",4],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",4],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",5],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",6],[0,"geom","ncollide4df32","Geometric primitives."],[1,"Ball","ncollide4df32::geom","A Ball geometry."],[11,"radius","","",7],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",8],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",9],[11,"margin","","",9],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",10],[11,"radius","","",10],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",11],[11,"radius","","",11],[11,"margin","","",11],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",12],[11,"radius","","",12],[11,"margin","","",12],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",13],[11,"margin","","",13],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",14],[11,"g1","","",14],[11,"m2","","",14],[11,"g2","","",14],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",15],[11,"g1","","",15],[11,"m2","","",15],[11,"g2","","",15],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"geom","","",16],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"mass","","",17],[11,"inertia","","",17],[11,"com","","",17],[11,"geoms","","",17],[11,"bvt","","",17],[11,"bvs","","",17],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[11,"geoms","","",18],[11,"props","","",18],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",19],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",20],[11,"bvs","","",20],[11,"margin","","",20],[11,"vertices","","",20],[11,"indices","","",20],[11,"uvs","","",20],[11,"normals","","",20],[1,"Segment","","A segment geometry."],[11,"margin","","",21],[11,"a","","",21],[11,"b","","",21],[1,"Triangle","","A triangle geometry."],[11,"margin","","",22],[11,"a","","",22],[11,"b","","",22],[11,"c","","",22],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",23],[11,"nupoints","","",23],[11,"nvpoints","","",23],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",24],[11,"v_cache","","",24],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",25],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",26],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",27],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",27],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",28],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",29],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",29],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",29],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",29],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",29],[0,"ray","ncollide4df32","Ray casting utilities."],[1,"Ray","ncollide4df32::ray","A Ray."],[11,"orig","","Starting point of the ray.",30],[11,"dir","","Direction of the ray.",30],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",31],[11,"normal","","The normal at the intersection point.",31],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",32],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",32],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",32],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",32],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",32],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",32],[0,"narrow","ncollide4df32","Narrow phases."],[1,"Contact","ncollide4df32::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",33],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",33],[11,"normal","","Contact normal",33],[11,"depth","","Penetration depth",33],[1,"Empty","","A collision detector that does nothing."],[11,"dummy","","",34],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",35],[11,"contact","","",35],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",36],[11,"contact","","",36],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",37],[11,"contact","","",37],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",38],[11,"prediction","","",38],[11,"contact","","",38],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",39],[11,"collector","","",39],[11,"prediction","","",39],[11,"sub_detector","","",39],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",40],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",41],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",42],[11,"to_delete","","",42],[11,"interferences","","",42],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",43],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",44],[11,"tree","","",44],[11,"selector","","",44],[11,"prediction","","",44],[11,"contacts","","",44],[11,"points","","",44],[11,"timestamp","","",44],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",45],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[11,"cache","","",46],[11,"tree","","",46],[11,"selector","","",46],[11,"prediction","","",46],[11,"contacts","","",46],[11,"points","","",46],[11,"timestamp","","",46],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide4df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide4df32::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide4df32::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide4df32::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide4df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide4df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide4df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide4df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",47],[9,"translate_by","","Translates each point of this simplex.",47],[9,"add_point","","Adds a point to the simplex.",47],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",47],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",47],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",47],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",47],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",47],[0,"johnson_simplex","ncollide4df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide4df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",48],[11,"points","","",48],[11,"exchange_points","","",48],[11,"determinants","","",48],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",49],[11,"offsets","","",49],[11,"sub_determinants","","",49],[11,"num_determinants","","",49],[11,"num_leaves","","",49],[10,"clone","","",48],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",49],[10,"new","","Creates a new, empty, Johnson simplex.",48],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",48],[10,"reset","","",48],[10,"dimension","","",48],[10,"max_sq_len","","",48],[10,"contains_point","","",48],[10,"add_point","","",48],[10,"project_origin_and_reduce","","",48],[10,"project_origin","","",48],[10,"translate_by","","",48],[0,"gjk","ncollide4df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide4df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",50],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",50],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",50],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",50],[10,"decode","","",50],[10,"encode","","",50],[0,"minkowski_sampling","ncollide4df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide4df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide4df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide4df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",51],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",52],[11,"diff_v","","",52],[11,"max_lmd","","",52],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",53],[11,"spread_u","","",53],[11,"spread_v","","",53],[11,"axis_u","","",53],[11,"axis_v","","",53],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",54],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",54],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",54],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",54],[10,"clone","","",55],[10,"new","","Creates a new `YesSirSurfaceSelector`.",55],[10,"set_max_lmd","","",55],[10,"is_flat","","",55],[10,"may_contain_a_closest_point","","",55],[10,"create_test_data","","",55],[10,"clone","","",51],[10,"new","","Creates a new hyperplane-based surface selector.",51],[10,"set_max_lmd","","",51],[10,"is_flat","","",51],[10,"may_contain_a_closest_point","","",51],[10,"create_test_data","","",51],[10,"clone","","",52],[10,"new","","Creates a new tangent-cone based surface detector.",52],[10,"set_max_lmd","","",52],[10,"is_flat","","",52],[10,"may_contain_a_closest_point","","",52],[10,"create_test_data","","",52],[0,"surface_subdivision_tree","ncollide4df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide4df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",56],[11,"value","","",56],[11,"key","","",56],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",57],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",58],[11,"lchild","","",58],[11,"timestamp","","",58],[11,"data","","",58],[11,"surface","","",58],[10,"clone","","",56],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",56],[10,"deref","","",56],[10,"drop","","",56],[10,"new","","Creates a new surface subdivision tree cache.",57],[10,"clear","","Removes everything from this cache.",57],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",57],[10,"new_orphan","","Creates a new tree with no parent nor children.",58],[10,"surface","","The surface contained by this node.",58],[10,"data","","Reference to the data contained by this node.",58],[10,"data_mut","","Mutable reference to the data contained by this node.",58],[10,"timestamp","","The timestamp of this tree node.",58],[10,"set_timestamp","","Sets the timestamp of this tree node.",58],[10,"has_left_child","","Whether or not this node has a left child.",58],[10,"has_right_child","","Whether or not this node has a right child.",58],[10,"right_child","","A copy of this node right child.",58],[10,"left_child","","A copy of this node left child.",58],[10,"right_child_ref","","A reference to this node right child.",58],[10,"left_child_ref","","A reference to this node left child.",58],[10,"set_right_child","","Sets the right child of this node.",58],[10,"set_left_child","","Sets the left child of this node.",58],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",58],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",58],[10,"remove_right_child","","Removes the right child of this node.",58],[10,"remove_left_child","","Removes the left child of this node.",58],[6,"CollisionDetector","ncollide4df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",59],[9,"num_colls","","The number of collision detected during the last update.",59],[9,"colls","","Collects the collisions detected during the last update.",59],[9,"toi","","Computes the time of impact of two objects.",59],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",60],[9,"num_colls","","The number of collision detected during the last update.",60],[9,"colls","","Collects the collisions detected during the last update.",60],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",61],[0,"broad","ncollide4df32","Broad phases."],[1,"NoIdDispatcher","ncollide4df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[11,"dispatcher","","",62],[11,"pairs","","",62],[11,"objects","","",62],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",63],[11,"sobjects","","",63],[11,"rb2bv","","",63],[11,"pairs","","",63],[11,"dispatcher","","",63],[11,"margin","","",63],[11,"to_update","","",63],[11,"update_off","","",63],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",64],[11,"stree","","",64],[11,"active2bv","","",64],[11,"inactive2bv","","",64],[11,"pairs","","",64],[11,"spairs","","",64],[11,"dispatcher","","",64],[11,"margin","","",64],[11,"collector","","",64],[11,"to_update","","",64],[11,"update_off","","",64],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",65],[9,"remove","","Removes an element from this broad phase.",65],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",65],[9,"update_object","","Updates the collision pairs involving one specific object.",65],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",66],[9,"deactivate","","Marks and object as inactive.",66],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",66],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",66],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",67],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",68],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",69],[9,"is_valid","","Tells whether a collision between two bodies can occur.",69],[0,"volumetric","ncollide4df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide4df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide4df32::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",70],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",70],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",70],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",71],[0,"implicit","ncollide4df32","Definition of support functions."],[3,"cso_support_point","ncollide4df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",73],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",74],[0,"partitioning","ncollide4df32","Spatial partitioning tools."],[1,"DBVT","ncollide4df32::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",75],[11,"tree","","",75],[11,"len","","",75],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",76],[11,"center","","The center of this node bounding volume.",76],[11,"object","","An user-defined object.",76],[11,"parent","","This node parent.",76],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",77],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",78],[11,"collector","","",78],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",79],[11,"collector","","",79],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",80],[12,"LeftChildOf","","This leaf is the left child of another node.",80],[12,"Detached","","This leaf is detached from any tree.",80],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",81],[12,"Parts","","Result of the partitioning of several elements.",81],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[9,"visit_leaf","","Visits a leaf.",82],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[10,"visit_leaf_mut","","Visits a leaf.",82],[0,"procedural","ncollide4df32","Procedural mesh generation."],[1,"TriMesh","ncollide4df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",83],[11,"normals","","Coordinates of the mesh normals.",83],[11,"uvs","","Textures coordinates of the mesh.",83],[11,"indices","","Index buffer of the mesh.",83],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",84],[11,"normals","","Coordinates of the polyline normals.",84],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",85],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",85],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide4df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide4df32::procedural","Path generation."],[1,"PolylinePattern","ncollide4df32::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",86],[11,"closed","","",86],[11,"last_start_id","","",86],[11,"start_cap","","",86],[11,"end_cap","","",86],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",87],[11,"curr_dir","","",87],[11,"curr_pt_id","","",87],[11,"curr_pt","","",87],[11,"polyline","","",87],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",88],[11,"front_dist_to_head","","",88],[11,"back_dist_to_head","","",88],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",89],[12,"InnerPoint","","A point that is inside of the path currently generated.",89],[12,"EndPoint","","A point that ends the path currently generated.",89],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",89],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",90],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",91],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",92],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",92],[6,"ToTriMesh","ncollide4df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",93],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",94],[0,"utils","ncollide4df32","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide4df32::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide4df32","Data structure utilities."],[0,"pair","ncollide4df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide4df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",95],[11,"second","","second object of the pair",95],[11,"ifirst","","",95],[11,"isecond","","",95],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",96],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Builds a new `Pair`.",95],[10,"eq","","",95],[10,"decode","","",96],[10,"encode","","",96],[10,"new","","Creates a new PairTWHash",96],[10,"hash","","",96],[0,"hash","ncollide4df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide4df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",97],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",98],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",99],[10,"decode","","",97],[10,"encode","","",97],[10,"clone","","",97],[10,"new","","Creates a new UintPairTWHash.",97],[10,"hash","","",97],[10,"decode","","",98],[10,"encode","","",98],[10,"clone","","",98],[10,"new","","Creates a new UintTWHash.",98],[10,"hash","","",98],[0,"hash_map","ncollide4df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide4df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",100],[11,"value","","The value of the entry.",100],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",101],[11,"table","","",101],[11,"mask","","",101],[11,"htable","","",101],[11,"next","","",101],[11,"num_elem","","",101],[11,"max_elem","","",101],[11,"real_max_elem","","",101],[10,"decode","","",100],[10,"encode","","",100],[10,"clone","","",100],[10,"decode","","",101],[10,"encode","","",101],[10,"clone","","",101],[10,"new","","Creates a new hash map.",101],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",101],[10,"elements","","The elements added to this hash map.",101],[10,"elements_mut","","The elements added to this hash map.",101],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",101],[10,"get_and_remove","","Removes an element and returns its value if it existed.",101],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",101],[10,"insert_or_replace","","Inserts or replace an element.",101],[10,"len","","",101],[10,"clear","","",101],[10,"contains_key","","",101],[10,"find","","",101],[10,"insert","","Inserts an element on the hash map.",101],[10,"remove","","Remove an element from the hash map.",101],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",101],[0,"owned_allocation_cache","ncollide4df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide4df32::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",102],[10,"new","","Initializes the cache.",102],[10,"alloc","","Box a value into a potentially already allocated box.",102],[10,"retain","","Retains a box which can be re-used by the `box` method.",102],[10,"clear","","Clears the cache, destroying any stored pointer.",102],[0,"has_uid","ncollide4df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide4df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",103],[10,"uid","std::gc","",104],[10,"uid","alloc::rc","",105],[10,"uid","alloc::arc","",106],[0,"vec_slice","ncollide4df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide4df32::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",107],[11,"length","","",107],[11,"stride","","",107],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",108],[11,"length","","",108],[11,"stride","","",108],[10,"len","","",107],[10,"is_empty","","",107],[10,"len","","",108],[10,"is_empty","","",108],[10,"new","","Creates a new immutable slice.",107],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",107],[10,"get","","Gets the i-th element of the slice.",107],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",107],[10,"new","","Creates a new mutable slice.",108],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",108],[10,"as_slice","","Creates an immutable slice from this mutable slice.",108],[10,"get","","Gets the i-th element of the slice.",108],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",108],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",108],[0,"math","ncollide4df32","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide4df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",109],[10,"to_world_space","","",109],[10,"to_relative_wrt_point","","",109]],"paths":[[1,"AABB"],[1,"BoundingSphere"],[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"CompoundData"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[1,"BezierSurfaceBezierSurface"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};
searchIndex['ncollide3df32'] = {"items":[[0,"","ncollide3df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide3df32::bounding_volume","An Axis Aligned Bounding Box."],[11,"mins","","",0],[11,"maxs","","",0],[1,"BoundingSphere","","A Bounding Sphere."],[11,"center","","",1],[11,"radius","","",1],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",2],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",3],[9,"contains","","Checks if this bounding volume contains another one.",3],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",3],[9,"merged","","Merges this bounding volume with another one.",3],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",4],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",4],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",5],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",6],[0,"geom","ncollide3df32","Geometric primitives."],[1,"Ball","ncollide3df32::geom","A Ball geometry."],[11,"radius","","",7],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",8],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",9],[11,"margin","","",9],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",10],[11,"radius","","",10],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",11],[11,"radius","","",11],[11,"margin","","",11],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",12],[11,"radius","","",12],[11,"margin","","",12],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",13],[11,"margin","","",13],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",14],[11,"g1","","",14],[11,"m2","","",14],[11,"g2","","",14],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",15],[11,"g1","","",15],[11,"m2","","",15],[11,"g2","","",15],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"geom","","",16],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"mass","","",17],[11,"inertia","","",17],[11,"com","","",17],[11,"geoms","","",17],[11,"bvt","","",17],[11,"bvs","","",17],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[11,"geoms","","",18],[11,"props","","",18],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",19],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",20],[11,"bvs","","",20],[11,"margin","","",20],[11,"vertices","","",20],[11,"indices","","",20],[11,"uvs","","",20],[11,"normals","","",20],[1,"Segment","","A segment geometry."],[11,"margin","","",21],[11,"a","","",21],[11,"b","","",21],[1,"Triangle","","A triangle geometry."],[11,"margin","","",22],[11,"a","","",22],[11,"b","","",22],[11,"c","","",22],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",23],[11,"nupoints","","",23],[11,"nvpoints","","",23],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",24],[11,"v_cache","","",24],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",25],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",26],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",27],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",27],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",28],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",29],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",29],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",29],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",29],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",29],[0,"ray","ncollide3df32","Ray casting utilities."],[1,"Ray","ncollide3df32::ray","A Ray."],[11,"orig","","Starting point of the ray.",30],[11,"dir","","Direction of the ray.",30],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",31],[11,"normal","","The normal at the intersection point.",31],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",31],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",32],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",32],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",32],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",32],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",32],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",32],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",32],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",32],[0,"narrow","ncollide3df32","Narrow phases."],[1,"Contact","ncollide3df32::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",33],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",33],[11,"normal","","Contact normal",33],[11,"depth","","Penetration depth",33],[1,"Empty","","A collision detector that does nothing."],[11,"dummy","","",34],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",35],[11,"contact","","",35],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",36],[11,"contact","","",36],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",37],[11,"contact","","",37],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",38],[11,"prediction","","",38],[11,"contact","","",38],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",39],[11,"collector","","",39],[11,"prediction","","",39],[11,"sub_detector","","",39],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",40],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",41],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",42],[11,"to_delete","","",42],[11,"interferences","","",42],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",43],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",44],[11,"tree","","",44],[11,"selector","","",44],[11,"prediction","","",44],[11,"contacts","","",44],[11,"points","","",44],[11,"timestamp","","",44],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",45],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[11,"cache","","",46],[11,"tree","","",46],[11,"selector","","",46],[11,"prediction","","",46],[11,"contacts","","",46],[11,"points","","",46],[11,"timestamp","","",46],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide3df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide3df32::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide3df32::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide3df32::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide3df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide3df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide3df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide3df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",47],[9,"translate_by","","Translates each point of this simplex.",47],[9,"add_point","","Adds a point to the simplex.",47],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",47],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",47],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",47],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",47],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",47],[0,"johnson_simplex","ncollide3df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide3df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",48],[11,"points","","",48],[11,"exchange_points","","",48],[11,"determinants","","",48],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",49],[11,"offsets","","",49],[11,"sub_determinants","","",49],[11,"num_determinants","","",49],[11,"num_leaves","","",49],[10,"clone","","",48],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",49],[10,"new","","Creates a new, empty, Johnson simplex.",48],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",48],[10,"reset","","",48],[10,"dimension","","",48],[10,"max_sq_len","","",48],[10,"contains_point","","",48],[10,"add_point","","",48],[10,"project_origin_and_reduce","","",48],[10,"project_origin","","",48],[10,"translate_by","","",48],[0,"gjk","ncollide3df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide3df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",50],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",50],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",50],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",50],[10,"decode","","",50],[10,"encode","","",50],[0,"minkowski_sampling","ncollide3df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide3df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide3df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide3df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",51],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",52],[11,"diff_v","","",52],[11,"max_lmd","","",52],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",53],[11,"spread_u","","",53],[11,"spread_v","","",53],[11,"axis_u","","",53],[11,"axis_v","","",53],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",54],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",54],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",54],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",54],[10,"clone","","",55],[10,"new","","Creates a new `YesSirSurfaceSelector`.",55],[10,"set_max_lmd","","",55],[10,"is_flat","","",55],[10,"may_contain_a_closest_point","","",55],[10,"create_test_data","","",55],[10,"clone","","",51],[10,"new","","Creates a new hyperplane-based surface selector.",51],[10,"set_max_lmd","","",51],[10,"is_flat","","",51],[10,"may_contain_a_closest_point","","",51],[10,"create_test_data","","",51],[10,"clone","","",52],[10,"new","","Creates a new tangent-cone based surface detector.",52],[10,"set_max_lmd","","",52],[10,"is_flat","","",52],[10,"may_contain_a_closest_point","","",52],[10,"create_test_data","","",52],[0,"surface_subdivision_tree","ncollide3df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide3df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",56],[11,"value","","",56],[11,"key","","",56],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",57],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",58],[11,"lchild","","",58],[11,"timestamp","","",58],[11,"data","","",58],[11,"surface","","",58],[10,"clone","","",56],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",56],[10,"deref","","",56],[10,"drop","","",56],[10,"new","","Creates a new surface subdivision tree cache.",57],[10,"clear","","Removes everything from this cache.",57],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",57],[10,"new_orphan","","Creates a new tree with no parent nor children.",58],[10,"surface","","The surface contained by this node.",58],[10,"data","","Reference to the data contained by this node.",58],[10,"data_mut","","Mutable reference to the data contained by this node.",58],[10,"timestamp","","The timestamp of this tree node.",58],[10,"set_timestamp","","Sets the timestamp of this tree node.",58],[10,"has_left_child","","Whether or not this node has a left child.",58],[10,"has_right_child","","Whether or not this node has a right child.",58],[10,"right_child","","A copy of this node right child.",58],[10,"left_child","","A copy of this node left child.",58],[10,"right_child_ref","","A reference to this node right child.",58],[10,"left_child_ref","","A reference to this node left child.",58],[10,"set_right_child","","Sets the right child of this node.",58],[10,"set_left_child","","Sets the left child of this node.",58],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",58],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",58],[10,"remove_right_child","","Removes the right child of this node.",58],[10,"remove_left_child","","Removes the left child of this node.",58],[6,"CollisionDetector","ncollide3df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",59],[9,"num_colls","","The number of collision detected during the last update.",59],[9,"colls","","Collects the collisions detected during the last update.",59],[9,"toi","","Computes the time of impact of two objects.",59],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",60],[9,"num_colls","","The number of collision detected during the last update.",60],[9,"colls","","Collects the collisions detected during the last update.",60],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",61],[0,"broad","ncollide3df32","Broad phases."],[1,"NoIdDispatcher","ncollide3df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[11,"dispatcher","","",62],[11,"pairs","","",62],[11,"objects","","",62],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",63],[11,"sobjects","","",63],[11,"rb2bv","","",63],[11,"pairs","","",63],[11,"dispatcher","","",63],[11,"margin","","",63],[11,"to_update","","",63],[11,"update_off","","",63],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",64],[11,"stree","","",64],[11,"active2bv","","",64],[11,"inactive2bv","","",64],[11,"pairs","","",64],[11,"spairs","","",64],[11,"dispatcher","","",64],[11,"margin","","",64],[11,"collector","","",64],[11,"to_update","","",64],[11,"update_off","","",64],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",65],[9,"remove","","Removes an element from this broad phase.",65],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",65],[9,"update_object","","Updates the collision pairs involving one specific object.",65],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",66],[9,"deactivate","","Marks and object as inactive.",66],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",66],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",66],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",67],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",68],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",69],[9,"is_valid","","Tells whether a collision between two bodies can occur.",69],[0,"volumetric","ncollide3df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide3df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide3df32::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",70],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",70],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",70],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",71],[0,"implicit","ncollide3df32","Definition of support functions."],[3,"cso_support_point","ncollide3df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",73],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",74],[0,"partitioning","ncollide3df32","Spatial partitioning tools."],[1,"DBVT","ncollide3df32::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",75],[11,"tree","","",75],[11,"len","","",75],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",76],[11,"center","","The center of this node bounding volume.",76],[11,"object","","An user-defined object.",76],[11,"parent","","This node parent.",76],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",77],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",78],[11,"collector","","",78],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",79],[11,"collector","","",79],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",80],[12,"LeftChildOf","","This leaf is the left child of another node.",80],[12,"Detached","","This leaf is detached from any tree.",80],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",81],[12,"Parts","","Result of the partitioning of several elements.",81],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[9,"visit_leaf","","Visits a leaf.",82],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[10,"visit_leaf_mut","","Visits a leaf.",82],[0,"procedural","ncollide3df32","Procedural mesh generation."],[1,"TriMesh","ncollide3df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",83],[11,"normals","","Coordinates of the mesh normals.",83],[11,"uvs","","Textures coordinates of the mesh.",83],[11,"indices","","Index buffer of the mesh.",83],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",84],[11,"normals","","Coordinates of the polyline normals.",84],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",85],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",85],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide3df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide3df32::procedural","Path generation."],[1,"PolylinePattern","ncollide3df32::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",86],[11,"closed","","",86],[11,"last_start_id","","",86],[11,"start_cap","","",86],[11,"end_cap","","",86],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",87],[11,"curr_dir","","",87],[11,"curr_pt_id","","",87],[11,"curr_pt","","",87],[11,"polyline","","",87],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",88],[11,"front_dist_to_head","","",88],[11,"back_dist_to_head","","",88],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",89],[12,"InnerPoint","","A point that is inside of the path currently generated.",89],[12,"EndPoint","","A point that ends the path currently generated.",89],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",89],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",90],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",91],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",92],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",92],[6,"ToTriMesh","ncollide3df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",93],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",94],[0,"utils","ncollide3df32","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide3df32::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide3df32","Data structure utilities."],[0,"pair","ncollide3df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide3df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",95],[11,"second","","second object of the pair",95],[11,"ifirst","","",95],[11,"isecond","","",95],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",96],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Builds a new `Pair`.",95],[10,"eq","","",95],[10,"decode","","",96],[10,"encode","","",96],[10,"new","","Creates a new PairTWHash",96],[10,"hash","","",96],[0,"hash","ncollide3df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide3df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",97],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",98],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",99],[10,"decode","","",97],[10,"encode","","",97],[10,"clone","","",97],[10,"new","","Creates a new UintPairTWHash.",97],[10,"hash","","",97],[10,"decode","","",98],[10,"encode","","",98],[10,"clone","","",98],[10,"new","","Creates a new UintTWHash.",98],[10,"hash","","",98],[0,"hash_map","ncollide3df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide3df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",100],[11,"value","","The value of the entry.",100],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",101],[11,"table","","",101],[11,"mask","","",101],[11,"htable","","",101],[11,"next","","",101],[11,"num_elem","","",101],[11,"max_elem","","",101],[11,"real_max_elem","","",101],[10,"decode","","",100],[10,"encode","","",100],[10,"clone","","",100],[10,"decode","","",101],[10,"encode","","",101],[10,"clone","","",101],[10,"new","","Creates a new hash map.",101],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",101],[10,"elements","","The elements added to this hash map.",101],[10,"elements_mut","","The elements added to this hash map.",101],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",101],[10,"get_and_remove","","Removes an element and returns its value if it existed.",101],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",101],[10,"insert_or_replace","","Inserts or replace an element.",101],[10,"len","","",101],[10,"clear","","",101],[10,"contains_key","","",101],[10,"find","","",101],[10,"insert","","Inserts an element on the hash map.",101],[10,"remove","","Remove an element from the hash map.",101],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",101],[0,"owned_allocation_cache","ncollide3df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide3df32::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",102],[10,"new","","Initializes the cache.",102],[10,"alloc","","Box a value into a potentially already allocated box.",102],[10,"retain","","Retains a box which can be re-used by the `box` method.",102],[10,"clear","","Clears the cache, destroying any stored pointer.",102],[0,"has_uid","ncollide3df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide3df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",103],[10,"uid","std::gc","",104],[10,"uid","alloc::rc","",105],[10,"uid","alloc::arc","",106],[0,"vec_slice","ncollide3df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide3df32::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",107],[11,"length","","",107],[11,"stride","","",107],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",108],[11,"length","","",108],[11,"stride","","",108],[10,"len","","",107],[10,"is_empty","","",107],[10,"len","","",108],[10,"is_empty","","",108],[10,"new","","Creates a new immutable slice.",107],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",107],[10,"get","","Gets the i-th element of the slice.",107],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",107],[10,"new","","Creates a new mutable slice.",108],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",108],[10,"as_slice","","Creates an immutable slice from this mutable slice.",108],[10,"get","","Gets the i-th element of the slice.",108],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",108],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",108],[0,"math","ncollide3df32","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide3df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",109],[10,"to_world_space","","",109],[10,"to_relative_wrt_point","","",109]],"paths":[[1,"AABB"],[1,"BoundingSphere"],[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"CompoundData"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[1,"BezierSurfaceBezierSurface"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['ncollide2df32'] = {"items":[[0,"","ncollide2df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide2df32::bounding_volume","An Axis Aligned Bounding Box."],[11,"mins","","",0],[11,"maxs","","",0],[1,"BoundingSphere","","A Bounding Sphere."],[11,"center","","",1],[11,"radius","","",1],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",2],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",3],[9,"contains","","Checks if this bounding volume contains another one.",3],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",3],[9,"merged","","Merges this bounding volume with another one.",3],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",4],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",4],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",5],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",6],[0,"geom","ncollide2df32","Geometric primitives."],[1,"Ball","ncollide2df32::geom","A Ball geometry."],[11,"radius","","",7],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",8],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",9],[11,"margin","","",9],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",10],[11,"radius","","",10],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",11],[11,"radius","","",11],[11,"margin","","",11],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",12],[11,"radius","","",12],[11,"margin","","",12],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",13],[11,"margin","","",13],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",14],[11,"g1","","",14],[11,"m2","","",14],[11,"g2","","",14],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",15],[11,"g1","","",15],[11,"m2","","",15],[11,"g2","","",15],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"geom","","",16],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"mass","","",17],[11,"inertia","","",17],[11,"com","","",17],[11,"geoms","","",17],[11,"bvt","","",17],[11,"bvs","","",17],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[11,"geoms","","",18],[11,"props","","",18],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",19],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",20],[11,"bvs","","",20],[11,"margin","","",20],[11,"vertices","","",20],[11,"indices","","",20],[11,"uvs","","",20],[11,"normals","","",20],[1,"Segment","","A segment geometry."],[11,"margin","","",21],[11,"a","","",21],[11,"b","","",21],[1,"Triangle","","A triangle geometry."],[11,"margin","","",22],[11,"a","","",22],[11,"b","","",22],[11,"c","","",22],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",23],[11,"nupoints","","",23],[11,"nvpoints","","",23],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",24],[11,"v_cache","","",24],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",25],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",26],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",27],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",27],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",28],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",29],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",29],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",29],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",29],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",29],[0,"ray","ncollide2df32","Ray casting utilities."],[1,"Ray","ncollide2df32::ray","A Ray."],[11,"orig","","Starting point of the ray.",30],[11,"dir","","Direction of the ray.",30],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",31],[11,"normal","","The normal at the intersection point.",31],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",32],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",32],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",32],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",32],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",32],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",32],[0,"narrow","ncollide2df32","Narrow phases."],[1,"Contact","ncollide2df32::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",33],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",33],[11,"normal","","Contact normal",33],[11,"depth","","Penetration depth",33],[1,"Empty","","A collision detector that does nothing."],[11,"dummy","","",34],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",35],[11,"contact","","",35],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",36],[11,"contact","","",36],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",37],[11,"contact","","",37],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",38],[11,"prediction","","",38],[11,"contact","","",38],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",39],[11,"collector","","",39],[11,"prediction","","",39],[11,"sub_detector","","",39],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",40],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",41],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",42],[11,"to_delete","","",42],[11,"interferences","","",42],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",43],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",44],[11,"tree","","",44],[11,"selector","","",44],[11,"prediction","","",44],[11,"contacts","","",44],[11,"points","","",44],[11,"timestamp","","",44],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",45],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[11,"cache","","",46],[11,"tree","","",46],[11,"selector","","",46],[11,"prediction","","",46],[11,"contacts","","",46],[11,"points","","",46],[11,"timestamp","","",46],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide2df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide2df32::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide2df32::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide2df32::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide2df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide2df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide2df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide2df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",47],[9,"translate_by","","Translates each point of this simplex.",47],[9,"add_point","","Adds a point to the simplex.",47],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",47],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",47],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",47],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",47],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",47],[0,"johnson_simplex","ncollide2df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide2df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",48],[11,"points","","",48],[11,"exchange_points","","",48],[11,"determinants","","",48],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",49],[11,"offsets","","",49],[11,"sub_determinants","","",49],[11,"num_determinants","","",49],[11,"num_leaves","","",49],[10,"clone","","",48],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",49],[10,"new","","Creates a new, empty, Johnson simplex.",48],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",48],[10,"reset","","",48],[10,"dimension","","",48],[10,"max_sq_len","","",48],[10,"contains_point","","",48],[10,"add_point","","",48],[10,"project_origin_and_reduce","","",48],[10,"project_origin","","",48],[10,"translate_by","","",48],[0,"gjk","ncollide2df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide2df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",50],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",50],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",50],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",50],[10,"decode","","",50],[10,"encode","","",50],[0,"minkowski_sampling","ncollide2df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide2df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide2df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide2df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",51],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",52],[11,"diff_v","","",52],[11,"max_lmd","","",52],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",53],[11,"spread_u","","",53],[11,"spread_v","","",53],[11,"axis_u","","",53],[11,"axis_v","","",53],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",54],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",54],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",54],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",54],[10,"clone","","",55],[10,"new","","Creates a new `YesSirSurfaceSelector`.",55],[10,"set_max_lmd","","",55],[10,"is_flat","","",55],[10,"may_contain_a_closest_point","","",55],[10,"create_test_data","","",55],[10,"clone","","",51],[10,"new","","Creates a new hyperplane-based surface selector.",51],[10,"set_max_lmd","","",51],[10,"is_flat","","",51],[10,"may_contain_a_closest_point","","",51],[10,"create_test_data","","",51],[10,"clone","","",52],[10,"new","","Creates a new tangent-cone based surface detector.",52],[10,"set_max_lmd","","",52],[10,"is_flat","","",52],[10,"may_contain_a_closest_point","","",52],[10,"create_test_data","","",52],[0,"surface_subdivision_tree","ncollide2df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide2df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",56],[11,"value","","",56],[11,"key","","",56],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",57],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",58],[11,"lchild","","",58],[11,"timestamp","","",58],[11,"data","","",58],[11,"surface","","",58],[10,"clone","","",56],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",56],[10,"deref","","",56],[10,"drop","","",56],[10,"new","","Creates a new surface subdivision tree cache.",57],[10,"clear","","Removes everything from this cache.",57],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",57],[10,"new_orphan","","Creates a new tree with no parent nor children.",58],[10,"surface","","The surface contained by this node.",58],[10,"data","","Reference to the data contained by this node.",58],[10,"data_mut","","Mutable reference to the data contained by this node.",58],[10,"timestamp","","The timestamp of this tree node.",58],[10,"set_timestamp","","Sets the timestamp of this tree node.",58],[10,"has_left_child","","Whether or not this node has a left child.",58],[10,"has_right_child","","Whether or not this node has a right child.",58],[10,"right_child","","A copy of this node right child.",58],[10,"left_child","","A copy of this node left child.",58],[10,"right_child_ref","","A reference to this node right child.",58],[10,"left_child_ref","","A reference to this node left child.",58],[10,"set_right_child","","Sets the right child of this node.",58],[10,"set_left_child","","Sets the left child of this node.",58],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",58],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",58],[10,"remove_right_child","","Removes the right child of this node.",58],[10,"remove_left_child","","Removes the left child of this node.",58],[6,"CollisionDetector","ncollide2df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",59],[9,"num_colls","","The number of collision detected during the last update.",59],[9,"colls","","Collects the collisions detected during the last update.",59],[9,"toi","","Computes the time of impact of two objects.",59],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",60],[9,"num_colls","","The number of collision detected during the last update.",60],[9,"colls","","Collects the collisions detected during the last update.",60],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",61],[0,"broad","ncollide2df32","Broad phases."],[1,"NoIdDispatcher","ncollide2df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[11,"dispatcher","","",62],[11,"pairs","","",62],[11,"objects","","",62],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",63],[11,"sobjects","","",63],[11,"rb2bv","","",63],[11,"pairs","","",63],[11,"dispatcher","","",63],[11,"margin","","",63],[11,"to_update","","",63],[11,"update_off","","",63],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",64],[11,"stree","","",64],[11,"active2bv","","",64],[11,"inactive2bv","","",64],[11,"pairs","","",64],[11,"spairs","","",64],[11,"dispatcher","","",64],[11,"margin","","",64],[11,"collector","","",64],[11,"to_update","","",64],[11,"update_off","","",64],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",65],[9,"remove","","Removes an element from this broad phase.",65],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",65],[9,"update_object","","Updates the collision pairs involving one specific object.",65],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",66],[9,"deactivate","","Marks and object as inactive.",66],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",66],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",66],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",67],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",68],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",69],[9,"is_valid","","Tells whether a collision between two bodies can occur.",69],[0,"volumetric","ncollide2df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide2df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide2df32::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",70],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",70],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",70],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",71],[0,"implicit","ncollide2df32","Definition of support functions."],[3,"cso_support_point","ncollide2df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",73],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",74],[0,"partitioning","ncollide2df32","Spatial partitioning tools."],[1,"DBVT","ncollide2df32::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",75],[11,"tree","","",75],[11,"len","","",75],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",76],[11,"center","","The center of this node bounding volume.",76],[11,"object","","An user-defined object.",76],[11,"parent","","This node parent.",76],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",77],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",78],[11,"collector","","",78],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",79],[11,"collector","","",79],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",80],[12,"LeftChildOf","","This leaf is the left child of another node.",80],[12,"Detached","","This leaf is detached from any tree.",80],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",81],[12,"Parts","","Result of the partitioning of several elements.",81],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[9,"visit_leaf","","Visits a leaf.",82],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[10,"visit_leaf_mut","","Visits a leaf.",82],[0,"procedural","ncollide2df32","Procedural mesh generation."],[1,"TriMesh","ncollide2df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",83],[11,"normals","","Coordinates of the mesh normals.",83],[11,"uvs","","Textures coordinates of the mesh.",83],[11,"indices","","Index buffer of the mesh.",83],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",84],[11,"normals","","Coordinates of the polyline normals.",84],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",85],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",85],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide2df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide2df32::procedural","Path generation."],[1,"PolylinePattern","ncollide2df32::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",86],[11,"closed","","",86],[11,"last_start_id","","",86],[11,"start_cap","","",86],[11,"end_cap","","",86],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",87],[11,"curr_dir","","",87],[11,"curr_pt_id","","",87],[11,"curr_pt","","",87],[11,"polyline","","",87],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",88],[11,"front_dist_to_head","","",88],[11,"back_dist_to_head","","",88],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",89],[12,"InnerPoint","","A point that is inside of the path currently generated.",89],[12,"EndPoint","","A point that ends the path currently generated.",89],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",89],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",90],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",91],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",92],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",92],[6,"ToTriMesh","ncollide2df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",93],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",94],[0,"utils","ncollide2df32","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide2df32::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide2df32","Data structure utilities."],[0,"pair","ncollide2df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide2df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",95],[11,"second","","second object of the pair",95],[11,"ifirst","","",95],[11,"isecond","","",95],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",96],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Builds a new `Pair`.",95],[10,"eq","","",95],[10,"decode","","",96],[10,"encode","","",96],[10,"new","","Creates a new PairTWHash",96],[10,"hash","","",96],[0,"hash","ncollide2df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide2df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",97],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",98],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",99],[10,"decode","","",97],[10,"encode","","",97],[10,"clone","","",97],[10,"new","","Creates a new UintPairTWHash.",97],[10,"hash","","",97],[10,"decode","","",98],[10,"encode","","",98],[10,"clone","","",98],[10,"new","","Creates a new UintTWHash.",98],[10,"hash","","",98],[0,"hash_map","ncollide2df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide2df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",100],[11,"value","","The value of the entry.",100],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",101],[11,"table","","",101],[11,"mask","","",101],[11,"htable","","",101],[11,"next","","",101],[11,"num_elem","","",101],[11,"max_elem","","",101],[11,"real_max_elem","","",101],[10,"decode","","",100],[10,"encode","","",100],[10,"clone","","",100],[10,"decode","","",101],[10,"encode","","",101],[10,"clone","","",101],[10,"new","","Creates a new hash map.",101],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",101],[10,"elements","","The elements added to this hash map.",101],[10,"elements_mut","","The elements added to this hash map.",101],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",101],[10,"get_and_remove","","Removes an element and returns its value if it existed.",101],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",101],[10,"insert_or_replace","","Inserts or replace an element.",101],[10,"len","","",101],[10,"clear","","",101],[10,"contains_key","","",101],[10,"find","","",101],[10,"insert","","Inserts an element on the hash map.",101],[10,"remove","","Remove an element from the hash map.",101],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",101],[0,"owned_allocation_cache","ncollide2df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide2df32::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",102],[10,"new","","Initializes the cache.",102],[10,"alloc","","Box a value into a potentially already allocated box.",102],[10,"retain","","Retains a box which can be re-used by the `box` method.",102],[10,"clear","","Clears the cache, destroying any stored pointer.",102],[0,"has_uid","ncollide2df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide2df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",103],[10,"uid","std::gc","",104],[10,"uid","alloc::rc","",105],[10,"uid","alloc::arc","",106],[0,"vec_slice","ncollide2df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide2df32::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",107],[11,"length","","",107],[11,"stride","","",107],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",108],[11,"length","","",108],[11,"stride","","",108],[10,"len","","",107],[10,"is_empty","","",107],[10,"len","","",108],[10,"is_empty","","",108],[10,"new","","Creates a new immutable slice.",107],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",107],[10,"get","","Gets the i-th element of the slice.",107],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",107],[10,"new","","Creates a new mutable slice.",108],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",108],[10,"as_slice","","Creates an immutable slice from this mutable slice.",108],[10,"get","","Gets the i-th element of the slice.",108],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",108],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",108],[0,"math","ncollide2df32","Compilation-flags-dependent aliases for mathematical types."],[4,"Scalar","ncollide2df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",109],[10,"to_world_space","","",109],[10,"to_relative_wrt_point","","",109]],"paths":[[1,"AABB"],[1,"BoundingSphere"],[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"CompoundData"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[1,"BezierSurfaceBezierSurface"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['ncollide4df64'] = {"items":[[0,"","ncollide4df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide4df64::bounding_volume","An Axis Aligned Bounding Box."],[11,"mins","","",0],[11,"maxs","","",0],[1,"BoundingSphere","","A Bounding Sphere."],[11,"center","","",1],[11,"radius","","",1],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",2],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",3],[9,"contains","","Checks if this bounding volume contains another one.",3],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",3],[9,"merged","","Merges this bounding volume with another one.",3],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",4],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",4],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",5],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",6],[0,"geom","ncollide4df64","Geometric primitives."],[1,"Ball","ncollide4df64::geom","A Ball geometry."],[11,"radius","","",7],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",8],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",9],[11,"margin","","",9],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",10],[11,"radius","","",10],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",11],[11,"radius","","",11],[11,"margin","","",11],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",12],[11,"radius","","",12],[11,"margin","","",12],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",13],[11,"margin","","",13],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",14],[11,"g1","","",14],[11,"m2","","",14],[11,"g2","","",14],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",15],[11,"g1","","",15],[11,"m2","","",15],[11,"g2","","",15],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"geom","","",16],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"mass","","",17],[11,"inertia","","",17],[11,"com","","",17],[11,"geoms","","",17],[11,"bvt","","",17],[11,"bvs","","",17],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[11,"geoms","","",18],[11,"props","","",18],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",19],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",20],[11,"bvs","","",20],[11,"margin","","",20],[11,"vertices","","",20],[11,"indices","","",20],[11,"uvs","","",20],[11,"normals","","",20],[1,"Segment","","A segment geometry."],[11,"margin","","",21],[11,"a","","",21],[11,"b","","",21],[1,"Triangle","","A triangle geometry."],[11,"margin","","",22],[11,"a","","",22],[11,"b","","",22],[11,"c","","",22],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",23],[11,"nupoints","","",23],[11,"nvpoints","","",23],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",24],[11,"v_cache","","",24],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",25],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",26],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",27],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",27],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",28],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",29],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",29],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",29],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",29],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",29],[0,"ray","ncollide4df64","Ray casting utilities."],[1,"Ray","ncollide4df64::ray","A Ray."],[11,"orig","","Starting point of the ray.",30],[11,"dir","","Direction of the ray.",30],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",31],[11,"normal","","The normal at the intersection point.",31],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",32],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",32],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",32],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",32],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",32],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",32],[0,"narrow","ncollide4df64","Narrow phases."],[1,"Contact","ncollide4df64::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",33],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",33],[11,"normal","","Contact normal",33],[11,"depth","","Penetration depth",33],[1,"Empty","","A collision detector that does nothing."],[11,"dummy","","",34],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",35],[11,"contact","","",35],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",36],[11,"contact","","",36],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",37],[11,"contact","","",37],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",38],[11,"prediction","","",38],[11,"contact","","",38],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",39],[11,"collector","","",39],[11,"prediction","","",39],[11,"sub_detector","","",39],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",40],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",41],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",42],[11,"to_delete","","",42],[11,"interferences","","",42],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",43],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",44],[11,"tree","","",44],[11,"selector","","",44],[11,"prediction","","",44],[11,"contacts","","",44],[11,"points","","",44],[11,"timestamp","","",44],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",45],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[11,"cache","","",46],[11,"tree","","",46],[11,"selector","","",46],[11,"prediction","","",46],[11,"contacts","","",46],[11,"points","","",46],[11,"timestamp","","",46],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide4df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide4df64::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide4df64::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide4df64::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide4df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide4df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide4df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide4df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",47],[9,"translate_by","","Translates each point of this simplex.",47],[9,"add_point","","Adds a point to the simplex.",47],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",47],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",47],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",47],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",47],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",47],[0,"johnson_simplex","ncollide4df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide4df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",48],[11,"points","","",48],[11,"exchange_points","","",48],[11,"determinants","","",48],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",49],[11,"offsets","","",49],[11,"sub_determinants","","",49],[11,"num_determinants","","",49],[11,"num_leaves","","",49],[10,"clone","","",48],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",49],[10,"new","","Creates a new, empty, Johnson simplex.",48],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",48],[10,"reset","","",48],[10,"dimension","","",48],[10,"max_sq_len","","",48],[10,"contains_point","","",48],[10,"add_point","","",48],[10,"project_origin_and_reduce","","",48],[10,"project_origin","","",48],[10,"translate_by","","",48],[0,"gjk","ncollide4df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide4df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",50],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",50],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",50],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",50],[10,"decode","","",50],[10,"encode","","",50],[0,"minkowski_sampling","ncollide4df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide4df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide4df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide4df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",51],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",52],[11,"diff_v","","",52],[11,"max_lmd","","",52],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",53],[11,"spread_u","","",53],[11,"spread_v","","",53],[11,"axis_u","","",53],[11,"axis_v","","",53],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",54],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",54],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",54],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",54],[10,"clone","","",55],[10,"new","","Creates a new `YesSirSurfaceSelector`.",55],[10,"set_max_lmd","","",55],[10,"is_flat","","",55],[10,"may_contain_a_closest_point","","",55],[10,"create_test_data","","",55],[10,"clone","","",51],[10,"new","","Creates a new hyperplane-based surface selector.",51],[10,"set_max_lmd","","",51],[10,"is_flat","","",51],[10,"may_contain_a_closest_point","","",51],[10,"create_test_data","","",51],[10,"clone","","",52],[10,"new","","Creates a new tangent-cone based surface detector.",52],[10,"set_max_lmd","","",52],[10,"is_flat","","",52],[10,"may_contain_a_closest_point","","",52],[10,"create_test_data","","",52],[0,"surface_subdivision_tree","ncollide4df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide4df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",56],[11,"value","","",56],[11,"key","","",56],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",57],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",58],[11,"lchild","","",58],[11,"timestamp","","",58],[11,"data","","",58],[11,"surface","","",58],[10,"clone","","",56],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",56],[10,"deref","","",56],[10,"drop","","",56],[10,"new","","Creates a new surface subdivision tree cache.",57],[10,"clear","","Removes everything from this cache.",57],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",57],[10,"new_orphan","","Creates a new tree with no parent nor children.",58],[10,"surface","","The surface contained by this node.",58],[10,"data","","Reference to the data contained by this node.",58],[10,"data_mut","","Mutable reference to the data contained by this node.",58],[10,"timestamp","","The timestamp of this tree node.",58],[10,"set_timestamp","","Sets the timestamp of this tree node.",58],[10,"has_left_child","","Whether or not this node has a left child.",58],[10,"has_right_child","","Whether or not this node has a right child.",58],[10,"right_child","","A copy of this node right child.",58],[10,"left_child","","A copy of this node left child.",58],[10,"right_child_ref","","A reference to this node right child.",58],[10,"left_child_ref","","A reference to this node left child.",58],[10,"set_right_child","","Sets the right child of this node.",58],[10,"set_left_child","","Sets the left child of this node.",58],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",58],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",58],[10,"remove_right_child","","Removes the right child of this node.",58],[10,"remove_left_child","","Removes the left child of this node.",58],[6,"CollisionDetector","ncollide4df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",59],[9,"num_colls","","The number of collision detected during the last update.",59],[9,"colls","","Collects the collisions detected during the last update.",59],[9,"toi","","Computes the time of impact of two objects.",59],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",60],[9,"num_colls","","The number of collision detected during the last update.",60],[9,"colls","","Collects the collisions detected during the last update.",60],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",61],[0,"broad","ncollide4df64","Broad phases."],[1,"NoIdDispatcher","ncollide4df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[11,"dispatcher","","",62],[11,"pairs","","",62],[11,"objects","","",62],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",63],[11,"sobjects","","",63],[11,"rb2bv","","",63],[11,"pairs","","",63],[11,"dispatcher","","",63],[11,"margin","","",63],[11,"to_update","","",63],[11,"update_off","","",63],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",64],[11,"stree","","",64],[11,"active2bv","","",64],[11,"inactive2bv","","",64],[11,"pairs","","",64],[11,"spairs","","",64],[11,"dispatcher","","",64],[11,"margin","","",64],[11,"collector","","",64],[11,"to_update","","",64],[11,"update_off","","",64],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",65],[9,"remove","","Removes an element from this broad phase.",65],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",65],[9,"update_object","","Updates the collision pairs involving one specific object.",65],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",66],[9,"deactivate","","Marks and object as inactive.",66],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",66],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",66],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",67],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",68],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",69],[9,"is_valid","","Tells whether a collision between two bodies can occur.",69],[0,"volumetric","ncollide4df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide4df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide4df64::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",70],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",70],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",70],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",71],[0,"implicit","ncollide4df64","Definition of support functions."],[3,"cso_support_point","ncollide4df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",73],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",74],[0,"partitioning","ncollide4df64","Spatial partitioning tools."],[1,"DBVT","ncollide4df64::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",75],[11,"tree","","",75],[11,"len","","",75],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",76],[11,"center","","The center of this node bounding volume.",76],[11,"object","","An user-defined object.",76],[11,"parent","","This node parent.",76],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",77],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",78],[11,"collector","","",78],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",79],[11,"collector","","",79],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",80],[12,"LeftChildOf","","This leaf is the left child of another node.",80],[12,"Detached","","This leaf is detached from any tree.",80],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",81],[12,"Parts","","Result of the partitioning of several elements.",81],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[9,"visit_leaf","","Visits a leaf.",82],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[10,"visit_leaf_mut","","Visits a leaf.",82],[0,"procedural","ncollide4df64","Procedural mesh generation."],[1,"TriMesh","ncollide4df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",83],[11,"normals","","Coordinates of the mesh normals.",83],[11,"uvs","","Textures coordinates of the mesh.",83],[11,"indices","","Index buffer of the mesh.",83],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",84],[11,"normals","","Coordinates of the polyline normals.",84],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",85],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",85],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide4df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide4df64::procedural","Path generation."],[1,"PolylinePattern","ncollide4df64::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",86],[11,"closed","","",86],[11,"last_start_id","","",86],[11,"start_cap","","",86],[11,"end_cap","","",86],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",87],[11,"curr_dir","","",87],[11,"curr_pt_id","","",87],[11,"curr_pt","","",87],[11,"polyline","","",87],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",88],[11,"front_dist_to_head","","",88],[11,"back_dist_to_head","","",88],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",89],[12,"InnerPoint","","A point that is inside of the path currently generated.",89],[12,"EndPoint","","A point that ends the path currently generated.",89],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",89],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",90],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",91],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",92],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",92],[6,"ToTriMesh","ncollide4df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",93],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",94],[0,"utils","ncollide4df64","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide4df64::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide4df64","Data structure utilities."],[0,"pair","ncollide4df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide4df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",95],[11,"second","","second object of the pair",95],[11,"ifirst","","",95],[11,"isecond","","",95],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",96],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Builds a new `Pair`.",95],[10,"eq","","",95],[10,"decode","","",96],[10,"encode","","",96],[10,"new","","Creates a new PairTWHash",96],[10,"hash","","",96],[0,"hash","ncollide4df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide4df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",97],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",98],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",99],[10,"decode","","",97],[10,"encode","","",97],[10,"clone","","",97],[10,"new","","Creates a new UintPairTWHash.",97],[10,"hash","","",97],[10,"decode","","",98],[10,"encode","","",98],[10,"clone","","",98],[10,"new","","Creates a new UintTWHash.",98],[10,"hash","","",98],[0,"hash_map","ncollide4df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide4df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",100],[11,"value","","The value of the entry.",100],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",101],[11,"table","","",101],[11,"mask","","",101],[11,"htable","","",101],[11,"next","","",101],[11,"num_elem","","",101],[11,"max_elem","","",101],[11,"real_max_elem","","",101],[10,"decode","","",100],[10,"encode","","",100],[10,"clone","","",100],[10,"decode","","",101],[10,"encode","","",101],[10,"clone","","",101],[10,"new","","Creates a new hash map.",101],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",101],[10,"elements","","The elements added to this hash map.",101],[10,"elements_mut","","The elements added to this hash map.",101],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",101],[10,"get_and_remove","","Removes an element and returns its value if it existed.",101],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",101],[10,"insert_or_replace","","Inserts or replace an element.",101],[10,"len","","",101],[10,"clear","","",101],[10,"contains_key","","",101],[10,"find","","",101],[10,"insert","","Inserts an element on the hash map.",101],[10,"remove","","Remove an element from the hash map.",101],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",101],[0,"owned_allocation_cache","ncollide4df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide4df64::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",102],[10,"new","","Initializes the cache.",102],[10,"alloc","","Box a value into a potentially already allocated box.",102],[10,"retain","","Retains a box which can be re-used by the `box` method.",102],[10,"clear","","Clears the cache, destroying any stored pointer.",102],[0,"has_uid","ncollide4df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide4df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",103],[10,"uid","std::gc","",104],[10,"uid","alloc::rc","",105],[10,"uid","alloc::arc","",106],[0,"vec_slice","ncollide4df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide4df64::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",107],[11,"length","","",107],[11,"stride","","",107],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",108],[11,"length","","",108],[11,"stride","","",108],[10,"len","","",107],[10,"is_empty","","",107],[10,"len","","",108],[10,"is_empty","","",108],[10,"new","","Creates a new immutable slice.",107],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",107],[10,"get","","Gets the i-th element of the slice.",107],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",107],[10,"new","","Creates a new mutable slice.",108],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",108],[10,"as_slice","","Creates an immutable slice from this mutable slice.",108],[10,"get","","Gets the i-th element of the slice.",108],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",108],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",108],[0,"math","ncollide4df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide4df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",109],[10,"to_world_space","","",109],[10,"to_relative_wrt_point","","",109]],"paths":[[1,"AABB"],[1,"BoundingSphere"],[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"CompoundData"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[1,"BezierSurfaceBezierSurface"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['ncollide3df64'] = {"items":[[0,"","ncollide3df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide3df64::bounding_volume","An Axis Aligned Bounding Box."],[11,"mins","","",0],[11,"maxs","","",0],[1,"BoundingSphere","","A Bounding Sphere."],[11,"center","","",1],[11,"radius","","",1],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",2],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",3],[9,"contains","","Checks if this bounding volume contains another one.",3],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",3],[9,"merged","","Merges this bounding volume with another one.",3],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",4],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",4],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",5],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",6],[0,"geom","ncollide3df64","Geometric primitives."],[1,"Ball","ncollide3df64::geom","A Ball geometry."],[11,"radius","","",7],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",8],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",9],[11,"margin","","",9],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",10],[11,"radius","","",10],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",11],[11,"radius","","",11],[11,"margin","","",11],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",12],[11,"radius","","",12],[11,"margin","","",12],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",13],[11,"margin","","",13],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",14],[11,"g1","","",14],[11,"m2","","",14],[11,"g2","","",14],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",15],[11,"g1","","",15],[11,"m2","","",15],[11,"g2","","",15],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"geom","","",16],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"mass","","",17],[11,"inertia","","",17],[11,"com","","",17],[11,"geoms","","",17],[11,"bvt","","",17],[11,"bvs","","",17],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[11,"geoms","","",18],[11,"props","","",18],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",19],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",20],[11,"bvs","","",20],[11,"margin","","",20],[11,"vertices","","",20],[11,"indices","","",20],[11,"uvs","","",20],[11,"normals","","",20],[1,"Segment","","A segment geometry."],[11,"margin","","",21],[11,"a","","",21],[11,"b","","",21],[1,"Triangle","","A triangle geometry."],[11,"margin","","",22],[11,"a","","",22],[11,"b","","",22],[11,"c","","",22],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",23],[11,"nupoints","","",23],[11,"nvpoints","","",23],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",24],[11,"v_cache","","",24],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",25],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",26],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",27],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",27],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",28],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",29],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",29],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",29],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",29],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",29],[0,"ray","ncollide3df64","Ray casting utilities."],[1,"Ray","ncollide3df64::ray","A Ray."],[11,"orig","","Starting point of the ray.",30],[11,"dir","","Direction of the ray.",30],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",31],[11,"normal","","The normal at the intersection point.",31],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",31],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",32],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",32],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",32],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",32],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",32],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",32],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",32],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",32],[0,"narrow","ncollide3df64","Narrow phases."],[1,"Contact","ncollide3df64::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",33],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",33],[11,"normal","","Contact normal",33],[11,"depth","","Penetration depth",33],[1,"Empty","","A collision detector that does nothing."],[11,"dummy","","",34],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",35],[11,"contact","","",35],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",36],[11,"contact","","",36],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",37],[11,"contact","","",37],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",38],[11,"prediction","","",38],[11,"contact","","",38],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",39],[11,"collector","","",39],[11,"prediction","","",39],[11,"sub_detector","","",39],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",40],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",41],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",42],[11,"to_delete","","",42],[11,"interferences","","",42],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",43],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",44],[11,"tree","","",44],[11,"selector","","",44],[11,"prediction","","",44],[11,"contacts","","",44],[11,"points","","",44],[11,"timestamp","","",44],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",45],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[11,"cache","","",46],[11,"tree","","",46],[11,"selector","","",46],[11,"prediction","","",46],[11,"contacts","","",46],[11,"points","","",46],[11,"timestamp","","",46],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide3df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide3df64::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide3df64::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide3df64::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide3df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide3df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide3df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide3df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",47],[9,"translate_by","","Translates each point of this simplex.",47],[9,"add_point","","Adds a point to the simplex.",47],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",47],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",47],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",47],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",47],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",47],[0,"johnson_simplex","ncollide3df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide3df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",48],[11,"points","","",48],[11,"exchange_points","","",48],[11,"determinants","","",48],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",49],[11,"offsets","","",49],[11,"sub_determinants","","",49],[11,"num_determinants","","",49],[11,"num_leaves","","",49],[10,"clone","","",48],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",49],[10,"new","","Creates a new, empty, Johnson simplex.",48],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",48],[10,"reset","","",48],[10,"dimension","","",48],[10,"max_sq_len","","",48],[10,"contains_point","","",48],[10,"add_point","","",48],[10,"project_origin_and_reduce","","",48],[10,"project_origin","","",48],[10,"translate_by","","",48],[0,"gjk","ncollide3df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide3df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",50],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",50],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",50],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",50],[10,"decode","","",50],[10,"encode","","",50],[0,"minkowski_sampling","ncollide3df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide3df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide3df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide3df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",51],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",52],[11,"diff_v","","",52],[11,"max_lmd","","",52],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",53],[11,"spread_u","","",53],[11,"spread_v","","",53],[11,"axis_u","","",53],[11,"axis_v","","",53],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",54],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",54],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",54],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",54],[10,"clone","","",55],[10,"new","","Creates a new `YesSirSurfaceSelector`.",55],[10,"set_max_lmd","","",55],[10,"is_flat","","",55],[10,"may_contain_a_closest_point","","",55],[10,"create_test_data","","",55],[10,"clone","","",51],[10,"new","","Creates a new hyperplane-based surface selector.",51],[10,"set_max_lmd","","",51],[10,"is_flat","","",51],[10,"may_contain_a_closest_point","","",51],[10,"create_test_data","","",51],[10,"clone","","",52],[10,"new","","Creates a new tangent-cone based surface detector.",52],[10,"set_max_lmd","","",52],[10,"is_flat","","",52],[10,"may_contain_a_closest_point","","",52],[10,"create_test_data","","",52],[0,"surface_subdivision_tree","ncollide3df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide3df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",56],[11,"value","","",56],[11,"key","","",56],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",57],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",58],[11,"lchild","","",58],[11,"timestamp","","",58],[11,"data","","",58],[11,"surface","","",58],[10,"clone","","",56],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",56],[10,"deref","","",56],[10,"drop","","",56],[10,"new","","Creates a new surface subdivision tree cache.",57],[10,"clear","","Removes everything from this cache.",57],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",57],[10,"new_orphan","","Creates a new tree with no parent nor children.",58],[10,"surface","","The surface contained by this node.",58],[10,"data","","Reference to the data contained by this node.",58],[10,"data_mut","","Mutable reference to the data contained by this node.",58],[10,"timestamp","","The timestamp of this tree node.",58],[10,"set_timestamp","","Sets the timestamp of this tree node.",58],[10,"has_left_child","","Whether or not this node has a left child.",58],[10,"has_right_child","","Whether or not this node has a right child.",58],[10,"right_child","","A copy of this node right child.",58],[10,"left_child","","A copy of this node left child.",58],[10,"right_child_ref","","A reference to this node right child.",58],[10,"left_child_ref","","A reference to this node left child.",58],[10,"set_right_child","","Sets the right child of this node.",58],[10,"set_left_child","","Sets the left child of this node.",58],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",58],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",58],[10,"remove_right_child","","Removes the right child of this node.",58],[10,"remove_left_child","","Removes the left child of this node.",58],[6,"CollisionDetector","ncollide3df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",59],[9,"num_colls","","The number of collision detected during the last update.",59],[9,"colls","","Collects the collisions detected during the last update.",59],[9,"toi","","Computes the time of impact of two objects.",59],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",60],[9,"num_colls","","The number of collision detected during the last update.",60],[9,"colls","","Collects the collisions detected during the last update.",60],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",61],[0,"broad","ncollide3df64","Broad phases."],[1,"NoIdDispatcher","ncollide3df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[11,"dispatcher","","",62],[11,"pairs","","",62],[11,"objects","","",62],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",63],[11,"sobjects","","",63],[11,"rb2bv","","",63],[11,"pairs","","",63],[11,"dispatcher","","",63],[11,"margin","","",63],[11,"to_update","","",63],[11,"update_off","","",63],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",64],[11,"stree","","",64],[11,"active2bv","","",64],[11,"inactive2bv","","",64],[11,"pairs","","",64],[11,"spairs","","",64],[11,"dispatcher","","",64],[11,"margin","","",64],[11,"collector","","",64],[11,"to_update","","",64],[11,"update_off","","",64],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",65],[9,"remove","","Removes an element from this broad phase.",65],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",65],[9,"update_object","","Updates the collision pairs involving one specific object.",65],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",66],[9,"deactivate","","Marks and object as inactive.",66],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",66],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",66],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",67],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",68],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",69],[9,"is_valid","","Tells whether a collision between two bodies can occur.",69],[0,"volumetric","ncollide3df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide3df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide3df64::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",70],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",70],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",70],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",71],[0,"implicit","ncollide3df64","Definition of support functions."],[3,"cso_support_point","ncollide3df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",73],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",74],[0,"partitioning","ncollide3df64","Spatial partitioning tools."],[1,"DBVT","ncollide3df64::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",75],[11,"tree","","",75],[11,"len","","",75],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",76],[11,"center","","The center of this node bounding volume.",76],[11,"object","","An user-defined object.",76],[11,"parent","","This node parent.",76],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",77],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",78],[11,"collector","","",78],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",79],[11,"collector","","",79],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",80],[12,"LeftChildOf","","This leaf is the left child of another node.",80],[12,"Detached","","This leaf is detached from any tree.",80],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",81],[12,"Parts","","Result of the partitioning of several elements.",81],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[9,"visit_leaf","","Visits a leaf.",82],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[10,"visit_leaf_mut","","Visits a leaf.",82],[0,"procedural","ncollide3df64","Procedural mesh generation."],[1,"TriMesh","ncollide3df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",83],[11,"normals","","Coordinates of the mesh normals.",83],[11,"uvs","","Textures coordinates of the mesh.",83],[11,"indices","","Index buffer of the mesh.",83],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",84],[11,"normals","","Coordinates of the polyline normals.",84],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",85],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",85],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide3df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide3df64::procedural","Path generation."],[1,"PolylinePattern","ncollide3df64::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",86],[11,"closed","","",86],[11,"last_start_id","","",86],[11,"start_cap","","",86],[11,"end_cap","","",86],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",87],[11,"curr_dir","","",87],[11,"curr_pt_id","","",87],[11,"curr_pt","","",87],[11,"polyline","","",87],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",88],[11,"front_dist_to_head","","",88],[11,"back_dist_to_head","","",88],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",89],[12,"InnerPoint","","A point that is inside of the path currently generated.",89],[12,"EndPoint","","A point that ends the path currently generated.",89],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",89],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",90],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",91],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",92],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",92],[6,"ToTriMesh","ncollide3df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",93],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",94],[0,"utils","ncollide3df64","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide3df64::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide3df64","Data structure utilities."],[0,"pair","ncollide3df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide3df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",95],[11,"second","","second object of the pair",95],[11,"ifirst","","",95],[11,"isecond","","",95],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",96],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Builds a new `Pair`.",95],[10,"eq","","",95],[10,"decode","","",96],[10,"encode","","",96],[10,"new","","Creates a new PairTWHash",96],[10,"hash","","",96],[0,"hash","ncollide3df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide3df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",97],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",98],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",99],[10,"decode","","",97],[10,"encode","","",97],[10,"clone","","",97],[10,"new","","Creates a new UintPairTWHash.",97],[10,"hash","","",97],[10,"decode","","",98],[10,"encode","","",98],[10,"clone","","",98],[10,"new","","Creates a new UintTWHash.",98],[10,"hash","","",98],[0,"hash_map","ncollide3df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide3df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",100],[11,"value","","The value of the entry.",100],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",101],[11,"table","","",101],[11,"mask","","",101],[11,"htable","","",101],[11,"next","","",101],[11,"num_elem","","",101],[11,"max_elem","","",101],[11,"real_max_elem","","",101],[10,"decode","","",100],[10,"encode","","",100],[10,"clone","","",100],[10,"decode","","",101],[10,"encode","","",101],[10,"clone","","",101],[10,"new","","Creates a new hash map.",101],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",101],[10,"elements","","The elements added to this hash map.",101],[10,"elements_mut","","The elements added to this hash map.",101],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",101],[10,"get_and_remove","","Removes an element and returns its value if it existed.",101],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",101],[10,"insert_or_replace","","Inserts or replace an element.",101],[10,"len","","",101],[10,"clear","","",101],[10,"contains_key","","",101],[10,"find","","",101],[10,"insert","","Inserts an element on the hash map.",101],[10,"remove","","Remove an element from the hash map.",101],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",101],[0,"owned_allocation_cache","ncollide3df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide3df64::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",102],[10,"new","","Initializes the cache.",102],[10,"alloc","","Box a value into a potentially already allocated box.",102],[10,"retain","","Retains a box which can be re-used by the `box` method.",102],[10,"clear","","Clears the cache, destroying any stored pointer.",102],[0,"has_uid","ncollide3df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide3df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",103],[10,"uid","std::gc","",104],[10,"uid","alloc::rc","",105],[10,"uid","alloc::arc","",106],[0,"vec_slice","ncollide3df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide3df64::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",107],[11,"length","","",107],[11,"stride","","",107],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",108],[11,"length","","",108],[11,"stride","","",108],[10,"len","","",107],[10,"is_empty","","",107],[10,"len","","",108],[10,"is_empty","","",108],[10,"new","","Creates a new immutable slice.",107],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",107],[10,"get","","Gets the i-th element of the slice.",107],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",107],[10,"new","","Creates a new mutable slice.",108],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",108],[10,"as_slice","","Creates an immutable slice from this mutable slice.",108],[10,"get","","Gets the i-th element of the slice.",108],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",108],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",108],[0,"math","ncollide3df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide3df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",109],[10,"to_world_space","","",109],[10,"to_relative_wrt_point","","",109]],"paths":[[1,"AABB"],[1,"BoundingSphere"],[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"CompoundData"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[1,"BezierSurfaceBezierSurface"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

searchIndex['ncollide2df64'] = {"items":[[0,"","ncollide2df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"AABB","ncollide2df64::bounding_volume","An Axis Aligned Bounding Box."],[11,"mins","","",0],[11,"maxs","","",0],[1,"BoundingSphere","","A Bounding Sphere."],[11,"center","","",1],[11,"radius","","",1],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",2],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",3],[9,"contains","","Checks if this bounding volume contains another one.",3],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",3],[9,"merged","","Merges this bounding volume with another one.",3],[6,"LooseBoundingVolume","","Trait of loose bounding volume."],[9,"loosen","","Enlarges this bounding volume.",4],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",4],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",5],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",6],[0,"geom","ncollide2df64","Geometric primitives."],[1,"Ball","ncollide2df64::geom","A Ball geometry."],[11,"radius","","",7],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",8],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",9],[11,"margin","","",9],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",10],[11,"radius","","",10],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",11],[11,"radius","","",11],[11,"margin","","",11],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `y` axis."],[11,"half_height","","",12],[11,"radius","","",12],[11,"margin","","",12],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",13],[11,"margin","","",13],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",14],[11,"g1","","",14],[11,"m2","","",14],[11,"g2","","",14],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",15],[11,"g1","","",15],[11,"m2","","",15],[11,"g2","","",15],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"geom","","",16],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"mass","","",17],[11,"inertia","","",17],[11,"com","","",17],[11,"geoms","","",17],[11,"bvt","","",17],[11,"bvs","","",17],[1,"CompoundData","","Structure used to build a `Compound` geometry."],[11,"geoms","","",18],[11,"props","","",18],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",19],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",20],[11,"bvs","","",20],[11,"margin","","",20],[11,"vertices","","",20],[11,"indices","","",20],[11,"uvs","","",20],[11,"normals","","",20],[1,"Segment","","A segment geometry."],[11,"margin","","",21],[11,"a","","",21],[11,"b","","",21],[1,"Triangle","","A triangle geometry."],[11,"margin","","",22],[11,"a","","",22],[11,"b","","",22],[11,"c","","",22],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",23],[11,"nupoints","","",23],[11,"nvpoints","","",23],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",24],[11,"v_cache","","",24],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",25],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",26],[4,"MeshPrimitive","","The primitive geometry used by a `Mesh`."],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",27],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",27],[6,"Geom","","Trait (that should be) implemented by every geometry."],[9,"duplicate","","Duplicates (clones) this geometry.",28],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",29],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",29],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",29],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",29],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",29],[0,"ray","ncollide2df64","Ray casting utilities."],[1,"Ray","ncollide2df64::ray","A Ray."],[11,"orig","","Starting point of the ray.",30],[11,"dir","","Direction of the ray.",30],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",31],[11,"normal","","The normal at the intersection point.",31],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",32],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",32],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",32],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",32],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",32],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",32],[0,"narrow","ncollide2df64","Narrow phases."],[1,"Contact","ncollide2df64::narrow","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",33],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",33],[11,"normal","","Contact normal",33],[11,"depth","","Penetration depth",33],[1,"Empty","","A collision detector that does nothing."],[11,"dummy","","",34],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",35],[11,"contact","","",35],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",36],[11,"contact","","",36],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",37],[11,"contact","","",37],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",38],[11,"prediction","","",38],[11,"contact","","",38],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",39],[11,"collector","","",39],[11,"prediction","","",39],[11,"sub_detector","","",39],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",40],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",41],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",42],[11,"to_delete","","",42],[11,"interferences","","",42],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",43],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",44],[11,"tree","","",44],[11,"selector","","",44],[11,"prediction","","",44],[11,"contacts","","",44],[11,"points","","",44],[11,"timestamp","","",44],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",45],[1,"BezierSurfaceBezierSurface","","A collision detector between two bézier surfaces."],[11,"cache","","",46],[11,"tree","","",46],[11,"selector","","",46],[11,"prediction","","",46],[11,"contacts","","",46],[11,"points","","",46],[11,"timestamp","","",46],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide2df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi_and_normal","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide2df64::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide2df64::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide2df64::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide2df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide2df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide2df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide2df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",47],[9,"translate_by","","Translates each point of this simplex.",47],[9,"add_point","","Adds a point to the simplex.",47],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",47],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",47],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",47],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",47],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",47],[0,"johnson_simplex","ncollide2df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide2df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",48],[11,"points","","",48],[11,"exchange_points","","",48],[11,"determinants","","",48],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",49],[11,"offsets","","",49],[11,"sub_determinants","","",49],[11,"num_determinants","","",49],[11,"num_leaves","","",49],[10,"clone","","",48],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",49],[10,"new","","Creates a new, empty, Johnson simplex.",48],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",48],[10,"reset","","",48],[10,"dimension","","",48],[10,"max_sq_len","","",48],[10,"contains_point","","",48],[10,"add_point","","",48],[10,"project_origin_and_reduce","","",48],[10,"project_origin","","",48],[10,"translate_by","","",48],[0,"gjk","ncollide2df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide2df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",50],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",50],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",50],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",50],[10,"decode","","",50],[10,"encode","","",50],[0,"minkowski_sampling","ncollide2df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide2df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide2df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide2df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",51],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",52],[11,"diff_v","","",52],[11,"max_lmd","","",52],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",53],[11,"spread_u","","",53],[11,"spread_v","","",53],[11,"axis_u","","",53],[11,"axis_v","","",53],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",54],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",54],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",54],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",54],[10,"clone","","",55],[10,"new","","Creates a new `YesSirSurfaceSelector`.",55],[10,"set_max_lmd","","",55],[10,"is_flat","","",55],[10,"may_contain_a_closest_point","","",55],[10,"create_test_data","","",55],[10,"clone","","",51],[10,"new","","Creates a new hyperplane-based surface selector.",51],[10,"set_max_lmd","","",51],[10,"is_flat","","",51],[10,"may_contain_a_closest_point","","",51],[10,"create_test_data","","",51],[10,"clone","","",52],[10,"new","","Creates a new tangent-cone based surface detector.",52],[10,"set_max_lmd","","",52],[10,"is_flat","","",52],[10,"may_contain_a_closest_point","","",52],[10,"create_test_data","","",52],[0,"surface_subdivision_tree","ncollide2df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide2df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",56],[11,"value","","",56],[11,"key","","",56],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",57],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",58],[11,"lchild","","",58],[11,"timestamp","","",58],[11,"data","","",58],[11,"surface","","",58],[10,"clone","","",56],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",56],[10,"deref","","",56],[10,"drop","","",56],[10,"new","","Creates a new surface subdivision tree cache.",57],[10,"clear","","Removes everything from this cache.",57],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",57],[10,"new_orphan","","Creates a new tree with no parent nor children.",58],[10,"surface","","The surface contained by this node.",58],[10,"data","","Reference to the data contained by this node.",58],[10,"data_mut","","Mutable reference to the data contained by this node.",58],[10,"timestamp","","The timestamp of this tree node.",58],[10,"set_timestamp","","Sets the timestamp of this tree node.",58],[10,"has_left_child","","Whether or not this node has a left child.",58],[10,"has_right_child","","Whether or not this node has a right child.",58],[10,"right_child","","A copy of this node right child.",58],[10,"left_child","","A copy of this node left child.",58],[10,"right_child_ref","","A reference to this node right child.",58],[10,"left_child_ref","","A reference to this node left child.",58],[10,"set_right_child","","Sets the right child of this node.",58],[10,"set_left_child","","Sets the left child of this node.",58],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",58],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",58],[10,"remove_right_child","","Removes the right child of this node.",58],[10,"remove_left_child","","Removes the left child of this node.",58],[6,"CollisionDetector","ncollide2df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",59],[9,"num_colls","","The number of collision detected during the last update.",59],[9,"colls","","Collects the collisions detected during the last update.",59],[9,"toi","","Computes the time of impact of two objects.",59],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",60],[9,"num_colls","","The number of collision detected during the last update.",60],[9,"colls","","Collects the collisions detected during the last update.",60],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",61],[0,"broad","ncollide2df64","Broad phases."],[1,"NoIdDispatcher","ncollide2df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","Broad phase with quadratic complexity."],[11,"dispatcher","","",62],[11,"pairs","","",62],[11,"objects","","",62],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",63],[11,"sobjects","","",63],[11,"rb2bv","","",63],[11,"pairs","","",63],[11,"dispatcher","","",63],[11,"margin","","",63],[11,"to_update","","",63],[11,"update_off","","",63],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",64],[11,"stree","","",64],[11,"active2bv","","",64],[11,"inactive2bv","","",64],[11,"pairs","","",64],[11,"spairs","","",64],[11,"dispatcher","","",64],[11,"margin","","",64],[11,"collector","","",64],[11,"to_update","","",64],[11,"update_off","","",64],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",65],[9,"remove","","Removes an element from this broad phase.",65],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",65],[9,"update_object","","Updates the collision pairs involving one specific object.",65],[6,"InterferencesBroadPhase","","Thait of broad phases which check for pairwise interferences."],[9,"activate","","Marks and object as active.",66],[9,"deactivate","","Marks and object as inactive.",66],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",66],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",66],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",67],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",68],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",69],[9,"is_valid","","Tells whether a collision between two bodies can occur.",69],[0,"volumetric","ncollide2df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide2df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[0,"volumetric","","Traits to compute inertial properties."],[6,"InertiaTensor","ncollide2df64::volumetric::volumetric","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",70],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",70],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",70],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",71],[0,"implicit","ncollide2df64","Definition of support functions."],[3,"cso_support_point","ncollide2df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",72],[6,"HasMargin","","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",73],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",74],[0,"partitioning","ncollide2df64","Spatial partitioning tools."],[1,"DBVT","ncollide2df64::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",75],[11,"tree","","",75],[11,"len","","",75],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",76],[11,"center","","The center of this node bounding volume.",76],[11,"object","","An user-defined object.",76],[11,"parent","","This node parent.",76],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",77],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",78],[11,"collector","","",78],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",79],[11,"collector","","",79],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",80],[12,"LeftChildOf","","This leaf is the left child of another node.",80],[12,"Detached","","This leaf is detached from any tree.",80],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",81],[12,"Parts","","Result of the partitioning of several elements.",81],[3,"kdtree_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[9,"visit_leaf","","Visits a leaf.",82],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",82],[10,"visit_leaf_mut","","Visits a leaf.",82],[0,"procedural","ncollide2df64","Procedural mesh generation."],[1,"TriMesh","ncollide2df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",83],[11,"normals","","Coordinates of the mesh normals.",83],[11,"uvs","","Textures coordinates of the mesh.",83],[11,"indices","","Index buffer of the mesh.",83],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",84],[11,"normals","","Coordinates of the polyline normals.",84],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",85],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",85],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid geometry with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide2df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide2df64::procedural","Path generation."],[1,"PolylinePattern","ncollide2df64::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",86],[11,"closed","","",86],[11,"last_start_id","","",86],[11,"start_cap","","",86],[11,"end_cap","","",86],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",87],[11,"curr_dir","","",87],[11,"curr_pt_id","","",87],[11,"curr_pt","","",87],[11,"polyline","","",87],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",88],[11,"front_dist_to_head","","",88],[11,"back_dist_to_head","","",88],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",89],[12,"InnerPoint","","A point that is inside of the path currently generated.",89],[12,"EndPoint","","A point that ends the path currently generated.",89],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",89],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",90],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",91],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",92],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",92],[6,"ToTriMesh","ncollide2df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",93],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",94],[0,"utils","ncollide2df64","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide2df64::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide2df64","Data structure utilities."],[0,"pair","ncollide2df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide2df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",95],[11,"second","","second object of the pair",95],[11,"ifirst","","",95],[11,"isecond","","",95],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",96],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Builds a new `Pair`.",95],[10,"eq","","",95],[10,"decode","","",96],[10,"encode","","",96],[10,"new","","Creates a new PairTWHash",96],[10,"hash","","",96],[0,"hash","ncollide2df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide2df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",97],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",98],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",99],[10,"decode","","",97],[10,"encode","","",97],[10,"clone","","",97],[10,"new","","Creates a new UintPairTWHash.",97],[10,"hash","","",97],[10,"decode","","",98],[10,"encode","","",98],[10,"clone","","",98],[10,"new","","Creates a new UintTWHash.",98],[10,"hash","","",98],[0,"hash_map","ncollide2df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide2df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",100],[11,"value","","The value of the entry.",100],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",101],[11,"table","","",101],[11,"mask","","",101],[11,"htable","","",101],[11,"next","","",101],[11,"num_elem","","",101],[11,"max_elem","","",101],[11,"real_max_elem","","",101],[10,"decode","","",100],[10,"encode","","",100],[10,"clone","","",100],[10,"decode","","",101],[10,"encode","","",101],[10,"clone","","",101],[10,"new","","Creates a new hash map.",101],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",101],[10,"elements","","The elements added to this hash map.",101],[10,"elements_mut","","The elements added to this hash map.",101],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",101],[10,"get_and_remove","","Removes an element and returns its value if it existed.",101],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",101],[10,"insert_or_replace","","Inserts or replace an element.",101],[10,"len","","",101],[10,"clear","","",101],[10,"contains_key","","",101],[10,"find","","",101],[10,"insert","","Inserts an element on the hash map.",101],[10,"remove","","Remove an element from the hash map.",101],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",101],[0,"owned_allocation_cache","ncollide2df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide2df64::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",102],[10,"new","","Initializes the cache.",102],[10,"alloc","","Box a value into a potentially already allocated box.",102],[10,"retain","","Retains a box which can be re-used by the `box` method.",102],[10,"clear","","Clears the cache, destroying any stored pointer.",102],[0,"has_uid","ncollide2df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide2df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",103],[10,"uid","std::gc","",104],[10,"uid","alloc::rc","",105],[10,"uid","alloc::arc","",106],[0,"vec_slice","ncollide2df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide2df64::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",107],[11,"length","","",107],[11,"stride","","",107],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",108],[11,"length","","",108],[11,"stride","","",108],[10,"len","","",107],[10,"is_empty","","",107],[10,"len","","",108],[10,"is_empty","","",108],[10,"new","","Creates a new immutable slice.",107],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",107],[10,"get","","Gets the i-th element of the slice.",107],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",107],[10,"new","","Creates a new mutable slice.",108],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",108],[10,"as_slice","","Creates an immutable slice from this mutable slice.",108],[10,"get","","Gets the i-th element of the slice.",108],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",108],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",108],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",108],[0,"math","ncollide2df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide2df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."],[10,"apply","","",109],[10,"to_world_space","","",109],[10,"to_relative_wrt_point","","",109]],"paths":[[1,"AABB"],[1,"BoundingSphere"],[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"LooseBoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"CompoundData"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"MeshElement"],[6,"Geom"],[6,"ConcaveGeom"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Contact"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[1,"BezierSurfaceBezierSurface"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[6,"InertiaTensor"],[6,"Volumetric"],[6,"Implicit"],[6,"HasMargin"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"],[4,"AngularInertia"]]};

initSearch(searchIndex);
