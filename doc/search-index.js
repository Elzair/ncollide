var searchIndex = {};
searchIndex['ncollide4df32'] = {"items":[[0,"","ncollide4df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"BoundingSphere","ncollide4df32::bounding_volume","A bounding sphere."],[11,"center","","",0],[11,"radius","","",0],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",1],[0,"geom","ncollide4df32","Geometric primitives."],[1,"Ball","ncollide4df32::geom","A Ball geometry."],[11,"radius","","",2],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",3],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",4],[11,"margin","","",4],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",5],[11,"radius","","",5],[11,"margin","","",5],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",6],[11,"radius","","",6],[11,"margin","","",6],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",7],[11,"radius","","",7],[11,"margin","","",7],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",8],[11,"margin","","",8],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",9],[11,"g1","","",9],[11,"m2","","",9],[11,"g2","","",9],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",10],[11,"g1","","",10],[11,"m2","","",10],[11,"g2","","",10],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"g","","",11],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"shapes","","",12],[11,"bvt","","",12],[11,"bvs","","",12],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",13],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",14],[11,"bvs","","",14],[11,"margin","","",14],[11,"vertices","","",14],[11,"indices","","",14],[11,"uvs","","",14],[11,"normals","","",14],[1,"Segment","","A segment geometry."],[11,"margin","","",15],[11,"a","","",15],[11,"b","","",15],[1,"Triangle","","A triangle geometry."],[11,"margin","","",16],[11,"a","","",16],[11,"b","","",16],[11,"c","","",16],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",17],[11,"nupoints","","",17],[11,"nvpoints","","",17],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",18],[11,"v_cache","","",18],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",19],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",20],[0,"geom","","Enum grouping the most useful geometric shapes."],[6,"Geom","ncollide4df32::geom::geom","Trait (that should be) implemented by each geometry supported by `ncollide`."],[9,"duplicate","","Duplicates (clones) this geometry.",21],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries supported by `ncollide`."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",22],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",22],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",22],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",22],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",22],[4,"MeshPrimitive","ncollide4df32::geom",""],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",23],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",23],[0,"ray","ncollide4df32","Ray casting utilities."],[3,"plane_toi_with_ray","ncollide4df32::ray","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[0,"ray","","Traits and structure needed to cast rays."],[1,"Ray","ncollide4df32::ray::ray","A Ray."],[11,"orig","","Starting point of the ray.",24],[11,"dir","","Direction of the ray.",24],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",25],[11,"normal","","The normal at the intersection point.",25],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",26],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",26],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",26],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",26],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",26],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",26],[10,"decode","","",24],[10,"encode","","",24],[10,"fmt","","",24],[10,"new","","Creates a new ray starting from `orig` and with the direction `dir`. `dir` must be\nnormalized.",24],[10,"new","","Creates a new `RayIntersection`.",25],[0,"narrow","ncollide4df32","Narrow phases."],[1,"Empty","ncollide4df32::narrow","A collision detector that does nothing."],[11,"dummy","","",27],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",28],[11,"contact","","",28],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",29],[11,"contact","","",29],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",30],[11,"contact","","",30],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",31],[11,"prediction","","",31],[11,"contact","","",31],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",32],[11,"collector","","",32],[11,"prediction","","",32],[11,"sub_detector","","",32],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",33],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",34],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",35],[11,"to_delete","","",35],[11,"interferences","","",35],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",36],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",37],[11,"tree","","",37],[11,"selector","","",37],[11,"prediction","","",37],[11,"contacts","","",37],[11,"points","","",37],[11,"timestamp","","",37],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",38],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide4df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide4df32::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide4df32::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide4df32::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide4df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide4df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide4df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide4df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",39],[9,"translate_by","","Translates each point of this simplex.",39],[9,"add_point","","Adds a point to the simplex.",39],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",39],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",39],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",39],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",39],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",39],[0,"johnson_simplex","ncollide4df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide4df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",40],[11,"points","","",40],[11,"exchange_points","","",40],[11,"determinants","","",40],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",41],[11,"offsets","","",41],[11,"sub_determinants","","",41],[11,"num_determinants","","",41],[11,"num_leaves","","",41],[10,"clone","","",40],[10,"decode","","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",41],[10,"new","","Creates a new, empty, Johnson simplex.",40],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",40],[10,"reset","","",40],[10,"dimension","","",40],[10,"max_sq_len","","",40],[10,"contains_point","","",40],[10,"add_point","","",40],[10,"project_origin_and_reduce","","",40],[10,"project_origin","","",40],[10,"translate_by","","",40],[0,"gjk","ncollide4df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide4df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",42],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",42],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",42],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",42],[10,"decode","","",42],[10,"encode","","",42],[0,"minkowski_sampling","ncollide4df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide4df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide4df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide4df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",43],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",44],[11,"diff_v","","",44],[11,"max_lmd","","",44],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",45],[11,"spread_u","","",45],[11,"spread_v","","",45],[11,"axis_u","","",45],[11,"axis_v","","",45],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",46],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",46],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",46],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",46],[10,"clone","","",47],[10,"new","","Creates a new `YesSirSurfaceSelector`.",47],[10,"set_max_lmd","","",47],[10,"is_flat","","",47],[10,"may_contain_a_closest_point","","",47],[10,"create_test_data","","",47],[10,"clone","","",43],[10,"new","","Creates a new hyperplane-based surface selector.",43],[10,"set_max_lmd","","",43],[10,"is_flat","","",43],[10,"may_contain_a_closest_point","","",43],[10,"create_test_data","","",43],[10,"clone","","",44],[10,"new","","Creates a new tangent-cone based surface detector.",44],[10,"set_max_lmd","","",44],[10,"is_flat","","",44],[10,"may_contain_a_closest_point","","",44],[10,"create_test_data","","",44],[0,"surface_subdivision_tree","ncollide4df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide4df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",48],[11,"value","","",48],[11,"key","","",48],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",49],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",50],[11,"lchild","","",50],[11,"timestamp","","",50],[11,"data","","",50],[11,"surface","","",50],[10,"clone","","",48],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",48],[10,"deref","","",48],[10,"drop","","",48],[10,"new","","Creates a new surface subdivision tree cache.",49],[10,"clear","","Removes everything from this cache.",49],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",49],[10,"new_orphan","","Creates a new tree with no parent nor children.",50],[10,"surface","","The surface contained by this node.",50],[10,"data","","Reference to the data contained by this node.",50],[10,"data_mut","","Mutable reference to the data contained by this node.",50],[10,"timestamp","","The timestamp of this tree node.",50],[10,"set_timestamp","","Sets the timestamp of this tree node.",50],[10,"has_left_child","","Whether or not this node has a left child.",50],[10,"has_right_child","","Whether or not this node has a right child.",50],[10,"right_child","","A copy of this node right child.",50],[10,"left_child","","A copy of this node left child.",50],[10,"right_child_ref","","A reference to this node right child.",50],[10,"left_child_ref","","A reference to this node left child.",50],[10,"set_right_child","","Sets the right child of this node.",50],[10,"set_left_child","","Sets the left child of this node.",50],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",50],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",50],[10,"remove_right_child","","Removes the right child of this node.",50],[10,"remove_left_child","","Removes the left child of this node.",50],[6,"CollisionDetector","ncollide4df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",51],[9,"num_colls","","The number of collision detected during the last update.",51],[9,"colls","","Collects the collisions detected during the last update.",51],[9,"toi","","Computes the time of impact of two objects.",51],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",52],[9,"num_colls","","The number of collision detected during the last update.",52],[9,"colls","","Collects the collisions detected during the last update.",52],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",53],[0,"broad","ncollide4df32","Broad phases."],[1,"NoIdDispatcher","ncollide4df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","The broad phase which does nothing."],[11,"dispatcher","","",54],[11,"pairs","","",54],[11,"objects","","",54],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",55],[11,"sobjects","","",55],[11,"rb2bv","","",55],[11,"pairs","","",55],[11,"dispatcher","","",55],[11,"margin","","",55],[11,"to_update","","",55],[11,"update_off","","",55],[1,"BoundingVolumeProxy","","Association of an object with its loose bounding volume."],[11,"bounding_volume","","The objects loose bounding volume.",56],[11,"body","","The object.",56],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",57],[11,"stree","","",57],[11,"active2bv","","",57],[11,"inactive2bv","","",57],[11,"pairs","","",57],[11,"spairs","","",57],[11,"dispatcher","","",57],[11,"margin","","",57],[11,"collector","","",57],[11,"to_update","","",57],[11,"update_off","","",57],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",58],[9,"remove","","Removes an element from this broad phase.",58],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",58],[9,"update_object","","Updates the collision pairs involving one specific object.",58],[6,"InterferencesBroadPhase","","Broad phase which check for pairwise interferences."],[9,"activate","","Marks and object as active.",59],[9,"deactivate","","Marks and object as inactive.",59],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",59],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",59],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",60],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",61],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",62],[9,"is_valid","","Tells whether a collision between two bodies can occur.",62],[0,"contact","ncollide4df32","Main data structure for contacts."],[1,"Contact","ncollide4df32::contact","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",63],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",63],[11,"normal","","Contact normal",63],[11,"depth","","Penetration depth",63],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"fmt","","",63],[10,"new","","Creates a new contact.",63],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",63],[0,"volumetric","ncollide4df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide4df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",64],[6,"InertiaTensor","","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",65],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",65],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",65],[0,"implicit","ncollide4df32","Definition of support functions."],[3,"cso_support_point","ncollide4df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[0,"implicit","","Traits for support mapping based geometries."],[6,"HasMargin","ncollide4df32::implicit::implicit","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",66],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",68],[0,"partitioning","ncollide4df32","Spatial partitioning tools."],[1,"DBVT","ncollide4df32::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",69],[11,"tree","","",69],[11,"len","","",69],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",70],[11,"center","","The center of this node bounding volume.",70],[11,"object","","An user-defined object.",70],[11,"parent","","This node parent.",70],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",71],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",72],[11,"collector","","",72],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",73],[11,"collector","","",73],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",74],[12,"LeftChildOf","","This leaf is the left child of another node.",74],[12,"Detached","","This leaf is detached from any tree.",74],[2,"BinaryPartition","","Result of a binary partitioning."],[12,"Part","","Result of the partitioning of one element.",75],[12,"Parts","","Result of the partitioning of several elements.",75],[3,"kdtree_partitioner","","Construction function for a kdree."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[9,"visit_leaf","","Visits a leaf.",76],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[10,"visit_leaf_mut","","Visits a leaf.",76],[0,"procedural","ncollide4df32","Procedural mesh generation."],[1,"TriMesh","ncollide4df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",77],[11,"normals","","Coordinates of the mesh normals.",77],[11,"uvs","","Textures coordinates of the mesh.",77],[11,"indices","","Index buffer of the mesh.",77],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",78],[11,"normals","","Coordinates of the polyline normals.",78],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",79],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",79],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle contained on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle contained on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide4df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_circle","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.\nThe created ring is open (the start and end points are not linked together)."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_closed_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide4df32::procedural","Path generation."],[1,"PolylinePattern","ncollide4df32::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",80],[11,"closed","","",80],[11,"last_start_id","","",80],[11,"start_cap","","",80],[11,"end_cap","","",80],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",81],[11,"curr_dir","","",81],[11,"curr_pt_id","","",81],[11,"curr_pt","","",81],[11,"polyline","","",81],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",82],[11,"front_dist_to_head","","",82],[11,"back_dist_to_head","","",82],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",83],[12,"InnerPoint","","A point that is inside of the path currently generated.",83],[12,"EndPoint","","A point that ends the path currently generated.",83],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",83],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",84],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",85],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",86],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",86],[6,"ToTriMesh","ncollide4df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",87],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",88],[0,"utils","ncollide4df32","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide4df32::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide4df32","Data structure utilities."],[0,"pair","ncollide4df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide4df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",89],[11,"second","","second object of the pair",89],[11,"ifirst","","",89],[11,"isecond","","",89],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",90],[10,"decode","","",89],[10,"encode","","",89],[10,"clone","","",89],[10,"new","","Builds a new `Pair`.",89],[10,"eq","","",89],[10,"decode","","",90],[10,"encode","","",90],[10,"new","","Creates a new PairTWHash",90],[10,"hash","","",90],[0,"hash","ncollide4df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide4df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",91],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",92],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",93],[10,"decode","","",91],[10,"encode","","",91],[10,"clone","","",91],[10,"new","","Creates a new UintPairTWHash.",91],[10,"hash","","",91],[10,"decode","","",92],[10,"encode","","",92],[10,"clone","","",92],[10,"new","","Creates a new UintTWHash.",92],[10,"hash","","",92],[0,"hash_map","ncollide4df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide4df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",94],[11,"value","","The value of the entry.",94],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",95],[11,"table","","",95],[11,"mask","","",95],[11,"htable","","",95],[11,"next","","",95],[11,"num_elem","","",95],[11,"max_elem","","",95],[11,"real_max_elem","","",95],[10,"decode","","",94],[10,"encode","","",94],[10,"clone","","",94],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Creates a new hash map.",95],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",95],[10,"elements","","The elements added to this hash map.",95],[10,"elements_mut","","The elements added to this hash map.",95],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",95],[10,"get_and_remove","","Removes an element and returns its value if it existed.",95],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",95],[10,"insert_or_replace","","Inserts or replace an element.",95],[10,"len","","",95],[10,"clear","","",95],[10,"contains_key","","",95],[10,"find","","",95],[10,"insert","","Inserts an element on the hash map.",95],[10,"remove","","Remove an element from the hash map.",95],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",95],[0,"owned_allocation_cache","ncollide4df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide4df32::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",96],[10,"new","","Initializes the cache.",96],[10,"alloc","","Box a value into a potentially already allocated box.",96],[10,"retain","","Retains a box which can be re-used by the `box` method.",96],[10,"clear","","Clears the cache, destroying any stored pointer.",96],[0,"has_uid","ncollide4df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide4df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",97],[10,"uid","std::gc","",98],[10,"uid","alloc::rc","",99],[10,"uid","alloc::arc","",100],[0,"vec_slice","ncollide4df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide4df32::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",101],[11,"length","","",101],[11,"stride","","",101],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",102],[11,"length","","",102],[11,"stride","","",102],[10,"len","","",101],[10,"is_empty","","",101],[10,"len","","",102],[10,"is_empty","","",102],[10,"new","","Creates a new immutable slice.",101],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",101],[10,"get","","Gets the i-th element of the slice.",101],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",101],[10,"new","","Creates a new mutable slice.",102],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",102],[10,"as_slice","","Creates an immutable slice from this mutable slice.",102],[10,"get","","Gets the i-th element of the slice.",102],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",102],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",102],[0,"math","ncollide4df32","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide4df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."]],"paths":[[1,"BoundingSphere"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"Geom"],[6,"ConcaveGeom"],[6,"MeshElement"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"BoundingVolumeProxy"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[1,"Contact"],[6,"Volumetric"],[6,"InertiaTensor"],[6,"HasMargin"],[6,"Implicit"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"]]};
searchIndex['ncollide3df32'] = {"items":[[0,"","ncollide3df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"BoundingSphere","ncollide3df32::bounding_volume","A bounding sphere."],[11,"center","","",0],[11,"radius","","",0],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",1],[0,"geom","ncollide3df32","Geometric primitives."],[1,"Ball","ncollide3df32::geom","A Ball geometry."],[11,"radius","","",2],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",3],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",4],[11,"margin","","",4],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",5],[11,"radius","","",5],[11,"margin","","",5],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",6],[11,"radius","","",6],[11,"margin","","",6],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",7],[11,"radius","","",7],[11,"margin","","",7],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",8],[11,"margin","","",8],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",9],[11,"g1","","",9],[11,"m2","","",9],[11,"g2","","",9],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",10],[11,"g1","","",10],[11,"m2","","",10],[11,"g2","","",10],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"g","","",11],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"shapes","","",12],[11,"bvt","","",12],[11,"bvs","","",12],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",13],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",14],[11,"bvs","","",14],[11,"margin","","",14],[11,"vertices","","",14],[11,"indices","","",14],[11,"uvs","","",14],[11,"normals","","",14],[1,"Segment","","A segment geometry."],[11,"margin","","",15],[11,"a","","",15],[11,"b","","",15],[1,"Triangle","","A triangle geometry."],[11,"margin","","",16],[11,"a","","",16],[11,"b","","",16],[11,"c","","",16],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",17],[11,"nupoints","","",17],[11,"nvpoints","","",17],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",18],[11,"v_cache","","",18],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",19],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",20],[0,"geom","","Enum grouping the most useful geometric shapes."],[6,"Geom","ncollide3df32::geom::geom","Trait (that should be) implemented by each geometry supported by `ncollide`."],[9,"duplicate","","Duplicates (clones) this geometry.",21],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries supported by `ncollide`."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",22],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",22],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",22],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",22],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",22],[4,"MeshPrimitive","ncollide3df32::geom",""],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",23],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",23],[0,"ray","ncollide3df32","Ray casting utilities."],[3,"plane_toi_with_ray","ncollide3df32::ray","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[0,"ray","","Traits and structure needed to cast rays."],[1,"Ray","ncollide3df32::ray::ray","A Ray."],[11,"orig","","Starting point of the ray.",24],[11,"dir","","Direction of the ray.",24],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",25],[11,"normal","","The normal at the intersection point.",25],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",25],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",26],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",26],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",26],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",26],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",26],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",26],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",26],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",26],[10,"decode","","",24],[10,"encode","","",24],[10,"fmt","","",24],[10,"new","","Creates a new ray starting from `orig` and with the direction `dir`. `dir` must be\nnormalized.",24],[10,"new_with_uvs","","Creates a new `RayIntersection`.",25],[10,"new","","Creates a new `RayIntersection`.",25],[0,"narrow","ncollide3df32","Narrow phases."],[1,"Empty","ncollide3df32::narrow","A collision detector that does nothing."],[11,"dummy","","",27],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",28],[11,"contact","","",28],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",29],[11,"contact","","",29],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",30],[11,"contact","","",30],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",31],[11,"prediction","","",31],[11,"contact","","",31],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",32],[11,"collector","","",32],[11,"prediction","","",32],[11,"sub_detector","","",32],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",33],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",34],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",35],[11,"to_delete","","",35],[11,"interferences","","",35],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",36],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",37],[11,"tree","","",37],[11,"selector","","",37],[11,"prediction","","",37],[11,"contacts","","",37],[11,"points","","",37],[11,"timestamp","","",37],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",38],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide3df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide3df32::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide3df32::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide3df32::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide3df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide3df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide3df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide3df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",39],[9,"translate_by","","Translates each point of this simplex.",39],[9,"add_point","","Adds a point to the simplex.",39],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",39],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",39],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",39],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",39],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",39],[0,"johnson_simplex","ncollide3df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide3df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",40],[11,"points","","",40],[11,"exchange_points","","",40],[11,"determinants","","",40],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",41],[11,"offsets","","",41],[11,"sub_determinants","","",41],[11,"num_determinants","","",41],[11,"num_leaves","","",41],[10,"clone","","",40],[10,"decode","","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",41],[10,"new","","Creates a new, empty, Johnson simplex.",40],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",40],[10,"reset","","",40],[10,"dimension","","",40],[10,"max_sq_len","","",40],[10,"contains_point","","",40],[10,"add_point","","",40],[10,"project_origin_and_reduce","","",40],[10,"project_origin","","",40],[10,"translate_by","","",40],[0,"gjk","ncollide3df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide3df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",42],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",42],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",42],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",42],[10,"decode","","",42],[10,"encode","","",42],[0,"minkowski_sampling","ncollide3df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide3df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide3df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide3df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",43],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",44],[11,"diff_v","","",44],[11,"max_lmd","","",44],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",45],[11,"spread_u","","",45],[11,"spread_v","","",45],[11,"axis_u","","",45],[11,"axis_v","","",45],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",46],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",46],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",46],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",46],[10,"clone","","",47],[10,"new","","Creates a new `YesSirSurfaceSelector`.",47],[10,"set_max_lmd","","",47],[10,"is_flat","","",47],[10,"may_contain_a_closest_point","","",47],[10,"create_test_data","","",47],[10,"clone","","",43],[10,"new","","Creates a new hyperplane-based surface selector.",43],[10,"set_max_lmd","","",43],[10,"is_flat","","",43],[10,"may_contain_a_closest_point","","",43],[10,"create_test_data","","",43],[10,"clone","","",44],[10,"new","","Creates a new tangent-cone based surface detector.",44],[10,"set_max_lmd","","",44],[10,"is_flat","","",44],[10,"may_contain_a_closest_point","","",44],[10,"create_test_data","","",44],[0,"surface_subdivision_tree","ncollide3df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide3df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",48],[11,"value","","",48],[11,"key","","",48],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",49],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",50],[11,"lchild","","",50],[11,"timestamp","","",50],[11,"data","","",50],[11,"surface","","",50],[10,"clone","","",48],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",48],[10,"deref","","",48],[10,"drop","","",48],[10,"new","","Creates a new surface subdivision tree cache.",49],[10,"clear","","Removes everything from this cache.",49],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",49],[10,"new_orphan","","Creates a new tree with no parent nor children.",50],[10,"surface","","The surface contained by this node.",50],[10,"data","","Reference to the data contained by this node.",50],[10,"data_mut","","Mutable reference to the data contained by this node.",50],[10,"timestamp","","The timestamp of this tree node.",50],[10,"set_timestamp","","Sets the timestamp of this tree node.",50],[10,"has_left_child","","Whether or not this node has a left child.",50],[10,"has_right_child","","Whether or not this node has a right child.",50],[10,"right_child","","A copy of this node right child.",50],[10,"left_child","","A copy of this node left child.",50],[10,"right_child_ref","","A reference to this node right child.",50],[10,"left_child_ref","","A reference to this node left child.",50],[10,"set_right_child","","Sets the right child of this node.",50],[10,"set_left_child","","Sets the left child of this node.",50],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",50],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",50],[10,"remove_right_child","","Removes the right child of this node.",50],[10,"remove_left_child","","Removes the left child of this node.",50],[6,"CollisionDetector","ncollide3df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",51],[9,"num_colls","","The number of collision detected during the last update.",51],[9,"colls","","Collects the collisions detected during the last update.",51],[9,"toi","","Computes the time of impact of two objects.",51],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",52],[9,"num_colls","","The number of collision detected during the last update.",52],[9,"colls","","Collects the collisions detected during the last update.",52],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",53],[0,"broad","ncollide3df32","Broad phases."],[1,"NoIdDispatcher","ncollide3df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","The broad phase which does nothing."],[11,"dispatcher","","",54],[11,"pairs","","",54],[11,"objects","","",54],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",55],[11,"sobjects","","",55],[11,"rb2bv","","",55],[11,"pairs","","",55],[11,"dispatcher","","",55],[11,"margin","","",55],[11,"to_update","","",55],[11,"update_off","","",55],[1,"BoundingVolumeProxy","","Association of an object with its loose bounding volume."],[11,"bounding_volume","","The objects loose bounding volume.",56],[11,"body","","The object.",56],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",57],[11,"stree","","",57],[11,"active2bv","","",57],[11,"inactive2bv","","",57],[11,"pairs","","",57],[11,"spairs","","",57],[11,"dispatcher","","",57],[11,"margin","","",57],[11,"collector","","",57],[11,"to_update","","",57],[11,"update_off","","",57],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",58],[9,"remove","","Removes an element from this broad phase.",58],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",58],[9,"update_object","","Updates the collision pairs involving one specific object.",58],[6,"InterferencesBroadPhase","","Broad phase which check for pairwise interferences."],[9,"activate","","Marks and object as active.",59],[9,"deactivate","","Marks and object as inactive.",59],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",59],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",59],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",60],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",61],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",62],[9,"is_valid","","Tells whether a collision between two bodies can occur.",62],[0,"contact","ncollide3df32","Main data structure for contacts."],[1,"Contact","ncollide3df32::contact","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",63],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",63],[11,"normal","","Contact normal",63],[11,"depth","","Penetration depth",63],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"fmt","","",63],[10,"new","","Creates a new contact.",63],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",63],[0,"volumetric","ncollide3df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide3df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",64],[6,"InertiaTensor","","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",65],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",65],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",65],[0,"implicit","ncollide3df32","Definition of support functions."],[3,"cso_support_point","ncollide3df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[0,"implicit","","Traits for support mapping based geometries."],[6,"HasMargin","ncollide3df32::implicit::implicit","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",66],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",68],[0,"partitioning","ncollide3df32","Spatial partitioning tools."],[1,"DBVT","ncollide3df32::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",69],[11,"tree","","",69],[11,"len","","",69],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",70],[11,"center","","The center of this node bounding volume.",70],[11,"object","","An user-defined object.",70],[11,"parent","","This node parent.",70],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",71],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",72],[11,"collector","","",72],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",73],[11,"collector","","",73],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",74],[12,"LeftChildOf","","This leaf is the left child of another node.",74],[12,"Detached","","This leaf is detached from any tree.",74],[2,"BinaryPartition","","Result of a binary partitioning."],[12,"Part","","Result of the partitioning of one element.",75],[12,"Parts","","Result of the partitioning of several elements.",75],[3,"kdtree_partitioner","","Construction function for a kdree."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[9,"visit_leaf","","Visits a leaf.",76],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[10,"visit_leaf_mut","","Visits a leaf.",76],[0,"procedural","ncollide3df32","Procedural mesh generation."],[1,"TriMesh","ncollide3df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",77],[11,"normals","","Coordinates of the mesh normals.",77],[11,"uvs","","Textures coordinates of the mesh.",77],[11,"indices","","Index buffer of the mesh.",77],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",78],[11,"normals","","Coordinates of the polyline normals.",78],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",79],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",79],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle contained on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle contained on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide3df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_circle","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.\nThe created ring is open (the start and end points are not linked together)."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_closed_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide3df32::procedural","Path generation."],[1,"PolylinePattern","ncollide3df32::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",80],[11,"closed","","",80],[11,"last_start_id","","",80],[11,"start_cap","","",80],[11,"end_cap","","",80],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",81],[11,"curr_dir","","",81],[11,"curr_pt_id","","",81],[11,"curr_pt","","",81],[11,"polyline","","",81],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",82],[11,"front_dist_to_head","","",82],[11,"back_dist_to_head","","",82],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",83],[12,"InnerPoint","","A point that is inside of the path currently generated.",83],[12,"EndPoint","","A point that ends the path currently generated.",83],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",83],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",84],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",85],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",86],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",86],[6,"ToTriMesh","ncollide3df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",87],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",88],[0,"utils","ncollide3df32","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide3df32::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide3df32","Data structure utilities."],[0,"pair","ncollide3df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide3df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",89],[11,"second","","second object of the pair",89],[11,"ifirst","","",89],[11,"isecond","","",89],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",90],[10,"decode","","",89],[10,"encode","","",89],[10,"clone","","",89],[10,"new","","Builds a new `Pair`.",89],[10,"eq","","",89],[10,"decode","","",90],[10,"encode","","",90],[10,"new","","Creates a new PairTWHash",90],[10,"hash","","",90],[0,"hash","ncollide3df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide3df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",91],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",92],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",93],[10,"decode","","",91],[10,"encode","","",91],[10,"clone","","",91],[10,"new","","Creates a new UintPairTWHash.",91],[10,"hash","","",91],[10,"decode","","",92],[10,"encode","","",92],[10,"clone","","",92],[10,"new","","Creates a new UintTWHash.",92],[10,"hash","","",92],[0,"hash_map","ncollide3df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide3df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",94],[11,"value","","The value of the entry.",94],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",95],[11,"table","","",95],[11,"mask","","",95],[11,"htable","","",95],[11,"next","","",95],[11,"num_elem","","",95],[11,"max_elem","","",95],[11,"real_max_elem","","",95],[10,"decode","","",94],[10,"encode","","",94],[10,"clone","","",94],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Creates a new hash map.",95],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",95],[10,"elements","","The elements added to this hash map.",95],[10,"elements_mut","","The elements added to this hash map.",95],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",95],[10,"get_and_remove","","Removes an element and returns its value if it existed.",95],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",95],[10,"insert_or_replace","","Inserts or replace an element.",95],[10,"len","","",95],[10,"clear","","",95],[10,"contains_key","","",95],[10,"find","","",95],[10,"insert","","Inserts an element on the hash map.",95],[10,"remove","","Remove an element from the hash map.",95],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",95],[0,"owned_allocation_cache","ncollide3df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide3df32::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",96],[10,"new","","Initializes the cache.",96],[10,"alloc","","Box a value into a potentially already allocated box.",96],[10,"retain","","Retains a box which can be re-used by the `box` method.",96],[10,"clear","","Clears the cache, destroying any stored pointer.",96],[0,"has_uid","ncollide3df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide3df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",97],[10,"uid","std::gc","",98],[10,"uid","alloc::rc","",99],[10,"uid","alloc::arc","",100],[0,"vec_slice","ncollide3df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide3df32::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",101],[11,"length","","",101],[11,"stride","","",101],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",102],[11,"length","","",102],[11,"stride","","",102],[10,"len","","",101],[10,"is_empty","","",101],[10,"len","","",102],[10,"is_empty","","",102],[10,"new","","Creates a new immutable slice.",101],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",101],[10,"get","","Gets the i-th element of the slice.",101],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",101],[10,"new","","Creates a new mutable slice.",102],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",102],[10,"as_slice","","Creates an immutable slice from this mutable slice.",102],[10,"get","","Gets the i-th element of the slice.",102],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",102],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",102],[0,"math","ncollide3df32","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide3df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."]],"paths":[[1,"BoundingSphere"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"Geom"],[6,"ConcaveGeom"],[6,"MeshElement"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"BoundingVolumeProxy"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[1,"Contact"],[6,"Volumetric"],[6,"InertiaTensor"],[6,"HasMargin"],[6,"Implicit"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"]]};

searchIndex['ncollide2df32'] = {"items":[[0,"","ncollide2df32","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"BoundingSphere","ncollide2df32::bounding_volume","A bounding sphere."],[11,"center","","",0],[11,"radius","","",0],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",1],[0,"geom","ncollide2df32","Geometric primitives."],[1,"Ball","ncollide2df32::geom","A Ball geometry."],[11,"radius","","",2],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",3],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",4],[11,"margin","","",4],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",5],[11,"radius","","",5],[11,"margin","","",5],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",6],[11,"radius","","",6],[11,"margin","","",6],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",7],[11,"radius","","",7],[11,"margin","","",7],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",8],[11,"margin","","",8],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",9],[11,"g1","","",9],[11,"m2","","",9],[11,"g2","","",9],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",10],[11,"g1","","",10],[11,"m2","","",10],[11,"g2","","",10],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"g","","",11],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"shapes","","",12],[11,"bvt","","",12],[11,"bvs","","",12],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",13],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",14],[11,"bvs","","",14],[11,"margin","","",14],[11,"vertices","","",14],[11,"indices","","",14],[11,"uvs","","",14],[11,"normals","","",14],[1,"Segment","","A segment geometry."],[11,"margin","","",15],[11,"a","","",15],[11,"b","","",15],[1,"Triangle","","A triangle geometry."],[11,"margin","","",16],[11,"a","","",16],[11,"b","","",16],[11,"c","","",16],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",17],[11,"nupoints","","",17],[11,"nvpoints","","",17],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",18],[11,"v_cache","","",18],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",19],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",20],[0,"geom","","Enum grouping the most useful geometric shapes."],[6,"Geom","ncollide2df32::geom::geom","Trait (that should be) implemented by each geometry supported by `ncollide`."],[9,"duplicate","","Duplicates (clones) this geometry.",21],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries supported by `ncollide`."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",22],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",22],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",22],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",22],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",22],[4,"MeshPrimitive","ncollide2df32::geom",""],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",23],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",23],[0,"ray","ncollide2df32","Ray casting utilities."],[3,"plane_toi_with_ray","ncollide2df32::ray","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[0,"ray","","Traits and structure needed to cast rays."],[1,"Ray","ncollide2df32::ray::ray","A Ray."],[11,"orig","","Starting point of the ray.",24],[11,"dir","","Direction of the ray.",24],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",25],[11,"normal","","The normal at the intersection point.",25],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",26],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",26],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",26],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",26],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",26],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",26],[10,"decode","","",24],[10,"encode","","",24],[10,"fmt","","",24],[10,"new","","Creates a new ray starting from `orig` and with the direction `dir`. `dir` must be\nnormalized.",24],[10,"new","","Creates a new `RayIntersection`.",25],[0,"narrow","ncollide2df32","Narrow phases."],[1,"Empty","ncollide2df32::narrow","A collision detector that does nothing."],[11,"dummy","","",27],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",28],[11,"contact","","",28],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",29],[11,"contact","","",29],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",30],[11,"contact","","",30],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",31],[11,"prediction","","",31],[11,"contact","","",31],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",32],[11,"collector","","",32],[11,"prediction","","",32],[11,"sub_detector","","",32],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",33],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",34],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",35],[11,"to_delete","","",35],[11,"interferences","","",35],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",36],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",37],[11,"tree","","",37],[11,"selector","","",37],[11,"prediction","","",37],[11,"contacts","","",37],[11,"points","","",37],[11,"timestamp","","",37],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",38],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide2df32::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide2df32::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide2df32::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide2df32::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide2df32::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide2df32::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide2df32::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide2df32::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",39],[9,"translate_by","","Translates each point of this simplex.",39],[9,"add_point","","Adds a point to the simplex.",39],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",39],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",39],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",39],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",39],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",39],[0,"johnson_simplex","ncollide2df32::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide2df32::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",40],[11,"points","","",40],[11,"exchange_points","","",40],[11,"determinants","","",40],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",41],[11,"offsets","","",41],[11,"sub_determinants","","",41],[11,"num_determinants","","",41],[11,"num_leaves","","",41],[10,"clone","","",40],[10,"decode","","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",41],[10,"new","","Creates a new, empty, Johnson simplex.",40],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",40],[10,"reset","","",40],[10,"dimension","","",40],[10,"max_sq_len","","",40],[10,"contains_point","","",40],[10,"add_point","","",40],[10,"project_origin_and_reduce","","",40],[10,"project_origin","","",40],[10,"translate_by","","",40],[0,"gjk","ncollide2df32::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide2df32::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",42],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",42],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",42],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",42],[10,"decode","","",42],[10,"encode","","",42],[0,"minkowski_sampling","ncollide2df32::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide2df32::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide2df32::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide2df32::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",43],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",44],[11,"diff_v","","",44],[11,"max_lmd","","",44],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",45],[11,"spread_u","","",45],[11,"spread_v","","",45],[11,"axis_u","","",45],[11,"axis_v","","",45],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",46],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",46],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",46],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",46],[10,"clone","","",47],[10,"new","","Creates a new `YesSirSurfaceSelector`.",47],[10,"set_max_lmd","","",47],[10,"is_flat","","",47],[10,"may_contain_a_closest_point","","",47],[10,"create_test_data","","",47],[10,"clone","","",43],[10,"new","","Creates a new hyperplane-based surface selector.",43],[10,"set_max_lmd","","",43],[10,"is_flat","","",43],[10,"may_contain_a_closest_point","","",43],[10,"create_test_data","","",43],[10,"clone","","",44],[10,"new","","Creates a new tangent-cone based surface detector.",44],[10,"set_max_lmd","","",44],[10,"is_flat","","",44],[10,"may_contain_a_closest_point","","",44],[10,"create_test_data","","",44],[0,"surface_subdivision_tree","ncollide2df32::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide2df32::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",48],[11,"value","","",48],[11,"key","","",48],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",49],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",50],[11,"lchild","","",50],[11,"timestamp","","",50],[11,"data","","",50],[11,"surface","","",50],[10,"clone","","",48],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",48],[10,"deref","","",48],[10,"drop","","",48],[10,"new","","Creates a new surface subdivision tree cache.",49],[10,"clear","","Removes everything from this cache.",49],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",49],[10,"new_orphan","","Creates a new tree with no parent nor children.",50],[10,"surface","","The surface contained by this node.",50],[10,"data","","Reference to the data contained by this node.",50],[10,"data_mut","","Mutable reference to the data contained by this node.",50],[10,"timestamp","","The timestamp of this tree node.",50],[10,"set_timestamp","","Sets the timestamp of this tree node.",50],[10,"has_left_child","","Whether or not this node has a left child.",50],[10,"has_right_child","","Whether or not this node has a right child.",50],[10,"right_child","","A copy of this node right child.",50],[10,"left_child","","A copy of this node left child.",50],[10,"right_child_ref","","A reference to this node right child.",50],[10,"left_child_ref","","A reference to this node left child.",50],[10,"set_right_child","","Sets the right child of this node.",50],[10,"set_left_child","","Sets the left child of this node.",50],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",50],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",50],[10,"remove_right_child","","Removes the right child of this node.",50],[10,"remove_left_child","","Removes the left child of this node.",50],[6,"CollisionDetector","ncollide2df32::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",51],[9,"num_colls","","The number of collision detected during the last update.",51],[9,"colls","","Collects the collisions detected during the last update.",51],[9,"toi","","Computes the time of impact of two objects.",51],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",52],[9,"num_colls","","The number of collision detected during the last update.",52],[9,"colls","","Collects the collisions detected during the last update.",52],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",53],[0,"broad","ncollide2df32","Broad phases."],[1,"NoIdDispatcher","ncollide2df32::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","The broad phase which does nothing."],[11,"dispatcher","","",54],[11,"pairs","","",54],[11,"objects","","",54],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",55],[11,"sobjects","","",55],[11,"rb2bv","","",55],[11,"pairs","","",55],[11,"dispatcher","","",55],[11,"margin","","",55],[11,"to_update","","",55],[11,"update_off","","",55],[1,"BoundingVolumeProxy","","Association of an object with its loose bounding volume."],[11,"bounding_volume","","The objects loose bounding volume.",56],[11,"body","","The object.",56],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",57],[11,"stree","","",57],[11,"active2bv","","",57],[11,"inactive2bv","","",57],[11,"pairs","","",57],[11,"spairs","","",57],[11,"dispatcher","","",57],[11,"margin","","",57],[11,"collector","","",57],[11,"to_update","","",57],[11,"update_off","","",57],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",58],[9,"remove","","Removes an element from this broad phase.",58],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",58],[9,"update_object","","Updates the collision pairs involving one specific object.",58],[6,"InterferencesBroadPhase","","Broad phase which check for pairwise interferences."],[9,"activate","","Marks and object as active.",59],[9,"deactivate","","Marks and object as inactive.",59],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",59],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",59],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",60],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",61],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",62],[9,"is_valid","","Tells whether a collision between two bodies can occur.",62],[0,"contact","ncollide2df32","Main data structure for contacts."],[1,"Contact","ncollide2df32::contact","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",63],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",63],[11,"normal","","Contact normal",63],[11,"depth","","Penetration depth",63],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"fmt","","",63],[10,"new","","Creates a new contact.",63],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",63],[0,"volumetric","ncollide2df32","Volume and inertia tensor computation."],[3,"ball_volume","ncollide2df32::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",64],[6,"InertiaTensor","","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",65],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",65],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",65],[0,"implicit","ncollide2df32","Definition of support functions."],[3,"cso_support_point","ncollide2df32::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[0,"implicit","","Traits for support mapping based geometries."],[6,"HasMargin","ncollide2df32::implicit::implicit","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",66],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",68],[0,"partitioning","ncollide2df32","Spatial partitioning tools."],[1,"DBVT","ncollide2df32::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",69],[11,"tree","","",69],[11,"len","","",69],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",70],[11,"center","","The center of this node bounding volume.",70],[11,"object","","An user-defined object.",70],[11,"parent","","This node parent.",70],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",71],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",72],[11,"collector","","",72],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",73],[11,"collector","","",73],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",74],[12,"LeftChildOf","","This leaf is the left child of another node.",74],[12,"Detached","","This leaf is detached from any tree.",74],[2,"BinaryPartition","","Result of a binary partitioning."],[12,"Part","","Result of the partitioning of one element.",75],[12,"Parts","","Result of the partitioning of several elements.",75],[3,"kdtree_partitioner","","Construction function for a kdree."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[9,"visit_leaf","","Visits a leaf.",76],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[10,"visit_leaf_mut","","Visits a leaf.",76],[0,"procedural","ncollide2df32","Procedural mesh generation."],[1,"TriMesh","ncollide2df32::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",77],[11,"normals","","Coordinates of the mesh normals.",77],[11,"uvs","","Textures coordinates of the mesh.",77],[11,"indices","","Index buffer of the mesh.",77],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",78],[11,"normals","","Coordinates of the polyline normals.",78],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",79],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",79],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle contained on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle contained on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide2df32::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_circle","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.\nThe created ring is open (the start and end points are not linked together)."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_closed_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide2df32::procedural","Path generation."],[1,"PolylinePattern","ncollide2df32::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",80],[11,"closed","","",80],[11,"last_start_id","","",80],[11,"start_cap","","",80],[11,"end_cap","","",80],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",81],[11,"curr_dir","","",81],[11,"curr_pt_id","","",81],[11,"curr_pt","","",81],[11,"polyline","","",81],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",82],[11,"front_dist_to_head","","",82],[11,"back_dist_to_head","","",82],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",83],[12,"InnerPoint","","A point that is inside of the path currently generated.",83],[12,"EndPoint","","A point that ends the path currently generated.",83],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",83],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",84],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",85],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",86],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",86],[6,"ToTriMesh","ncollide2df32::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",87],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",88],[0,"utils","ncollide2df32","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide2df32::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide2df32","Data structure utilities."],[0,"pair","ncollide2df32::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide2df32::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",89],[11,"second","","second object of the pair",89],[11,"ifirst","","",89],[11,"isecond","","",89],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",90],[10,"decode","","",89],[10,"encode","","",89],[10,"clone","","",89],[10,"new","","Builds a new `Pair`.",89],[10,"eq","","",89],[10,"decode","","",90],[10,"encode","","",90],[10,"new","","Creates a new PairTWHash",90],[10,"hash","","",90],[0,"hash","ncollide2df32::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide2df32::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",91],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",92],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",93],[10,"decode","","",91],[10,"encode","","",91],[10,"clone","","",91],[10,"new","","Creates a new UintPairTWHash.",91],[10,"hash","","",91],[10,"decode","","",92],[10,"encode","","",92],[10,"clone","","",92],[10,"new","","Creates a new UintTWHash.",92],[10,"hash","","",92],[0,"hash_map","ncollide2df32::data","An hash map with a customizable hash function."],[1,"Entry","ncollide2df32::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",94],[11,"value","","The value of the entry.",94],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",95],[11,"table","","",95],[11,"mask","","",95],[11,"htable","","",95],[11,"next","","",95],[11,"num_elem","","",95],[11,"max_elem","","",95],[11,"real_max_elem","","",95],[10,"decode","","",94],[10,"encode","","",94],[10,"clone","","",94],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Creates a new hash map.",95],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",95],[10,"elements","","The elements added to this hash map.",95],[10,"elements_mut","","The elements added to this hash map.",95],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",95],[10,"get_and_remove","","Removes an element and returns its value if it existed.",95],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",95],[10,"insert_or_replace","","Inserts or replace an element.",95],[10,"len","","",95],[10,"clear","","",95],[10,"contains_key","","",95],[10,"find","","",95],[10,"insert","","Inserts an element on the hash map.",95],[10,"remove","","Remove an element from the hash map.",95],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",95],[0,"owned_allocation_cache","ncollide2df32::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide2df32::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",96],[10,"new","","Initializes the cache.",96],[10,"alloc","","Box a value into a potentially already allocated box.",96],[10,"retain","","Retains a box which can be re-used by the `box` method.",96],[10,"clear","","Clears the cache, destroying any stored pointer.",96],[0,"has_uid","ncollide2df32::data","Objects with an unique identifier."],[6,"HasUid","ncollide2df32::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",97],[10,"uid","std::gc","",98],[10,"uid","alloc::rc","",99],[10,"uid","alloc::arc","",100],[0,"vec_slice","ncollide2df32::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide2df32::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",101],[11,"length","","",101],[11,"stride","","",101],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",102],[11,"length","","",102],[11,"stride","","",102],[10,"len","","",101],[10,"is_empty","","",101],[10,"len","","",102],[10,"is_empty","","",102],[10,"new","","Creates a new immutable slice.",101],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",101],[10,"get","","Gets the i-th element of the slice.",101],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",101],[10,"new","","Creates a new mutable slice.",102],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",102],[10,"as_slice","","Creates an immutable slice from this mutable slice.",102],[10,"get","","Gets the i-th element of the slice.",102],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",102],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",102],[0,"math","ncollide2df32","Compilation-flags-dependent aliases for mathematical types."],[4,"Scalar","ncollide2df32::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."]],"paths":[[1,"BoundingSphere"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"Geom"],[6,"ConcaveGeom"],[6,"MeshElement"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"BoundingVolumeProxy"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[1,"Contact"],[6,"Volumetric"],[6,"InertiaTensor"],[6,"HasMargin"],[6,"Implicit"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"]]};

searchIndex['ncollide4df64'] = {"items":[[0,"","ncollide4df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"BoundingSphere","ncollide4df64::bounding_volume","A bounding sphere."],[11,"center","","",0],[11,"radius","","",0],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",1],[0,"geom","ncollide4df64","Geometric primitives."],[1,"Ball","ncollide4df64::geom","A Ball geometry."],[11,"radius","","",2],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",3],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",4],[11,"margin","","",4],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",5],[11,"radius","","",5],[11,"margin","","",5],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",6],[11,"radius","","",6],[11,"margin","","",6],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",7],[11,"radius","","",7],[11,"margin","","",7],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",8],[11,"margin","","",8],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",9],[11,"g1","","",9],[11,"m2","","",9],[11,"g2","","",9],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",10],[11,"g1","","",10],[11,"m2","","",10],[11,"g2","","",10],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"g","","",11],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"shapes","","",12],[11,"bvt","","",12],[11,"bvs","","",12],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",13],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",14],[11,"bvs","","",14],[11,"margin","","",14],[11,"vertices","","",14],[11,"indices","","",14],[11,"uvs","","",14],[11,"normals","","",14],[1,"Segment","","A segment geometry."],[11,"margin","","",15],[11,"a","","",15],[11,"b","","",15],[1,"Triangle","","A triangle geometry."],[11,"margin","","",16],[11,"a","","",16],[11,"b","","",16],[11,"c","","",16],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",17],[11,"nupoints","","",17],[11,"nvpoints","","",17],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",18],[11,"v_cache","","",18],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",19],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",20],[0,"geom","","Enum grouping the most useful geometric shapes."],[6,"Geom","ncollide4df64::geom::geom","Trait (that should be) implemented by each geometry supported by `ncollide`."],[9,"duplicate","","Duplicates (clones) this geometry.",21],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries supported by `ncollide`."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",22],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",22],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",22],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",22],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",22],[4,"MeshPrimitive","ncollide4df64::geom",""],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",23],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",23],[0,"ray","ncollide4df64","Ray casting utilities."],[3,"plane_toi_with_ray","ncollide4df64::ray","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[0,"ray","","Traits and structure needed to cast rays."],[1,"Ray","ncollide4df64::ray::ray","A Ray."],[11,"orig","","Starting point of the ray.",24],[11,"dir","","Direction of the ray.",24],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",25],[11,"normal","","The normal at the intersection point.",25],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",26],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",26],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",26],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",26],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",26],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",26],[10,"decode","","",24],[10,"encode","","",24],[10,"fmt","","",24],[10,"new","","Creates a new ray starting from `orig` and with the direction `dir`. `dir` must be\nnormalized.",24],[10,"new","","Creates a new `RayIntersection`.",25],[0,"narrow","ncollide4df64","Narrow phases."],[1,"Empty","ncollide4df64::narrow","A collision detector that does nothing."],[11,"dummy","","",27],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",28],[11,"contact","","",28],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",29],[11,"contact","","",29],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",30],[11,"contact","","",30],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",31],[11,"prediction","","",31],[11,"contact","","",31],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",32],[11,"collector","","",32],[11,"prediction","","",32],[11,"sub_detector","","",32],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",33],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",34],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",35],[11,"to_delete","","",35],[11,"interferences","","",35],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",36],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",37],[11,"tree","","",37],[11,"selector","","",37],[11,"prediction","","",37],[11,"contacts","","",37],[11,"points","","",37],[11,"timestamp","","",37],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",38],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide4df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide4df64::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide4df64::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide4df64::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide4df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide4df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide4df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide4df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",39],[9,"translate_by","","Translates each point of this simplex.",39],[9,"add_point","","Adds a point to the simplex.",39],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",39],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",39],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",39],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",39],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",39],[0,"johnson_simplex","ncollide4df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide4df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",40],[11,"points","","",40],[11,"exchange_points","","",40],[11,"determinants","","",40],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",41],[11,"offsets","","",41],[11,"sub_determinants","","",41],[11,"num_determinants","","",41],[11,"num_leaves","","",41],[10,"clone","","",40],[10,"decode","","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",41],[10,"new","","Creates a new, empty, Johnson simplex.",40],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",40],[10,"reset","","",40],[10,"dimension","","",40],[10,"max_sq_len","","",40],[10,"contains_point","","",40],[10,"add_point","","",40],[10,"project_origin_and_reduce","","",40],[10,"project_origin","","",40],[10,"translate_by","","",40],[0,"gjk","ncollide4df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide4df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",42],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",42],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",42],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",42],[10,"decode","","",42],[10,"encode","","",42],[0,"minkowski_sampling","ncollide4df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide4df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide4df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide4df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",43],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",44],[11,"diff_v","","",44],[11,"max_lmd","","",44],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",45],[11,"spread_u","","",45],[11,"spread_v","","",45],[11,"axis_u","","",45],[11,"axis_v","","",45],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",46],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",46],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",46],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",46],[10,"clone","","",47],[10,"new","","Creates a new `YesSirSurfaceSelector`.",47],[10,"set_max_lmd","","",47],[10,"is_flat","","",47],[10,"may_contain_a_closest_point","","",47],[10,"create_test_data","","",47],[10,"clone","","",43],[10,"new","","Creates a new hyperplane-based surface selector.",43],[10,"set_max_lmd","","",43],[10,"is_flat","","",43],[10,"may_contain_a_closest_point","","",43],[10,"create_test_data","","",43],[10,"clone","","",44],[10,"new","","Creates a new tangent-cone based surface detector.",44],[10,"set_max_lmd","","",44],[10,"is_flat","","",44],[10,"may_contain_a_closest_point","","",44],[10,"create_test_data","","",44],[0,"surface_subdivision_tree","ncollide4df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide4df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",48],[11,"value","","",48],[11,"key","","",48],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",49],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",50],[11,"lchild","","",50],[11,"timestamp","","",50],[11,"data","","",50],[11,"surface","","",50],[10,"clone","","",48],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",48],[10,"deref","","",48],[10,"drop","","",48],[10,"new","","Creates a new surface subdivision tree cache.",49],[10,"clear","","Removes everything from this cache.",49],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",49],[10,"new_orphan","","Creates a new tree with no parent nor children.",50],[10,"surface","","The surface contained by this node.",50],[10,"data","","Reference to the data contained by this node.",50],[10,"data_mut","","Mutable reference to the data contained by this node.",50],[10,"timestamp","","The timestamp of this tree node.",50],[10,"set_timestamp","","Sets the timestamp of this tree node.",50],[10,"has_left_child","","Whether or not this node has a left child.",50],[10,"has_right_child","","Whether or not this node has a right child.",50],[10,"right_child","","A copy of this node right child.",50],[10,"left_child","","A copy of this node left child.",50],[10,"right_child_ref","","A reference to this node right child.",50],[10,"left_child_ref","","A reference to this node left child.",50],[10,"set_right_child","","Sets the right child of this node.",50],[10,"set_left_child","","Sets the left child of this node.",50],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",50],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",50],[10,"remove_right_child","","Removes the right child of this node.",50],[10,"remove_left_child","","Removes the left child of this node.",50],[6,"CollisionDetector","ncollide4df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",51],[9,"num_colls","","The number of collision detected during the last update.",51],[9,"colls","","Collects the collisions detected during the last update.",51],[9,"toi","","Computes the time of impact of two objects.",51],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",52],[9,"num_colls","","The number of collision detected during the last update.",52],[9,"colls","","Collects the collisions detected during the last update.",52],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",53],[0,"broad","ncollide4df64","Broad phases."],[1,"NoIdDispatcher","ncollide4df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","The broad phase which does nothing."],[11,"dispatcher","","",54],[11,"pairs","","",54],[11,"objects","","",54],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",55],[11,"sobjects","","",55],[11,"rb2bv","","",55],[11,"pairs","","",55],[11,"dispatcher","","",55],[11,"margin","","",55],[11,"to_update","","",55],[11,"update_off","","",55],[1,"BoundingVolumeProxy","","Association of an object with its loose bounding volume."],[11,"bounding_volume","","The objects loose bounding volume.",56],[11,"body","","The object.",56],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",57],[11,"stree","","",57],[11,"active2bv","","",57],[11,"inactive2bv","","",57],[11,"pairs","","",57],[11,"spairs","","",57],[11,"dispatcher","","",57],[11,"margin","","",57],[11,"collector","","",57],[11,"to_update","","",57],[11,"update_off","","",57],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",58],[9,"remove","","Removes an element from this broad phase.",58],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",58],[9,"update_object","","Updates the collision pairs involving one specific object.",58],[6,"InterferencesBroadPhase","","Broad phase which check for pairwise interferences."],[9,"activate","","Marks and object as active.",59],[9,"deactivate","","Marks and object as inactive.",59],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",59],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",59],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",60],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",61],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",62],[9,"is_valid","","Tells whether a collision between two bodies can occur.",62],[0,"contact","ncollide4df64","Main data structure for contacts."],[1,"Contact","ncollide4df64::contact","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",63],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",63],[11,"normal","","Contact normal",63],[11,"depth","","Penetration depth",63],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"fmt","","",63],[10,"new","","Creates a new contact.",63],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",63],[0,"volumetric","ncollide4df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide4df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",64],[6,"InertiaTensor","","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",65],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",65],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",65],[0,"implicit","ncollide4df64","Definition of support functions."],[3,"cso_support_point","ncollide4df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[0,"implicit","","Traits for support mapping based geometries."],[6,"HasMargin","ncollide4df64::implicit::implicit","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",66],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",68],[0,"partitioning","ncollide4df64","Spatial partitioning tools."],[1,"DBVT","ncollide4df64::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",69],[11,"tree","","",69],[11,"len","","",69],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",70],[11,"center","","The center of this node bounding volume.",70],[11,"object","","An user-defined object.",70],[11,"parent","","This node parent.",70],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",71],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",72],[11,"collector","","",72],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",73],[11,"collector","","",73],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",74],[12,"LeftChildOf","","This leaf is the left child of another node.",74],[12,"Detached","","This leaf is detached from any tree.",74],[2,"BinaryPartition","","Result of a binary partitioning."],[12,"Part","","Result of the partitioning of one element.",75],[12,"Parts","","Result of the partitioning of several elements.",75],[3,"kdtree_partitioner","","Construction function for a kdree."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[9,"visit_leaf","","Visits a leaf.",76],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[10,"visit_leaf_mut","","Visits a leaf.",76],[0,"procedural","ncollide4df64","Procedural mesh generation."],[1,"TriMesh","ncollide4df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",77],[11,"normals","","Coordinates of the mesh normals.",77],[11,"uvs","","Textures coordinates of the mesh.",77],[11,"indices","","Index buffer of the mesh.",77],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",78],[11,"normals","","Coordinates of the polyline normals.",78],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",79],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",79],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle contained on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle contained on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide4df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_circle","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.\nThe created ring is open (the start and end points are not linked together)."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_closed_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide4df64::procedural","Path generation."],[1,"PolylinePattern","ncollide4df64::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",80],[11,"closed","","",80],[11,"last_start_id","","",80],[11,"start_cap","","",80],[11,"end_cap","","",80],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",81],[11,"curr_dir","","",81],[11,"curr_pt_id","","",81],[11,"curr_pt","","",81],[11,"polyline","","",81],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",82],[11,"front_dist_to_head","","",82],[11,"back_dist_to_head","","",82],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",83],[12,"InnerPoint","","A point that is inside of the path currently generated.",83],[12,"EndPoint","","A point that ends the path currently generated.",83],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",83],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",84],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",85],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",86],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",86],[6,"ToTriMesh","ncollide4df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",87],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",88],[0,"utils","ncollide4df64","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide4df64::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide4df64","Data structure utilities."],[0,"pair","ncollide4df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide4df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",89],[11,"second","","second object of the pair",89],[11,"ifirst","","",89],[11,"isecond","","",89],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",90],[10,"decode","","",89],[10,"encode","","",89],[10,"clone","","",89],[10,"new","","Builds a new `Pair`.",89],[10,"eq","","",89],[10,"decode","","",90],[10,"encode","","",90],[10,"new","","Creates a new PairTWHash",90],[10,"hash","","",90],[0,"hash","ncollide4df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide4df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",91],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",92],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",93],[10,"decode","","",91],[10,"encode","","",91],[10,"clone","","",91],[10,"new","","Creates a new UintPairTWHash.",91],[10,"hash","","",91],[10,"decode","","",92],[10,"encode","","",92],[10,"clone","","",92],[10,"new","","Creates a new UintTWHash.",92],[10,"hash","","",92],[0,"hash_map","ncollide4df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide4df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",94],[11,"value","","The value of the entry.",94],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",95],[11,"table","","",95],[11,"mask","","",95],[11,"htable","","",95],[11,"next","","",95],[11,"num_elem","","",95],[11,"max_elem","","",95],[11,"real_max_elem","","",95],[10,"decode","","",94],[10,"encode","","",94],[10,"clone","","",94],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Creates a new hash map.",95],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",95],[10,"elements","","The elements added to this hash map.",95],[10,"elements_mut","","The elements added to this hash map.",95],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",95],[10,"get_and_remove","","Removes an element and returns its value if it existed.",95],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",95],[10,"insert_or_replace","","Inserts or replace an element.",95],[10,"len","","",95],[10,"clear","","",95],[10,"contains_key","","",95],[10,"find","","",95],[10,"insert","","Inserts an element on the hash map.",95],[10,"remove","","Remove an element from the hash map.",95],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",95],[0,"owned_allocation_cache","ncollide4df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide4df64::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",96],[10,"new","","Initializes the cache.",96],[10,"alloc","","Box a value into a potentially already allocated box.",96],[10,"retain","","Retains a box which can be re-used by the `box` method.",96],[10,"clear","","Clears the cache, destroying any stored pointer.",96],[0,"has_uid","ncollide4df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide4df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",97],[10,"uid","std::gc","",98],[10,"uid","alloc::rc","",99],[10,"uid","alloc::arc","",100],[0,"vec_slice","ncollide4df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide4df64::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",101],[11,"length","","",101],[11,"stride","","",101],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",102],[11,"length","","",102],[11,"stride","","",102],[10,"len","","",101],[10,"is_empty","","",101],[10,"len","","",102],[10,"is_empty","","",102],[10,"new","","Creates a new immutable slice.",101],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",101],[10,"get","","Gets the i-th element of the slice.",101],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",101],[10,"new","","Creates a new mutable slice.",102],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",102],[10,"as_slice","","Creates an immutable slice from this mutable slice.",102],[10,"get","","Gets the i-th element of the slice.",102],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",102],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",102],[0,"math","ncollide4df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide4df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."]],"paths":[[1,"BoundingSphere"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"Geom"],[6,"ConcaveGeom"],[6,"MeshElement"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"BoundingVolumeProxy"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[1,"Contact"],[6,"Volumetric"],[6,"InertiaTensor"],[6,"HasMargin"],[6,"Implicit"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"]]};

searchIndex['ncollide3df64'] = {"items":[[0,"","ncollide3df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"BoundingSphere","ncollide3df64::bounding_volume","A bounding sphere."],[11,"center","","",0],[11,"radius","","",0],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",1],[0,"geom","ncollide3df64","Geometric primitives."],[1,"Ball","ncollide3df64::geom","A Ball geometry."],[11,"radius","","",2],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",3],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",4],[11,"margin","","",4],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",5],[11,"radius","","",5],[11,"margin","","",5],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",6],[11,"radius","","",6],[11,"margin","","",6],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",7],[11,"radius","","",7],[11,"margin","","",7],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",8],[11,"margin","","",8],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",9],[11,"g1","","",9],[11,"m2","","",9],[11,"g2","","",9],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",10],[11,"g1","","",10],[11,"m2","","",10],[11,"g2","","",10],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"g","","",11],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"shapes","","",12],[11,"bvt","","",12],[11,"bvs","","",12],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",13],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",14],[11,"bvs","","",14],[11,"margin","","",14],[11,"vertices","","",14],[11,"indices","","",14],[11,"uvs","","",14],[11,"normals","","",14],[1,"Segment","","A segment geometry."],[11,"margin","","",15],[11,"a","","",15],[11,"b","","",15],[1,"Triangle","","A triangle geometry."],[11,"margin","","",16],[11,"a","","",16],[11,"b","","",16],[11,"c","","",16],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",17],[11,"nupoints","","",17],[11,"nvpoints","","",17],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",18],[11,"v_cache","","",18],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",19],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",20],[0,"geom","","Enum grouping the most useful geometric shapes."],[6,"Geom","ncollide3df64::geom::geom","Trait (that should be) implemented by each geometry supported by `ncollide`."],[9,"duplicate","","Duplicates (clones) this geometry.",21],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries supported by `ncollide`."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",22],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",22],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",22],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",22],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",22],[4,"MeshPrimitive","ncollide3df64::geom",""],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",23],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",23],[0,"ray","ncollide3df64","Ray casting utilities."],[3,"plane_toi_with_ray","ncollide3df64::ray","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[0,"ray","","Traits and structure needed to cast rays."],[1,"Ray","ncollide3df64::ray::ray","A Ray."],[11,"orig","","Starting point of the ray.",24],[11,"dir","","Direction of the ray.",24],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",25],[11,"normal","","The normal at the intersection point.",25],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",25],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",26],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",26],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this geometry and a ray.",26],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",26],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",26],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",26],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\ngeometry and a ray.",26],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",26],[10,"decode","","",24],[10,"encode","","",24],[10,"fmt","","",24],[10,"new","","Creates a new ray starting from `orig` and with the direction `dir`. `dir` must be\nnormalized.",24],[10,"new_with_uvs","","Creates a new `RayIntersection`.",25],[10,"new","","Creates a new `RayIntersection`.",25],[0,"narrow","ncollide3df64","Narrow phases."],[1,"Empty","ncollide3df64::narrow","A collision detector that does nothing."],[11,"dummy","","",27],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",28],[11,"contact","","",28],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",29],[11,"contact","","",29],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",30],[11,"contact","","",30],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",31],[11,"prediction","","",31],[11,"contact","","",31],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",32],[11,"collector","","",32],[11,"prediction","","",32],[11,"sub_detector","","",32],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",33],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",34],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",35],[11,"to_delete","","",35],[11,"interferences","","",35],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",36],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",37],[11,"tree","","",37],[11,"selector","","",37],[11,"prediction","","",37],[11,"contacts","","",37],[11,"points","","",37],[11,"timestamp","","",37],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",38],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide3df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide3df64::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide3df64::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide3df64::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide3df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide3df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide3df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide3df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",39],[9,"translate_by","","Translates each point of this simplex.",39],[9,"add_point","","Adds a point to the simplex.",39],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",39],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",39],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",39],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",39],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",39],[0,"johnson_simplex","ncollide3df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide3df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",40],[11,"points","","",40],[11,"exchange_points","","",40],[11,"determinants","","",40],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",41],[11,"offsets","","",41],[11,"sub_determinants","","",41],[11,"num_determinants","","",41],[11,"num_leaves","","",41],[10,"clone","","",40],[10,"decode","","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",41],[10,"new","","Creates a new, empty, Johnson simplex.",40],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",40],[10,"reset","","",40],[10,"dimension","","",40],[10,"max_sq_len","","",40],[10,"contains_point","","",40],[10,"add_point","","",40],[10,"project_origin_and_reduce","","",40],[10,"project_origin","","",40],[10,"translate_by","","",40],[0,"gjk","ncollide3df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide3df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",42],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",42],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",42],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",42],[10,"decode","","",42],[10,"encode","","",42],[0,"minkowski_sampling","ncollide3df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide3df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide3df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide3df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",43],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",44],[11,"diff_v","","",44],[11,"max_lmd","","",44],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",45],[11,"spread_u","","",45],[11,"spread_v","","",45],[11,"axis_u","","",45],[11,"axis_v","","",45],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",46],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",46],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",46],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",46],[10,"clone","","",47],[10,"new","","Creates a new `YesSirSurfaceSelector`.",47],[10,"set_max_lmd","","",47],[10,"is_flat","","",47],[10,"may_contain_a_closest_point","","",47],[10,"create_test_data","","",47],[10,"clone","","",43],[10,"new","","Creates a new hyperplane-based surface selector.",43],[10,"set_max_lmd","","",43],[10,"is_flat","","",43],[10,"may_contain_a_closest_point","","",43],[10,"create_test_data","","",43],[10,"clone","","",44],[10,"new","","Creates a new tangent-cone based surface detector.",44],[10,"set_max_lmd","","",44],[10,"is_flat","","",44],[10,"may_contain_a_closest_point","","",44],[10,"create_test_data","","",44],[0,"surface_subdivision_tree","ncollide3df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide3df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",48],[11,"value","","",48],[11,"key","","",48],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",49],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",50],[11,"lchild","","",50],[11,"timestamp","","",50],[11,"data","","",50],[11,"surface","","",50],[10,"clone","","",48],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",48],[10,"deref","","",48],[10,"drop","","",48],[10,"new","","Creates a new surface subdivision tree cache.",49],[10,"clear","","Removes everything from this cache.",49],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",49],[10,"new_orphan","","Creates a new tree with no parent nor children.",50],[10,"surface","","The surface contained by this node.",50],[10,"data","","Reference to the data contained by this node.",50],[10,"data_mut","","Mutable reference to the data contained by this node.",50],[10,"timestamp","","The timestamp of this tree node.",50],[10,"set_timestamp","","Sets the timestamp of this tree node.",50],[10,"has_left_child","","Whether or not this node has a left child.",50],[10,"has_right_child","","Whether or not this node has a right child.",50],[10,"right_child","","A copy of this node right child.",50],[10,"left_child","","A copy of this node left child.",50],[10,"right_child_ref","","A reference to this node right child.",50],[10,"left_child_ref","","A reference to this node left child.",50],[10,"set_right_child","","Sets the right child of this node.",50],[10,"set_left_child","","Sets the left child of this node.",50],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",50],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",50],[10,"remove_right_child","","Removes the right child of this node.",50],[10,"remove_left_child","","Removes the left child of this node.",50],[6,"CollisionDetector","ncollide3df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",51],[9,"num_colls","","The number of collision detected during the last update.",51],[9,"colls","","Collects the collisions detected during the last update.",51],[9,"toi","","Computes the time of impact of two objects.",51],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",52],[9,"num_colls","","The number of collision detected during the last update.",52],[9,"colls","","Collects the collisions detected during the last update.",52],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",53],[0,"broad","ncollide3df64","Broad phases."],[1,"NoIdDispatcher","ncollide3df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","The broad phase which does nothing."],[11,"dispatcher","","",54],[11,"pairs","","",54],[11,"objects","","",54],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",55],[11,"sobjects","","",55],[11,"rb2bv","","",55],[11,"pairs","","",55],[11,"dispatcher","","",55],[11,"margin","","",55],[11,"to_update","","",55],[11,"update_off","","",55],[1,"BoundingVolumeProxy","","Association of an object with its loose bounding volume."],[11,"bounding_volume","","The objects loose bounding volume.",56],[11,"body","","The object.",56],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",57],[11,"stree","","",57],[11,"active2bv","","",57],[11,"inactive2bv","","",57],[11,"pairs","","",57],[11,"spairs","","",57],[11,"dispatcher","","",57],[11,"margin","","",57],[11,"collector","","",57],[11,"to_update","","",57],[11,"update_off","","",57],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",58],[9,"remove","","Removes an element from this broad phase.",58],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",58],[9,"update_object","","Updates the collision pairs involving one specific object.",58],[6,"InterferencesBroadPhase","","Broad phase which check for pairwise interferences."],[9,"activate","","Marks and object as active.",59],[9,"deactivate","","Marks and object as inactive.",59],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",59],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",59],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",60],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",61],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",62],[9,"is_valid","","Tells whether a collision between two bodies can occur.",62],[0,"contact","ncollide3df64","Main data structure for contacts."],[1,"Contact","ncollide3df64::contact","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",63],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",63],[11,"normal","","Contact normal",63],[11,"depth","","Penetration depth",63],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"fmt","","",63],[10,"new","","Creates a new contact.",63],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",63],[0,"volumetric","ncollide3df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide3df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",64],[6,"InertiaTensor","","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",65],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",65],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",65],[0,"implicit","ncollide3df64","Definition of support functions."],[3,"cso_support_point","ncollide3df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[0,"implicit","","Traits for support mapping based geometries."],[6,"HasMargin","ncollide3df64::implicit::implicit","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",66],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",68],[0,"partitioning","ncollide3df64","Spatial partitioning tools."],[1,"DBVT","ncollide3df64::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",69],[11,"tree","","",69],[11,"len","","",69],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",70],[11,"center","","The center of this node bounding volume.",70],[11,"object","","An user-defined object.",70],[11,"parent","","This node parent.",70],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",71],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",72],[11,"collector","","",72],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",73],[11,"collector","","",73],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",74],[12,"LeftChildOf","","This leaf is the left child of another node.",74],[12,"Detached","","This leaf is detached from any tree.",74],[2,"BinaryPartition","","Result of a binary partitioning."],[12,"Part","","Result of the partitioning of one element.",75],[12,"Parts","","Result of the partitioning of several elements.",75],[3,"kdtree_partitioner","","Construction function for a kdree."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[9,"visit_leaf","","Visits a leaf.",76],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[10,"visit_leaf_mut","","Visits a leaf.",76],[0,"procedural","ncollide3df64","Procedural mesh generation."],[1,"TriMesh","ncollide3df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",77],[11,"normals","","Coordinates of the mesh normals.",77],[11,"uvs","","Textures coordinates of the mesh.",77],[11,"indices","","Index buffer of the mesh.",77],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",78],[11,"normals","","Coordinates of the polyline normals.",78],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",79],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",79],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle contained on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle contained on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide3df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_circle","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.\nThe created ring is open (the start and end points are not linked together)."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_closed_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide3df64::procedural","Path generation."],[1,"PolylinePattern","ncollide3df64::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",80],[11,"closed","","",80],[11,"last_start_id","","",80],[11,"start_cap","","",80],[11,"end_cap","","",80],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",81],[11,"curr_dir","","",81],[11,"curr_pt_id","","",81],[11,"curr_pt","","",81],[11,"polyline","","",81],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",82],[11,"front_dist_to_head","","",82],[11,"back_dist_to_head","","",82],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",83],[12,"InnerPoint","","A point that is inside of the path currently generated.",83],[12,"EndPoint","","A point that ends the path currently generated.",83],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",83],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",84],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",85],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",86],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",86],[6,"ToTriMesh","ncollide3df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",87],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",88],[0,"utils","ncollide3df64","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide3df64::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide3df64","Data structure utilities."],[0,"pair","ncollide3df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide3df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",89],[11,"second","","second object of the pair",89],[11,"ifirst","","",89],[11,"isecond","","",89],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",90],[10,"decode","","",89],[10,"encode","","",89],[10,"clone","","",89],[10,"new","","Builds a new `Pair`.",89],[10,"eq","","",89],[10,"decode","","",90],[10,"encode","","",90],[10,"new","","Creates a new PairTWHash",90],[10,"hash","","",90],[0,"hash","ncollide3df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide3df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",91],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",92],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",93],[10,"decode","","",91],[10,"encode","","",91],[10,"clone","","",91],[10,"new","","Creates a new UintPairTWHash.",91],[10,"hash","","",91],[10,"decode","","",92],[10,"encode","","",92],[10,"clone","","",92],[10,"new","","Creates a new UintTWHash.",92],[10,"hash","","",92],[0,"hash_map","ncollide3df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide3df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",94],[11,"value","","The value of the entry.",94],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",95],[11,"table","","",95],[11,"mask","","",95],[11,"htable","","",95],[11,"next","","",95],[11,"num_elem","","",95],[11,"max_elem","","",95],[11,"real_max_elem","","",95],[10,"decode","","",94],[10,"encode","","",94],[10,"clone","","",94],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Creates a new hash map.",95],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",95],[10,"elements","","The elements added to this hash map.",95],[10,"elements_mut","","The elements added to this hash map.",95],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",95],[10,"get_and_remove","","Removes an element and returns its value if it existed.",95],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",95],[10,"insert_or_replace","","Inserts or replace an element.",95],[10,"len","","",95],[10,"clear","","",95],[10,"contains_key","","",95],[10,"find","","",95],[10,"insert","","Inserts an element on the hash map.",95],[10,"remove","","Remove an element from the hash map.",95],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",95],[0,"owned_allocation_cache","ncollide3df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide3df64::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",96],[10,"new","","Initializes the cache.",96],[10,"alloc","","Box a value into a potentially already allocated box.",96],[10,"retain","","Retains a box which can be re-used by the `box` method.",96],[10,"clear","","Clears the cache, destroying any stored pointer.",96],[0,"has_uid","ncollide3df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide3df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",97],[10,"uid","std::gc","",98],[10,"uid","alloc::rc","",99],[10,"uid","alloc::arc","",100],[0,"vec_slice","ncollide3df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide3df64::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",101],[11,"length","","",101],[11,"stride","","",101],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",102],[11,"length","","",102],[11,"stride","","",102],[10,"len","","",101],[10,"is_empty","","",101],[10,"len","","",102],[10,"is_empty","","",102],[10,"new","","Creates a new immutable slice.",101],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",101],[10,"get","","Gets the i-th element of the slice.",101],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",101],[10,"new","","Creates a new mutable slice.",102],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",102],[10,"as_slice","","Creates an immutable slice from this mutable slice.",102],[10,"get","","Gets the i-th element of the slice.",102],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",102],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",102],[0,"math","ncollide3df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide3df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."]],"paths":[[1,"BoundingSphere"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"Geom"],[6,"ConcaveGeom"],[6,"MeshElement"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"BoundingVolumeProxy"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[1,"Contact"],[6,"Volumetric"],[6,"InertiaTensor"],[6,"HasMargin"],[6,"Implicit"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"]]};

searchIndex['ncollide2df64'] = {"items":[[0,"","ncollide2df64","ncollide\n========"],[0,"bounding_volume","","Bounding volumes."],[1,"BoundingSphere","ncollide2df64::bounding_volume","A bounding sphere."],[11,"center","","",0],[11,"radius","","",0],[3,"implicit_shape_aabb","","Computes the AABB of an implicit shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"bounding_sphere","","Computes a bounding sphere of the specified set of point."],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",1],[0,"geom","ncollide2df64","Geometric primitives."],[1,"Ball","ncollide2df64::geom","A Ball geometry."],[11,"radius","","",2],[1,"Plane","","Implicit description of a plane."],[11,"normal","","The plane normal.",3],[1,"Cuboid","","Geometry of a box."],[11,"half_extents","","",4],[11,"margin","","",4],[1,"Capsule","","Implicit description of a capsule geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",5],[11,"radius","","",5],[11,"margin","","",5],[1,"Cone","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",6],[11,"radius","","",6],[11,"margin","","",6],[1,"Cylinder","","Implicit description of a cylinder geometry with its principal axis aligned with the `x` axis."],[11,"half_height","","",7],[11,"radius","","",7],[11,"margin","","",7],[1,"Convex","","Set of point assumed to form a convex polytope."],[11,"pts","","",8],[11,"margin","","",8],[1,"MinkowskiSum","","Implicit representation of the Minkowski sum of two geometries."],[11,"m1","","",9],[11,"g1","","",9],[11,"m2","","",9],[11,"g2","","",9],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped geometries."],[11,"m1","","",10],[11,"g1","","",10],[11,"m2","","",10],[11,"g2","","",10],[1,"Reflection","","Implicit representation of the reflection of a geometry."],[11,"g","","",11],[1,"Compound","","A compound geometry with an aabb bounding volume."],[11,"shapes","","",12],[11,"bvt","","",12],[11,"bvs","","",12],[1,"GeomWithMargin","","Extends the wrapped geometry with its margin."],[11,"geom","","",13],[1,"Mesh","","Geometry commonly known as a 2d line strip or a 3d triangle mesh."],[11,"bvt","","",14],[11,"bvs","","",14],[11,"margin","","",14],[11,"vertices","","",14],[11,"indices","","",14],[11,"uvs","","",14],[11,"normals","","",14],[1,"Segment","","A segment geometry."],[11,"margin","","",15],[11,"a","","",15],[11,"b","","",15],[1,"Triangle","","A triangle geometry."],[11,"margin","","",16],[11,"a","","",16],[11,"b","","",16],[11,"c","","",16],[1,"BezierSurface","","Procedural generator of non-rational Bézier surfaces."],[11,"control_points","","",17],[11,"nupoints","","",17],[11,"nvpoints","","",17],[1,"BezierSurfaceEvaluationCache","","Cache used to evaluate a bezier surface at a given parameter."],[11,"u_cache","","",18],[11,"v_cache","","",18],[1,"BezierCurve","","Procedural generator of non-rational Bézier curve."],[11,"control_points","","",19],[1,"BezierCurveEvaluationCache","","Cache used to evaluate a bezier curve at a given parameter."],[11,"cache","","",20],[0,"geom","","Enum grouping the most useful geometric shapes."],[6,"Geom","ncollide2df64::geom::geom","Trait (that should be) implemented by each geometry supported by `ncollide`."],[9,"duplicate","","Duplicates (clones) this geometry.",21],[6,"ConcaveGeom","","Trait implemented by concave, composite geometries supported by `ncollide`."],[9,"map_part_at","","Applies a function to each sub-geometry of this concave geometry.",22],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-geometry of this concave\ngeometry.",22],[9,"approx_interferences_with_aabb","","Computes the indices of every sub-geometry which might intersect a given AABB.",22],[9,"approx_interferences_with_ray","","Computes the indices of every sub-geometry which might intersect a given Ray.",22],[9,"aabb_at","","Gets the AABB of the geometry identified by the index `i`.",22],[4,"MeshPrimitive","ncollide2df64::geom",""],[6,"MeshElement","","Trait implemented by elements usable on the Mesh."],[9,"nvertices","","The number of vertices of this mesh element.",23],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices and the margin.",23],[0,"ray","ncollide2df64","Ray casting utilities."],[3,"plane_toi_with_ray","ncollide2df64::ray","Computes the toi of a ray with a plane described by its center and normal."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a geometry using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[0,"ray","","Traits and structure needed to cast rays."],[1,"Ray","ncollide2df64::ray::ray","A Ray."],[11,"orig","","Starting point of the ray.",24],[11,"dir","","Direction of the ray.",24],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",25],[11,"normal","","The normal at the intersection point.",25],[6,"RayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this geometry and a ray",26],[9,"toi_and_normal_with_ray","","Computes the intersection point between this geometry and a ray.",26],[10,"intersects_ray","","Tests whether a ray intersects this geometry.",26],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform geometry and a ray.",26],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed geometry and a ray.",26],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed geometry.",26],[10,"decode","","",24],[10,"encode","","",24],[10,"fmt","","",24],[10,"new","","Creates a new ray starting from `orig` and with the direction `dir`. `dir` must be\nnormalized.",24],[10,"new","","Creates a new `RayIntersection`.",25],[0,"narrow","ncollide2df64","Narrow phases."],[1,"Empty","ncollide2df64::narrow","A collision detector that does nothing."],[11,"dummy","","",27],[1,"BallBall","","Collision detector between two balls."],[11,"prediction","","",28],[11,"contact","","",28],[1,"PlaneImplicit","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",29],[11,"contact","","",29],[1,"ImplicitPlane","","Collision detector between a plane and a geometry implementing the `Implicit` trait."],[11,"prediction","","",30],[11,"contact","","",30],[1,"ImplicitImplicit","","Persistent collision detector between two shapes having a support mapping function."],[11,"simplex","","",31],[11,"prediction","","",31],[11,"contact","","",31],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[11,"contacts","","",32],[11,"collector","","",32],[11,"prediction","","",32],[11,"sub_detector","","",32],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[11,"sub_detector","","",33],[1,"GeomGeomDispatcher","","Collision dispatcher between two `~Geom`."],[11,"constructors","","",34],[1,"ConcaveGeomGeom","","Collision detector between a concave geometry and another geometry."],[11,"sub_detectors","","",35],[11,"to_delete","","",35],[11,"interferences","","",35],[1,"GeomConcaveGeom","","Collision detector between a geometry and a concave geometry."],[11,"sub_detector","","",36],[1,"ConcaveGeomGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `ConcaveGeomGeom`\ncollision detector."],[1,"GeomConcaveGeomFactory","","Structure implementing `CollisionDetectorFactory` in order to create a new `GeomConcaveGeom`\ncollision detector."],[1,"BallBezierSurface","","Collision detector between a ball and a bezier surface."],[11,"cache","","",37],[11,"tree","","",37],[11,"selector","","",37],[11,"prediction","","",37],[11,"contacts","","",37],[11,"points","","",37],[11,"timestamp","","",37],[1,"BezierSurfaceBall","","Collision detector between a bezier surface and a ball."],[11,"detector","","",38],[0,"toi","","Functions to compute the time of impact between two geometries."],[3,"toi","ncollide2df64::narrow::toi","Computes the Time Of Impact of two balls."],[3,"toi","","Computes the Time Of Impact of a geometry and a plane."],[3,"toi","","Computes the Time Of Impact of two geometries."],[0,"collide","ncollide2df64::narrow","Functions to compute one contact point between two geometries."],[3,"collide","ncollide2df64::narrow::collide","Computes the contact point between two balls."],[3,"collide","","Same as `update_collide_plane_implicit_shape` but the existing collision or `None`."],[3,"collide","","Computes a contact point between two implicit geometries."],[0,"closest_points","ncollide2df64::narrow","Functions to compute the closest points between two geometries."],[3,"closest_points","ncollide2df64::narrow::closest_points","Computes the closest points between two balls."],[0,"algorithm","ncollide2df64::narrow","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide2df64::narrow::algorithm","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide2df64::narrow::algorithm::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",39],[9,"translate_by","","Translates each point of this simplex.",39],[9,"add_point","","Adds a point to the simplex.",39],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",39],[9,"project_origin","","Projection the origin on the simplex. The simplex itself in unchanged, although it is mutable\nfor optimization purpose.",39],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",39],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",39],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",39],[0,"johnson_simplex","ncollide2df64::narrow::algorithm","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide2df64::narrow::algorithm::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[11,"recursion_template","","",40],[11,"points","","",40],[11,"exchange_points","","",40],[11,"determinants","","",40],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[11,"permutation_list","","",41],[11,"offsets","","",41],[11,"sub_determinants","","",41],[11,"num_determinants","","",41],[11,"num_leaves","","",41],[10,"clone","","",40],[10,"decode","","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",41],[10,"new","","Creates a new, empty, Johnson simplex.",40],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",40],[10,"reset","","",40],[10,"dimension","","",40],[10,"max_sq_len","","",40],[10,"contains_point","","",40],[10,"add_point","","",40],[10,"project_origin_and_reduce","","",40],[10,"project_origin","","",40],[10,"translate_by","","",40],[0,"gjk","ncollide2df64::narrow::algorithm","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide2df64::narrow::algorithm::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",42],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",42],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",42],[3,"closest_points","","Computes the closest points between two convex geometries unsing the GJK algorithm."],[3,"closest_points_without_margin","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"closest_points_without_margin_with_max_dist","","Computes the closest points between two convex geometries without their margins unsing the GJK\nalgorithm."],[3,"project_origin","","Projects the origin on a geometry unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a geometry using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[10,"clone","","",42],[10,"decode","","",42],[10,"encode","","",42],[0,"minkowski_sampling","ncollide2df64::narrow::algorithm","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide2df64::narrow::algorithm::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[0,"surface_selector","ncollide2df64::narrow","Heuristics to select surface containing the projection of a point."],[1,"YesSirSurfaceSelector","ncollide2df64::narrow::surface_selector","A selector that does not filter out any surface."],[1,"HyperPlaneSurfaceSelector","","A selector that tries to project the point on one of the extremal point of the surface."],[11,"max_lmd","","",43],[1,"TangentConesSurfaceSelector","","A selector that tests the orthogonality condition using the surface tangent cone."],[11,"diff_u","","",44],[11,"diff_v","","",44],[11,"max_lmd","","",44],[1,"TangentConesSurfaceSelectorTestData","","Data used by the `TangentconesSurfaceSelector` to test orthogonality and flatness."],[11,"bounding_sphere","","",45],[11,"spread_u","","",45],[11,"spread_v","","",45],[11,"axis_u","","",45],[11,"axis_v","","",45],[6,"SurfaceSelector","","Trait implemented by the heristics for surface selection during collision detection."],[9,"set_max_lmd","","Sets the maximum local minimal distance.",46],[9,"is_flat","","Tells whether a surface is flat enough to run a numerical resolution algorithm.",46],[9,"may_contain_a_closest_point","","Tells whether a surface might contain a closest point or not.",46],[9,"create_test_data","","Allocates data used to test flatnass and closest point containment.",46],[10,"clone","","",47],[10,"new","","Creates a new `YesSirSurfaceSelector`.",47],[10,"set_max_lmd","","",47],[10,"is_flat","","",47],[10,"may_contain_a_closest_point","","",47],[10,"create_test_data","","",47],[10,"clone","","",43],[10,"new","","Creates a new hyperplane-based surface selector.",43],[10,"set_max_lmd","","",43],[10,"is_flat","","",43],[10,"may_contain_a_closest_point","","",43],[10,"create_test_data","","",43],[10,"clone","","",44],[10,"new","","Creates a new tangent-cone based surface detector.",44],[10,"set_max_lmd","","",44],[10,"is_flat","","",44],[10,"may_contain_a_closest_point","","",44],[10,"create_test_data","","",44],[0,"surface_subdivision_tree","ncollide2df64::narrow","Tree used to cache subdivisions of surfaces."],[1,"SurfaceSubdivisionTreeRef","ncollide2df64::narrow::surface_subdivision_tree","A referenece to an element of the subdivision cache."],[11,"parent_cache","","",48],[11,"value","","",48],[11,"key","","",48],[1,"SurfaceSubdivisionTreeCache","","A cache that keeps track of parametric surface subdivision trees."],[11,"cache","","",49],[1,"SurfaceSubdivisionTree","","A shareable binary tree with a pointer to its parent."],[11,"rchild","","",50],[11,"lchild","","",50],[11,"timestamp","","",50],[11,"data","","",50],[11,"surface","","",50],[10,"clone","","",48],[10,"is_the_subdivision_tree_of","","Tests if this references the subdivision tree of the bézier surface `b`.",48],[10,"deref","","",48],[10,"drop","","",48],[10,"new","","Creates a new surface subdivision tree cache.",49],[10,"clear","","Removes everything from this cache.",49],[10,"find_or_insert_with","","Gets from the cache `cache`, the subdivision tree for the surface `b`.",49],[10,"new_orphan","","Creates a new tree with no parent nor children.",50],[10,"surface","","The surface contained by this node.",50],[10,"data","","Reference to the data contained by this node.",50],[10,"data_mut","","Mutable reference to the data contained by this node.",50],[10,"timestamp","","The timestamp of this tree node.",50],[10,"set_timestamp","","Sets the timestamp of this tree node.",50],[10,"has_left_child","","Whether or not this node has a left child.",50],[10,"has_right_child","","Whether or not this node has a right child.",50],[10,"right_child","","A copy of this node right child.",50],[10,"left_child","","A copy of this node left child.",50],[10,"right_child_ref","","A reference to this node right child.",50],[10,"left_child_ref","","A reference to this node left child.",50],[10,"set_right_child","","Sets the right child of this node.",50],[10,"set_left_child","","Sets the left child of this node.",50],[10,"is_right_child","","Returns `true` if `child` is the right child of this node.",50],[10,"is_left_child","","Returns `true` if `child` is the left child of this node.",50],[10,"remove_right_child","","Removes the right child of this node.",50],[10,"remove_left_child","","Removes the left child of this node.",50],[6,"CollisionDetector","ncollide2df64::narrow","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",51],[9,"num_colls","","The number of collision detected during the last update.",51],[9,"colls","","Collects the collisions detected during the last update.",51],[9,"toi","","Computes the time of impact of two objects.",51],[6,"DynamicCollisionDetector","","Trait to be implemented by collision detector using dynamic dispatch."],[6,"GeomGeomCollisionDetector","","Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",52],[9,"num_colls","","The number of collision detected during the last update.",52],[9,"colls","","Collects the collisions detected during the last update.",52],[6,"CollisionDetectorFactory","","Trait of structures able do build a new collision detector."],[9,"build","","Builds a new collision detector.",53],[0,"broad","ncollide2df64","Broad phases."],[1,"NoIdDispatcher","ncollide2df64::broad","Dispatcher which disallows dispatches between identical pointers."],[1,"BruteForceBroadPhase","","The broad phase which does nothing."],[11,"dispatcher","","",54],[11,"pairs","","",54],[11,"objects","","",54],[1,"BruteForceBoundingVolumeBroadPhase","","Broad phase with quadratic complexity but sped up using loose bounding volumes."],[11,"objects","","",55],[11,"sobjects","","",55],[11,"rb2bv","","",55],[11,"pairs","","",55],[11,"dispatcher","","",55],[11,"margin","","",55],[11,"to_update","","",55],[11,"update_off","","",55],[1,"BoundingVolumeProxy","","Association of an object with its loose bounding volume."],[11,"bounding_volume","","The objects loose bounding volume.",56],[11,"body","","The object.",56],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[11,"tree","","",57],[11,"stree","","",57],[11,"active2bv","","",57],[11,"inactive2bv","","",57],[11,"pairs","","",57],[11,"spairs","","",57],[11,"dispatcher","","",57],[11,"margin","","",57],[11,"collector","","",57],[11,"to_update","","",57],[11,"update_off","","",57],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"add","","Adds an element to this broad phase.",58],[9,"remove","","Removes an element from this broad phase.",58],[9,"update","","Updates the collision pairs based on the objects bounding volumes.",58],[9,"update_object","","Updates the collision pairs involving one specific object.",58],[6,"InterferencesBroadPhase","","Broad phase which check for pairwise interferences."],[9,"activate","","Marks and object as active.",59],[9,"deactivate","","Marks and object as inactive.",59],[9,"for_each_pair","","Execute a function on each interference detected by the broad phase.",59],[9,"for_each_pair_mut","","Execute a function on each interference detected by the broad phase.",59],[6,"BoundingVolumeBroadPhase","","Trait of broad phases working with bounding volume."],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",60],[6,"RayCastBroadPhase","","Traits of broad phase able to run fast ray-cast queries."],[9,"interferences_with_ray","","Collects every object which might intersect a ray.",61],[6,"Dispatcher","","Trait of dispatcher."],[9,"dispatch","","Deduce the narrow phase from two bodies.",62],[9,"is_valid","","Tells whether a collision between two bodies can occur.",62],[0,"contact","ncollide2df64","Main data structure for contacts."],[1,"Contact","ncollide2df64::contact","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",63],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",63],[11,"normal","","Contact normal",63],[11,"depth","","Penetration depth",63],[10,"decode","","",63],[10,"encode","","",63],[10,"clone","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"fmt","","",63],[10,"new","","Creates a new contact.",63],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",63],[0,"volumetric","ncollide2df64","Volume and inertia tensor computation."],[3,"ball_volume","ncollide2df64::volumetric","Computes the volume of a ball."],[3,"cuboid_volume","","Computes the volume of a cuboid."],[3,"cone_volume","","Computes the volume of a cone."],[3,"capsule_volume","","Computes the volume of a capsule."],[3,"cylinder_volume","","Computes the volume of a cylinder."],[6,"Volumetric","","Trait to be implemented by objects which have a mass, a center of mass, and an inverse\ninertia tensor."],[9,"mass_properties","","Given a density, this computes the mass, center of mass, and inertia tensor of this object.",64],[6,"InertiaTensor","","Trait to be implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",65],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",65],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",65],[0,"implicit","ncollide2df64","Definition of support functions."],[3,"cso_support_point","ncollide2df64::implicit","Computes the support point of a CSO on a given direction."],[3,"cso_support_point_without_margin","","Computes the support point of a CSO on a given direction."],[0,"implicit","","Traits for support mapping based geometries."],[6,"HasMargin","ncollide2df64::implicit::implicit","Trait of geometries having a margin."],[9,"margin","","The geometry margin.",66],[6,"Implicit","","Traits of convex geometries representable by a support mapping function."],[10,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[9,"support_point_without_margin","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the geometry point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\ngeometry-dependent. Use `support_point` to sample the complete geometry.\n \n# Arguments:\n * `dir` - the input of the support function. It is not required for it to\n           be normalized.",67],[6,"PreferedSamplingDirections","","Trait of geometries having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this geometry with a given transform.",68],[0,"partitioning","ncollide2df64","Spatial partitioning tools."],[1,"DBVT","ncollide2df64::partitioning","A Dynamic Bounding Volume Tree."],[11,"cache","","",69],[11,"tree","","",69],[11,"len","","",69],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",70],[11,"center","","The center of this node bounding volume.",70],[11,"object","","An user-defined object.",70],[11,"parent","","This node parent.",70],[1,"BVT","","A Boundig Volume Tree."],[11,"tree","","",71],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[11,"ray","","",72],[11,"collector","","",72],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[11,"bv","","",73],[11,"collector","","",73],[2,"DBVTLeafState","","State of a leaf."],[12,"RightChildOf","","This leaf is the right child of another node.",74],[12,"LeftChildOf","","This leaf is the left child of another node.",74],[12,"Detached","","This leaf is detached from any tree.",74],[2,"BinaryPartition","","Result of a binary partitioning."],[12,"Part","","Result of the partitioning of one element.",75],[12,"Parts","","Result of the partitioning of several elements.",75],[3,"kdtree_partitioner","","Construction function for a kdree."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[9,"visit_leaf","","Visits a leaf.",76],[10,"visit_internal_mut","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",76],[10,"visit_leaf_mut","","Visits a leaf.",76],[0,"procedural","ncollide2df64","Procedural mesh generation."],[1,"TriMesh","ncollide2df64::procedural","Geometric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",77],[11,"normals","","Coordinates of the mesh normals.",77],[11,"uvs","","Textures coordinates of the mesh.",77],[11,"indices","","Index buffer of the mesh.",77],[1,"Polyline","","Geometric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",78],[11,"normals","","Coordinates of the polyline normals.",78],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"UnifiedIndexBuffer","","The vertex, normal, and uvs share the same indices.",79],[12,"SplitIndexBuffer","","The vertex, normal, and uvs have different indices.",79],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"rational_bezier_surface","","Given a set of weighted control points, generates a rational Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"rational_bezier_curve","","Given a set of control points, generates a rational Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cube","","Generates a cube geometry with a split index buffer."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle contained on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle contained on the `(x,y)` plane."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide2df64::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_circle","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization.\nThe created ring is open (the start and end points are not linked together)."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_closed_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[0,"path","ncollide2df64::procedural","Path generation."],[1,"PolylinePattern","ncollide2df64::procedural::path","A pattern composed of polyline and two caps."],[11,"pattern","","",80],[11,"closed","","",80],[11,"last_start_id","","",80],[11,"start_cap","","",80],[11,"end_cap","","",80],[1,"PolylinePath","","A path with its sample points given by a polyline."],[11,"curr_len","","",81],[11,"curr_dir","","",81],[11,"curr_pt_id","","",81],[11,"curr_pt","","",81],[11,"polyline","","",81],[1,"ArrowheadCap","","A cap that looks like an arrow."],[11,"radius_scale","","",82],[11,"front_dist_to_head","","",82],[11,"back_dist_to_head","","",82],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",83],[12,"InnerPoint","","A point that is inside of the path currently generated.",83],[12,"EndPoint","","A point that ends the path currently generated.",83],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",83],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",84],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",85],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",86],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",86],[6,"ToTriMesh","ncollide2df64::procedural","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this geometry.",87],[6,"ToPolyline","","Trait implemented by geometries that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this geometry.",88],[0,"utils","ncollide2df64","Miscelaneous, unsorted generic geometric utilities."],[3,"center","ncollide2df64::utils","Computes the center of a set of point."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[0,"data","ncollide2df64","Data structure utilities."],[0,"pair","ncollide2df64::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide2df64::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",89],[11,"second","","second object of the pair",89],[11,"ifirst","","",89],[11,"isecond","","",89],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[11,"unused","","",90],[10,"decode","","",89],[10,"encode","","",89],[10,"clone","","",89],[10,"new","","Builds a new `Pair`.",89],[10,"eq","","",89],[10,"decode","","",90],[10,"encode","","",90],[10,"new","","Creates a new PairTWHash",90],[10,"hash","","",90],[0,"hash","ncollide2df64::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide2df64::data::hash","Hash function for pairs of `uint`, using the Tomas Wang hash."],[11,"unused","","",91],[1,"UintTWHash","","Hash function for `uint`."],[11,"unused","","",92],[3,"key_from_pair","","Combines two `uint` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",93],[10,"decode","","",91],[10,"encode","","",91],[10,"clone","","",91],[10,"new","","Creates a new UintPairTWHash.",91],[10,"hash","","",91],[10,"decode","","",92],[10,"encode","","",92],[10,"clone","","",92],[10,"new","","Creates a new UintTWHash.",92],[10,"hash","","",92],[0,"hash_map","ncollide2df64::data","An hash map with a customizable hash function."],[1,"Entry","ncollide2df64::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",94],[11,"value","","The value of the entry.",94],[1,"HashMap","","Alternative implementation of `HashMap`."],[11,"hash","","",95],[11,"table","","",95],[11,"mask","","",95],[11,"htable","","",95],[11,"next","","",95],[11,"num_elem","","",95],[11,"max_elem","","",95],[11,"real_max_elem","","",95],[10,"decode","","",94],[10,"encode","","",94],[10,"clone","","",94],[10,"decode","","",95],[10,"encode","","",95],[10,"clone","","",95],[10,"new","","Creates a new hash map.",95],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",95],[10,"elements","","The elements added to this hash map.",95],[10,"elements_mut","","The elements added to this hash map.",95],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",95],[10,"get_and_remove","","Removes an element and returns its value if it existed.",95],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",95],[10,"insert_or_replace","","Inserts or replace an element.",95],[10,"len","","",95],[10,"clear","","",95],[10,"contains_key","","",95],[10,"find","","",95],[10,"insert","","Inserts an element on the hash map.",95],[10,"remove","","Remove an element from the hash map.",95],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",95],[0,"owned_allocation_cache","ncollide2df64::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide2df64::data::owned_allocation_cache","Cache for owned objects."],[11,"cache","","",96],[10,"new","","Initializes the cache.",96],[10,"alloc","","Box a value into a potentially already allocated box.",96],[10,"retain","","Retains a box which can be re-used by the `box` method.",96],[10,"clear","","Clears the cache, destroying any stored pointer.",96],[0,"has_uid","ncollide2df64::data","Objects with an unique identifier."],[6,"HasUid","ncollide2df64::data::has_uid","Trait of objects having an unique identifier."],[9,"uid","","An unique identifier. It should be O(1).",97],[10,"uid","std::gc","",98],[10,"uid","alloc::rc","",99],[10,"uid","alloc::arc","",100],[0,"vec_slice","ncollide2df64::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide2df64::data::vec_slice","A vector slice with a specific length and stride."],[11,"data","","",101],[11,"length","","",101],[11,"stride","","",101],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[11,"data","","",102],[11,"length","","",102],[11,"stride","","",102],[10,"len","","",101],[10,"is_empty","","",101],[10,"len","","",102],[10,"is_empty","","",102],[10,"new","","Creates a new immutable slice.",101],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",101],[10,"get","","Gets the i-th element of the slice.",101],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",101],[10,"new","","Creates a new mutable slice.",102],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",102],[10,"as_slice","","Creates an immutable slice from this mutable slice.",102],[10,"get","","Gets the i-th element of the slice.",102],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"unsafe_get","","Gets the i-th element of the slice without bound-checking.",102],[10,"unsafe_get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",102],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",102],[0,"math","ncollide2df64","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","ncollide2df64::math","The scalar type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."]],"paths":[[1,"BoundingSphere"],[6,"HasBoundingSphere"],[1,"Ball"],[1,"Plane"],[1,"Cuboid"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Convex"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Reflection"],[1,"Compound"],[1,"GeomWithMargin"],[1,"Mesh"],[1,"Segment"],[1,"Triangle"],[1,"BezierSurface"],[1,"BezierSurfaceEvaluationCache"],[1,"BezierCurve"],[1,"BezierCurveEvaluationCache"],[6,"Geom"],[6,"ConcaveGeom"],[6,"MeshElement"],[1,"Ray"],[1,"RayIntersection"],[6,"RayCast"],[1,"Empty"],[1,"BallBall"],[1,"PlaneImplicit"],[1,"ImplicitPlane"],[1,"ImplicitImplicit"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"GeomGeomDispatcher"],[1,"ConcaveGeomGeom"],[1,"GeomConcaveGeom"],[1,"BallBezierSurface"],[1,"BezierSurfaceBall"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"HyperPlaneSurfaceSelector"],[1,"TangentConesSurfaceSelector"],[1,"TangentConesSurfaceSelectorTestData"],[6,"SurfaceSelector"],[1,"YesSirSurfaceSelector"],[1,"SurfaceSubdivisionTreeRef"],[1,"SurfaceSubdivisionTreeCache"],[1,"SurfaceSubdivisionTree"],[6,"CollisionDetector"],[6,"GeomGeomCollisionDetector"],[6,"CollisionDetectorFactory"],[1,"BruteForceBroadPhase"],[1,"BruteForceBoundingVolumeBroadPhase"],[1,"BoundingVolumeProxy"],[1,"DBVTBroadPhase"],[6,"BroadPhase"],[6,"InterferencesBroadPhase"],[6,"BoundingVolumeBroadPhase"],[6,"RayCastBroadPhase"],[6,"Dispatcher"],[1,"Contact"],[6,"Volumetric"],[6,"InertiaTensor"],[6,"HasMargin"],[6,"Implicit"],[6,"PreferedSamplingDirections"],[1,"DBVT"],[1,"DBVTLeaf"],[1,"BVT"],[1,"RayInterferencesCollector"],[1,"BoundingVolumeInterferencesCollector"],[2,"DBVTLeafState"],[2,"BinaryPartition"],[6,"BVTVisitor"],[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[1,"PolylinePattern"],[1,"PolylinePath"],[1,"ArrowheadCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"],[6,"ToTriMesh"],[6,"ToPolyline"],[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[6,"HashFun"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[6,"HasUid"],[1,"Gc"],[1,"Rc"],[1,"Arc"],[1,"VecSlice"],[1,"VecSliceMut"]]};

initSearch(searchIndex);
