<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>geom_geom.rs.html -- source</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../../ncollide/main.css">

    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        

        
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class='line-numbers'><span id='1'>  1</span>
<span id='2'>  2</span>
<span id='3'>  3</span>
<span id='4'>  4</span>
<span id='5'>  5</span>
<span id='6'>  6</span>
<span id='7'>  7</span>
<span id='8'>  8</span>
<span id='9'>  9</span>
<span id='10'> 10</span>
<span id='11'> 11</span>
<span id='12'> 12</span>
<span id='13'> 13</span>
<span id='14'> 14</span>
<span id='15'> 15</span>
<span id='16'> 16</span>
<span id='17'> 17</span>
<span id='18'> 18</span>
<span id='19'> 19</span>
<span id='20'> 20</span>
<span id='21'> 21</span>
<span id='22'> 22</span>
<span id='23'> 23</span>
<span id='24'> 24</span>
<span id='25'> 25</span>
<span id='26'> 26</span>
<span id='27'> 27</span>
<span id='28'> 28</span>
<span id='29'> 29</span>
<span id='30'> 30</span>
<span id='31'> 31</span>
<span id='32'> 32</span>
<span id='33'> 33</span>
<span id='34'> 34</span>
<span id='35'> 35</span>
<span id='36'> 36</span>
<span id='37'> 37</span>
<span id='38'> 38</span>
<span id='39'> 39</span>
<span id='40'> 40</span>
<span id='41'> 41</span>
<span id='42'> 42</span>
<span id='43'> 43</span>
<span id='44'> 44</span>
<span id='45'> 45</span>
<span id='46'> 46</span>
<span id='47'> 47</span>
<span id='48'> 48</span>
<span id='49'> 49</span>
<span id='50'> 50</span>
<span id='51'> 51</span>
<span id='52'> 52</span>
<span id='53'> 53</span>
<span id='54'> 54</span>
<span id='55'> 55</span>
<span id='56'> 56</span>
<span id='57'> 57</span>
<span id='58'> 58</span>
<span id='59'> 59</span>
<span id='60'> 60</span>
<span id='61'> 61</span>
<span id='62'> 62</span>
<span id='63'> 63</span>
<span id='64'> 64</span>
<span id='65'> 65</span>
<span id='66'> 66</span>
<span id='67'> 67</span>
<span id='68'> 68</span>
<span id='69'> 69</span>
<span id='70'> 70</span>
<span id='71'> 71</span>
<span id='72'> 72</span>
<span id='73'> 73</span>
<span id='74'> 74</span>
<span id='75'> 75</span>
<span id='76'> 76</span>
<span id='77'> 77</span>
<span id='78'> 78</span>
<span id='79'> 79</span>
<span id='80'> 80</span>
<span id='81'> 81</span>
<span id='82'> 82</span>
<span id='83'> 83</span>
<span id='84'> 84</span>
<span id='85'> 85</span>
<span id='86'> 86</span>
<span id='87'> 87</span>
<span id='88'> 88</span>
<span id='89'> 89</span>
<span id='90'> 90</span>
<span id='91'> 91</span>
<span id='92'> 92</span>
<span id='93'> 93</span>
<span id='94'> 94</span>
<span id='95'> 95</span>
<span id='96'> 96</span>
<span id='97'> 97</span>
<span id='98'> 98</span>
<span id='99'> 99</span>
<span id='100'>100</span>
<span id='101'>101</span>
<span id='102'>102</span>
<span id='103'>103</span>
<span id='104'>104</span>
<span id='105'>105</span>
<span id='106'>106</span>
<span id='107'>107</span>
<span id='108'>108</span>
<span id='109'>109</span>
<span id='110'>110</span>
<span id='111'>111</span>
<span id='112'>112</span>
<span id='113'>113</span>
<span id='114'>114</span>
<span id='115'>115</span>
<span id='116'>116</span>
<span id='117'>117</span>
<span id='118'>118</span>
<span id='119'>119</span>
<span id='120'>120</span>
<span id='121'>121</span>
<span id='122'>122</span>
<span id='123'>123</span>
<span id='124'>124</span>
<span id='125'>125</span>
<span id='126'>126</span>
<span id='127'>127</span>
<span id='128'>128</span>
<span id='129'>129</span>
<span id='130'>130</span>
<span id='131'>131</span>
<span id='132'>132</span>
<span id='133'>133</span>
<span id='134'>134</span>
<span id='135'>135</span>
<span id='136'>136</span>
<span id='137'>137</span>
<span id='138'>138</span>
<span id='139'>139</span>
<span id='140'>140</span>
<span id='141'>141</span>
<span id='142'>142</span>
<span id='143'>143</span>
<span id='144'>144</span>
<span id='145'>145</span>
<span id='146'>146</span>
<span id='147'>147</span>
<span id='148'>148</span>
<span id='149'>149</span>
<span id='150'>150</span>
<span id='151'>151</span>
<span id='152'>152</span>
<span id='153'>153</span>
<span id='154'>154</span>
<span id='155'>155</span>
<span id='156'>156</span>
<span id='157'>157</span>
<span id='158'>158</span>
<span id='159'>159</span>
<span id='160'>160</span>
<span id='161'>161</span>
<span id='162'>162</span>
<span id='163'>163</span>
<span id='164'>164</span>
<span id='165'>165</span>
<span id='166'>166</span>
<span id='167'>167</span>
<span id='168'>168</span>
<span id='169'>169</span>
<span id='170'>170</span>
<span id='171'>171</span>
<span id='172'>172</span>
<span id='173'>173</span>
<span id='174'>174</span>
<span id='175'>175</span>
<span id='176'>176</span>
<span id='177'>177</span>
<span id='178'>178</span>
<span id='179'>179</span>
<span id='180'>180</span>
<span id='181'>181</span>
<span id='182'>182</span>
<span id='183'>183</span>
<span id='184'>184</span>
<span id='185'>185</span>
<span id='186'>186</span>
<span id='187'>187</span>
<span id='188'>188</span>
<span id='189'>189</span>
<span id='190'>190</span>
<span id='191'>191</span>
<span id='192'>192</span>
<span id='193'>193</span>
<span id='194'>194</span>
<span id='195'>195</span>
<span id='196'>196</span>
<span id='197'>197</span>
<span id='198'>198</span>
<span id='199'>199</span>
<span id='200'>200</span>
<span id='201'>201</span>
<span id='202'>202</span>
<span id='203'>203</span>
<span id='204'>204</span>
<span id='205'>205</span>
<span id='206'>206</span>
<span id='207'>207</span>
<span id='208'>208</span>
<span id='209'>209</span>
<span id='210'>210</span>
<span id='211'>211</span>
<span id='212'>212</span>
<span id='213'>213</span>
<span id='214'>214</span>
<span id='215'>215</span>
<span id='216'>216</span>
<span id='217'>217</span>
<span id='218'>218</span>
<span id='219'>219</span>
<span id='220'>220</span>
<span id='221'>221</span>
<span id='222'>222</span>
<span id='223'>223</span>
<span id='224'>224</span>
<span id='225'>225</span>
<span id='226'>226</span>
<span id='227'>227</span>
<span id='228'>228</span>
<span id='229'>229</span>
<span id='230'>230</span>
<span id='231'>231</span>
<span id='232'>232</span>
<span id='233'>233</span>
<span id='234'>234</span>
<span id='235'>235</span>
<span id='236'>236</span>
<span id='237'>237</span>
<span id='238'>238</span>
<span id='239'>239</span>
<span id='240'>240</span>
<span id='241'>241</span>
<span id='242'>242</span>
<span id='243'>243</span>
<span id='244'>244</span>
<span id='245'>245</span>
<span id='246'>246</span>
<span id='247'>247</span>
<span id='248'>248</span>
<span id='249'>249</span>
<span id='250'>250</span>
<span id='251'>251</span>
<span id='252'>252</span>
<span id='253'>253</span>
<span id='254'>254</span>
<span id='255'>255</span>
<span id='256'>256</span>
<span id='257'>257</span>
<span id='258'>258</span>
<span id='259'>259</span>
<span id='260'>260</span>
<span id='261'>261</span>
<span id='262'>262</span>
<span id='263'>263</span>
<span id='264'>264</span>
<span id='265'>265</span>
<span id='266'>266</span>
<span id='267'>267</span>
<span id='268'>268</span>
<span id='269'>269</span>
<span id='270'>270</span>
<span id='271'>271</span>
<span id='272'>272</span>
<span id='273'>273</span>
<span id='274'>274</span>
<span id='275'>275</span>
<span id='276'>276</span>
<span id='277'>277</span>
<span id='278'>278</span>
<span id='279'>279</span>
<span id='280'>280</span>
<span id='281'>281</span>
<span id='282'>282</span>
<span id='283'>283</span>
<span id='284'>284</span>
<span id='285'>285</span>
<span id='286'>286</span>
<span id='287'>287</span>
<span id='288'>288</span>
<span id='289'>289</span>
<span id='290'>290</span>
<span id='291'>291</span>
<span id='292'>292</span>
<span id='293'>293</span>
<span id='294'>294</span>
<span id='295'>295</span>
<span id='296'>296</span>
<span id='297'>297</span>
<span id='298'>298</span>
<span id='299'>299</span>
<span id='300'>300</span>
<span id='301'>301</span>
<span id='302'>302</span>
<span id='303'>303</span>
<span id='304'>304</span>
<span id='305'>305</span>
<span id='306'>306</span>
<span id='307'>307</span>
<span id='308'>308</span>
<span id='309'>309</span>
<span id='310'>310</span>
<span id='311'>311</span>
<span id='312'>312</span>
<span id='313'>313</span>
<span id='314'>314</span>
<span id='315'>315</span>
<span id='316'>316</span>
<span id='317'>317</span>
<span id='318'>318</span>
<span id='319'>319</span>
<span id='320'>320</span>
<span id='321'>321</span>
<span id='322'>322</span>
<span id='323'>323</span>
<span id='324'>324</span>
<span id='325'>325</span>
<span id='326'>326</span>
<span id='327'>327</span>
<span id='328'>328</span>
<span id='329'>329</span>
<span id='330'>330</span>
<span id='331'>331</span>
<span id='332'>332</span>
<span id='333'>333</span>
<span id='334'>334</span>
<span id='335'>335</span>
<span id='336'>336</span>
<span id='337'>337</span>
<span id='338'>338</span>
<span id='339'>339</span>
<span id='340'>340</span>
<span id='341'>341</span>
<span id='342'>342</span>
<span id='343'>343</span>
<span id='344'>344</span>
<span id='345'>345</span>
<span id='346'>346</span>
<span id='347'>347</span>
<span id='348'>348</span>
<span id='349'>349</span>
<span id='350'>350</span>
<span id='351'>351</span>
<span id='352'>352</span>
<span id='353'>353</span>
<span id='354'>354</span>
<span id='355'>355</span>
<span id='356'>356</span>
<span id='357'>357</span>
<span id='358'>358</span>
<span id='359'>359</span>
<span id='360'>360</span>
<span id='361'>361</span>
<span id='362'>362</span>
<span id='363'>363</span>
<span id='364'>364</span>
<span id='365'>365</span>
<span id='366'>366</span>
<span id='367'>367</span>
<span id='368'>368</span>
<span id='369'>369</span>
<span id='370'>370</span>
<span id='371'>371</span>
<span id='372'>372</span>
<span id='373'>373</span>
<span id='374'>374</span>
<span id='375'>375</span>
<span id='376'>376</span>
</pre><pre class='rust'>use std::num::{One, Zero};
use std::unstable::intrinsics::TypeId;
use std::hashmap::HashMap;
use nalgebra::na;
use nalgebra::na::{Cast, Translation, Rotate, Rotation, AbsoluteRotate, Transform,
                   Inv, Vec, AlgebraicVecExt, Cross, Indexable};
use volumetric::InertiaTensor;
use geom::{AnnotatedPoint, Geom, ConcaveGeom};
use geom;
use implicit::Implicit;
use contact::Contact;
use narrow::algorithm::simplex::Simplex;
use narrow::algorithm::johnson_simplex::{JohnsonSimplex, RecursionTemplate};
use narrow::algorithm::minkowski_sampling::PreferedSamplingDirections;
use narrow::{CollisionDetector, ImplicitImplicit, BallBall,
             ImplicitPlane, PlaneImplicit, ConcaveGeomGeomFactory, GeomConcaveGeomFactory};
use OSCMG = narrow::OneShotContactManifoldGenerator;

/// Same as the `CollisionDetector` trait but using dynamic dispatch on the geometries.
pub trait GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt; {
    /// Runs the collision detection on two objects. It is assumed that the same
    /// collision detector (the same structure) is always used with the same
    /// pair of object.
    fn update(&amp;mut self,
              &amp;GeomGeomDispatcher&lt;N, LV, AV, M, II&gt;,
              &amp;M,
              &amp;Geom&lt;N, LV, M, II&gt;,
              &amp;M,
              &amp;Geom&lt;N, LV, M, II&gt;);

    /// The number of collision detected during the last update.
    fn num_colls(&amp;self) -&gt; uint;

    /// Collects the collisions detected during the last update.
    fn colls(&amp;self, &amp;mut ~[Contact&lt;N, LV&gt;]);
}

/// Trait to be implemented by collision detector using dynamic dispatch.
/// This is used to know the exact type of the geometries.
pub trait DynamicCollisionDetector&lt;N, LV, AV, M, II, G1, G2&gt;: GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt; { }

#[deriving(Clone)]
struct DetectorWithoutRedispatch&lt;D&gt; {
    detector: D
}

impl&lt;D&gt; DetectorWithoutRedispatch&lt;D&gt; {
    pub fn new(d: D) -&gt; DetectorWithoutRedispatch&lt;D&gt; {
        DetectorWithoutRedispatch {
            detector: d
        }
    }
}

impl&lt;D: CollisionDetector&lt;N, V, M, G1, G2&gt;, N, V, M, G1, G2&gt;
CollisionDetector&lt;N, V, M, G1, G2&gt; for DetectorWithoutRedispatch&lt;D&gt; {
    fn update(&amp;mut self, _: &amp;M, _: &amp;G1, _: &amp;M, _: &amp;G2) { unreachable!() }
    fn num_colls(&amp;self) -&gt; uint { unreachable!() }
    fn colls(&amp;self, _: &amp;mut ~[Contact&lt;N, V&gt;]) { unreachable!() }
    fn toi(_: Option&lt;DetectorWithoutRedispatch&lt;D&gt;&gt;, _: &amp;M, _: &amp;V, _: &amp;N, _: &amp;G1, _: &amp;M, _: &amp;G2) -&gt; Option&lt;N&gt; {
        unreachable!()
    }
}

impl&lt;D: CollisionDetector&lt;N, LV, M, G1, G2&gt;, N, LV, AV, M, II, G1, G2&gt;
DynamicCollisionDetector&lt;N, LV, AV, M, II, G1, G2&gt; for DetectorWithoutRedispatch&lt;D&gt; { }

impl&lt;D: CollisionDetector&lt;N, LV, M, G1, G2&gt;, N, LV, AV, M, II, G1: &#39;static, G2: &#39;static&gt;
GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt; for DetectorWithoutRedispatch&lt;D&gt; {
    #[inline]
    fn update(&amp;mut self,
              _:  &amp;GeomGeomDispatcher&lt;N, LV, AV, M, II&gt;,
              m1: &amp;M,
              g1: &amp;Geom&lt;N, LV, M, II&gt;,
              m2: &amp;M,
              g2: &amp;Geom&lt;N, LV, M, II&gt;) {
        self.detector.update(
            m1,
            g1.as_ref::&lt;G1&gt;().expect(&quot;Invalid geometry.&quot;),
            m2,
            g2.as_ref::&lt;G2&gt;().expect(&quot;Invalid geometry.&quot;))
    }

    #[inline]
    fn num_colls(&amp;self) -&gt; uint {
        self.detector.num_colls()
    }

    #[inline]
    fn colls(&amp;self, cs: &amp;mut ~[Contact&lt;N, LV&gt;]) {
        self.detector.colls(cs)
    }
}

pub struct GeomGeomDispatcher&lt;N, LV, AV, M, II&gt; {
    priv constructors: HashMap&lt;(TypeId, TypeId), ~CollisionDetectorFactory&lt;N, LV, AV, M, II&gt;&gt;
}

impl&lt;N, LV, AV, M, II&gt; GeomGeomDispatcher&lt;N, LV, AV, M, II&gt; {
    pub fn new_without_default() -&gt; GeomGeomDispatcher&lt;N, LV, AV, M, II&gt; {
        GeomGeomDispatcher {
            constructors: HashMap::new()
        }
    }

    pub fn register_dynamic_detector&lt;G1: &#39;static + Any,
                                     G2: &#39;static + Any,
                                     D:  &#39;static + Send + Clone +
                                         DynamicCollisionDetector&lt;N, LV, AV, M, II, G1, G2&gt;&gt;(
                                     &amp;mut self,
                                     d:   D) {
        let key     = (TypeId::of::&lt;G1&gt;(), TypeId::of::&lt;G2&gt;());
        let factory = ~CollisionDetectorCloner::new(d);
        self.constructors.insert(key, factory as ~CollisionDetectorFactory&lt;N, LV, AV, M, II&gt;);
    }

    pub fn register_detector&lt;G1: &#39;static + Any,
                             G2: &#39;static + Any,
                             D:  &#39;static + Send + CollisionDetector&lt;N, LV, M, G1, G2&gt; + Clone&gt;(
                             &amp;mut self,
                             d:   D) {
        self.register_dynamic_detector(DetectorWithoutRedispatch::new(d));
    }

    pub fn unregister_detector&lt;G1: &#39;static + Any, G2: &#39;static + Any&gt;(&amp;mut self) {
        let key = (TypeId::of::&lt;G1&gt;(), TypeId::of::&lt;G2&gt;());
        self.constructors.remove(&amp;key);
    }

    pub fn dispatch(&amp;self, a: &amp;Geom&lt;N, LV, M, II&gt;, b: &amp;Geom&lt;N, LV, M, II&gt;)
                    -&gt; ~GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt; {
        match self.constructors.find(&amp;(a.get_type_id(), b.get_type_id())) {
            Some(f) =&gt; f.build(),
            None    =&gt; fail!(&quot;Unable to find a collision detector.&quot;)
        }
    }
}

impl&lt;N:  &#39;static + Send + Freeze + ApproxEq&lt;N&gt; + Num + Real + Float + Ord + Cast&lt;f32&gt; + Clone + Algebraic,
     LV: &#39;static + Send + Freeze + AlgebraicVecExt&lt;N&gt; + Cross&lt;AV&gt; + ApproxEq&lt;N&gt; + Translation&lt;LV&gt; +
         Clone + Rotate&lt;LV&gt; + Transform&lt;LV&gt;,
     AV: &#39;static + Clone + Vec&lt;N&gt;,
     M:  &#39;static + Clone + Send + Freeze + Rotation&lt;AV&gt; + Rotate&lt;LV&gt; + Translation&lt;LV&gt; + Transform&lt;LV&gt; +
        AbsoluteRotate&lt;LV&gt; + Mul&lt;M, M&gt; + Inv + One,
     II: Zero + Add&lt;II, II&gt; + InertiaTensor&lt;N, LV, AV, M&gt; + Indexable&lt;(uint, uint), N&gt;&gt;
GeomGeomDispatcher&lt;N, LV, AV, M, II&gt; {
    // FIXME: make this a function which has the simplex and the prediction margin as parameters
    pub fn new() -&gt; GeomGeomDispatcher&lt;N, LV, AV, M, II&gt; {
        let mut res = GeomGeomDispatcher::new_without_default();

        type Simplex  = JohnsonSimplex&lt;N, AnnotatedPoint&lt;LV&gt;&gt;;
        type Self     = GeomGeomDispatcher&lt;N, LV, AV, M, II&gt;;
        type Super    = ~GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt;;

        type Ball     = geom::Ball&lt;N&gt;;
        type Box      = geom::Box&lt;N, LV&gt;;
        type Plane    = geom::Plane&lt;N, LV&gt;;
        type Cone     = geom::Cone&lt;N&gt;;
        type Cylinder = geom::Cylinder&lt;N&gt;;
        type Capsule  = geom::Capsule&lt;N&gt;;
        type Convex   = geom::Convex&lt;N, LV&gt;;
        type Compound = geom::Compound&lt;N, LV, M, II&gt;;
        type Triangle = geom::Triangle&lt;N, LV&gt;;
        type Segment  = geom::Segment&lt;N, LV&gt;;
        type TriangleMesh = geom::Mesh&lt;N, LV, M, II, Triangle&gt;;
        type SegmentStrip = geom::Mesh&lt;N, LV, M, II, Segment&gt;;

        /*
         * Involving a Plane
         */
        let prediction: &amp;N = &amp;na::cast(0.1);

        // Ball vs. Ball
        let bb: BallBall&lt;N, LV, M&gt; = BallBall::new(prediction.clone());
        res.register_detector(bb);

        // Plane vs. Implicit
        res.register_default_plane_implicit_detector::&lt;Ball&gt;(false, prediction);
        res.register_default_plane_implicit_detector::&lt;Box&gt;(true, prediction);
        res.register_default_plane_implicit_detector::&lt;Cone&gt;(true, prediction);
        res.register_default_plane_implicit_detector::&lt;Cylinder&gt;(true, prediction);
        res.register_default_plane_implicit_detector::&lt;Capsule&gt;(true, prediction);
        res.register_default_plane_implicit_detector::&lt;Convex&gt;(true, prediction);
        res.register_default_plane_implicit_detector::&lt;Triangle&gt;(true, prediction);
        res.register_default_plane_implicit_detector::&lt;Segment&gt;(true, prediction);

        // Implicit vs. Implicit
        // NOTE: some pair will be registered twice…
        res.register_default_implicit_detectors::&lt;Box&gt;(true, prediction);
        res.register_default_implicit_detectors::&lt;Cone&gt;(true, prediction);
        res.register_default_implicit_detectors::&lt;Cylinder&gt;(true, prediction);
        res.register_default_implicit_detectors::&lt;Capsule&gt;(true, prediction);
        res.register_default_implicit_detectors::&lt;Convex&gt;(true, prediction);
        res.register_default_implicit_detectors::&lt;Triangle&gt;(true, prediction);
        res.register_default_implicit_detectors::&lt;Segment&gt;(true, prediction);

        // FIXME: refactor the three following blocks?
        // Compound vs. Other
        res.register_default_concave_geom_geom_detector::&lt;Compound, Plane&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Ball&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Box&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Cone&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Cylinder&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Capsule&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Convex&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Triangle&gt;();
        res.register_default_concave_geom_geom_detector::&lt;Compound, Segment&gt;();

        // TriangleMesh vs. Other
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Plane&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Ball&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Box&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Cone&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Cylinder&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Capsule&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Convex&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Triangle&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Segment&gt;();

        // SegmentStrip vs. Other
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Plane&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Ball&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Box&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Cone&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Cylinder&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Capsule&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Convex&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Triangle&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Segment&gt;();

        // FIXME: implement a ConcaveGeomConcaveGeom detector?
        res.register_default_concave_geom_geom_detector::&lt;Compound, Compound&gt;();
        res.register_default_concave_geom_geom_detector::&lt;TriangleMesh, Compound&gt;();
        res.register_default_concave_geom_geom_detector::&lt;SegmentStrip, Compound&gt;();

        res
    }

    pub fn register_default_plane_implicit_detector&lt;I: &#39;static + Implicit&lt;N, LV, M&gt;&gt;(
                                                    &amp;mut self,
                                                    generate_manifold: bool,
                                                    prediction:        &amp;N) {
        let p = if generate_manifold { na::zero() } else { prediction.clone() };

        type IP    = ImplicitPlane&lt;N, LV, M, I&gt;;
        let d1: IP = ImplicitPlane::new(p.clone());

        type PI    = PlaneImplicit&lt;N, LV, M, I&gt;;
        let d2: PI = PlaneImplicit::new(p.clone());

        if generate_manifold {
            self.register_detector_with_contact_manifold_generator(d1, prediction);
            self.register_detector_with_contact_manifold_generator(d2, prediction);
        }
        else {
            self.register_detector(d1);
            self.register_detector(d2);
        }
    }

    pub fn register_default_implicit_implicit_detector&lt;G1: &#39;static            +
                                                           Implicit&lt;N, LV, M&gt; +
                                                           PreferedSamplingDirections&lt;LV, M&gt;,
                                                       G2: &#39;static            +
                                                           Implicit&lt;N, LV, M&gt; +
                                                           PreferedSamplingDirections&lt;LV, M&gt;,
                                                       S:  Send + Clone + Simplex&lt;N, AnnotatedPoint&lt;LV&gt;&gt;&gt;(
                                                       &amp;mut self,
                                                       generate_manifold: bool,
                                                       prediction:        &amp;N,
                                                       simplex:           &amp;S) {
        let p = if generate_manifold { na::zero() } else { prediction.clone() };

        type I1I2    = ImplicitImplicit&lt;N, LV, S, G1, G2&gt;;
        let d1: I1I2 = ImplicitImplicit::new(p.clone(), simplex.clone());

        type I2I1    = ImplicitImplicit&lt;N, LV, S, G2, G1&gt;;
        let d2: I2I1 = ImplicitImplicit::new(p.clone(), simplex.clone());

        if generate_manifold {
            self.register_detector_with_contact_manifold_generator(d1, prediction);
            self.register_detector_with_contact_manifold_generator(d2, prediction);
        }
        else {
            self.register_detector(d1);
            self.register_detector(d2);
        }
    }

    pub fn register_default_concave_geom_geom_detector&lt;G1: &#39;static + ConcaveGeom&lt;N, LV, M, II&gt;,
                                                       G2: &#39;static + Geom&lt;N, LV, M, II&gt;&gt;(&amp;mut self) {
        type CGG      = ConcaveGeomGeomFactory&lt;N, LV, AV, M, II, G1, G2&gt;;
        let  f1: CGG  = ConcaveGeomGeomFactory;

        type GCG      = GeomConcaveGeomFactory&lt;N, LV, AV, M, II, G2, G1&gt;;
        let  f2: GCG  = GeomConcaveGeomFactory;

        // FIXME: find a way to factorize that?
        let key     = (TypeId::of::&lt;G1&gt;(), TypeId::of::&lt;G2&gt;());
        self.constructors.insert(key, ~f1 as ~CollisionDetectorFactory&lt;N, LV, AV, M, II&gt;);

        let key     = (TypeId::of::&lt;G2&gt;(), TypeId::of::&lt;G1&gt;());
        self.constructors.insert(key, ~f2 as ~CollisionDetectorFactory&lt;N, LV, AV, M, II&gt;);
    }

    pub fn register_detector_with_contact_manifold_generator&lt;G1: &#39;static + Any,
                                                             G2: &#39;static + Any,
                                                             D:  &#39;static + Send +
                                                                 CollisionDetector&lt;N, LV, M, G1, G2&gt; +
                                                                 Clone&gt;(
                                                             &amp;mut self,
                                                             d:          D,
                                                             prediction: &amp;N) {
        type OSCMGD   = OSCMG&lt;D, N, LV, AV, M&gt;;
        let d: OSCMGD = OSCMG::new(prediction.clone(), d);
        self.register_detector(d);
    }

    /*
    pub fn register_default_compound_any_detector&lt;G, S&gt;(&amp;mut self) {
        type CA = CompoundAABBAny&lt;N, LV, M, ~Geom&lt;N, LV, M, II&gt;&gt;;
    }
    */

    pub fn register_default_implicit_detectors&lt;G: &#39;static + Implicit&lt;N, LV, M&gt; + PreferedSamplingDirections&lt;LV, M&gt;&gt;(
                                               &amp;mut self,
                                               generate_manifold: bool,
                                               prediction:        &amp;N) {
        type Simplex  = JohnsonSimplex&lt;N, AnnotatedPoint&lt;LV&gt;&gt;;
        type Ball     = geom::Ball&lt;N&gt;;
        type Box      = geom::Box&lt;N, LV&gt;;
        type Cone     = geom::Cone&lt;N&gt;;
        type Cylinder = geom::Cylinder&lt;N&gt;;
        type Capsule  = geom::Capsule&lt;N&gt;;
        type Convex   = geom::Convex&lt;N, LV&gt;;
        type Triangle = geom::Triangle&lt;N, LV&gt;;
        type Segment  = geom::Segment&lt;N, LV&gt;;

        // Implicit vs. Implicit
        let rt = RecursionTemplate::new(na::dim::&lt;LV&gt;());
        let js = &amp;JohnsonSimplex::new(rt);

        self.register_default_implicit_implicit_detector::&lt;Ball, G, Simplex&gt;(false, prediction, js);
        self.register_default_implicit_implicit_detector::&lt;Box, G, Simplex&gt;(generate_manifold, prediction, js);
        self.register_default_implicit_implicit_detector::&lt;Cone, G, Simplex&gt;(generate_manifold, prediction, js);
        self.register_default_implicit_implicit_detector::&lt;Cylinder, G, Simplex&gt;(generate_manifold, prediction, js);
        self.register_default_implicit_implicit_detector::&lt;Capsule, G, Simplex&gt;(generate_manifold, prediction, js);
        self.register_default_implicit_implicit_detector::&lt;Convex, G, Simplex&gt;(generate_manifold, prediction, js);
        self.register_default_implicit_implicit_detector::&lt;Triangle, G, Simplex&gt;(generate_manifold, prediction, js);
        self.register_default_implicit_implicit_detector::&lt;Segment, G, Simplex&gt;(generate_manifold, prediction, js);
    }
}

// FIXME: rename that GeomGeomCollisionDetectorFactory ?
pub trait CollisionDetectorFactory&lt;N, LV, AV, M, II&gt; : Send + Freeze {
    fn build(&amp;self) -&gt; ~GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt;;
}

pub struct CollisionDetectorCloner&lt;CD&gt; {
    template: CD
}

impl&lt;CD: GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt; + Clone, N, LV, AV, M, II&gt; CollisionDetectorCloner&lt;CD&gt; {
    fn new(detector: CD) -&gt; CollisionDetectorCloner&lt;CD&gt; {
        CollisionDetectorCloner {
            template: detector
        }
    }
}

impl&lt;CD: &#39;static + Send + Freeze + GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt; + Clone, N, LV, AV, M, II&gt;
CollisionDetectorFactory&lt;N, LV, AV, M, II&gt; for CollisionDetectorCloner&lt;CD&gt; {
    fn build(&amp;self) -&gt; ~GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt; {
        ~self.template.clone() as ~GeomGeomCollisionDetector&lt;N, LV, AV, M, II&gt;
    }
}
</pre></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <script>
        var rootPath = "../../../../";
    </script>
    <script src="../../../../ncollide/jquery.js"></script>
    <script src="../../../../ncollide/search-index.js"></script>
    <script src="../../../../ncollide/main.js"></script>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>
</body>
</html>
