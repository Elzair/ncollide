<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>brute_force_bounding_volume_broad_phase.rs.html -- source</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../../ncollide/main.css">

    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        

        
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class='line-numbers'><span id='1'>  1</span>
<span id='2'>  2</span>
<span id='3'>  3</span>
<span id='4'>  4</span>
<span id='5'>  5</span>
<span id='6'>  6</span>
<span id='7'>  7</span>
<span id='8'>  8</span>
<span id='9'>  9</span>
<span id='10'> 10</span>
<span id='11'> 11</span>
<span id='12'> 12</span>
<span id='13'> 13</span>
<span id='14'> 14</span>
<span id='15'> 15</span>
<span id='16'> 16</span>
<span id='17'> 17</span>
<span id='18'> 18</span>
<span id='19'> 19</span>
<span id='20'> 20</span>
<span id='21'> 21</span>
<span id='22'> 22</span>
<span id='23'> 23</span>
<span id='24'> 24</span>
<span id='25'> 25</span>
<span id='26'> 26</span>
<span id='27'> 27</span>
<span id='28'> 28</span>
<span id='29'> 29</span>
<span id='30'> 30</span>
<span id='31'> 31</span>
<span id='32'> 32</span>
<span id='33'> 33</span>
<span id='34'> 34</span>
<span id='35'> 35</span>
<span id='36'> 36</span>
<span id='37'> 37</span>
<span id='38'> 38</span>
<span id='39'> 39</span>
<span id='40'> 40</span>
<span id='41'> 41</span>
<span id='42'> 42</span>
<span id='43'> 43</span>
<span id='44'> 44</span>
<span id='45'> 45</span>
<span id='46'> 46</span>
<span id='47'> 47</span>
<span id='48'> 48</span>
<span id='49'> 49</span>
<span id='50'> 50</span>
<span id='51'> 51</span>
<span id='52'> 52</span>
<span id='53'> 53</span>
<span id='54'> 54</span>
<span id='55'> 55</span>
<span id='56'> 56</span>
<span id='57'> 57</span>
<span id='58'> 58</span>
<span id='59'> 59</span>
<span id='60'> 60</span>
<span id='61'> 61</span>
<span id='62'> 62</span>
<span id='63'> 63</span>
<span id='64'> 64</span>
<span id='65'> 65</span>
<span id='66'> 66</span>
<span id='67'> 67</span>
<span id='68'> 68</span>
<span id='69'> 69</span>
<span id='70'> 70</span>
<span id='71'> 71</span>
<span id='72'> 72</span>
<span id='73'> 73</span>
<span id='74'> 74</span>
<span id='75'> 75</span>
<span id='76'> 76</span>
<span id='77'> 77</span>
<span id='78'> 78</span>
<span id='79'> 79</span>
<span id='80'> 80</span>
<span id='81'> 81</span>
<span id='82'> 82</span>
<span id='83'> 83</span>
<span id='84'> 84</span>
<span id='85'> 85</span>
<span id='86'> 86</span>
<span id='87'> 87</span>
<span id='88'> 88</span>
<span id='89'> 89</span>
<span id='90'> 90</span>
<span id='91'> 91</span>
<span id='92'> 92</span>
<span id='93'> 93</span>
<span id='94'> 94</span>
<span id='95'> 95</span>
<span id='96'> 96</span>
<span id='97'> 97</span>
<span id='98'> 98</span>
<span id='99'> 99</span>
<span id='100'>100</span>
<span id='101'>101</span>
<span id='102'>102</span>
<span id='103'>103</span>
<span id='104'>104</span>
<span id='105'>105</span>
<span id='106'>106</span>
<span id='107'>107</span>
<span id='108'>108</span>
<span id='109'>109</span>
<span id='110'>110</span>
<span id='111'>111</span>
<span id='112'>112</span>
<span id='113'>113</span>
<span id='114'>114</span>
<span id='115'>115</span>
<span id='116'>116</span>
<span id='117'>117</span>
<span id='118'>118</span>
<span id='119'>119</span>
<span id='120'>120</span>
<span id='121'>121</span>
<span id='122'>122</span>
<span id='123'>123</span>
<span id='124'>124</span>
<span id='125'>125</span>
<span id='126'>126</span>
<span id='127'>127</span>
<span id='128'>128</span>
<span id='129'>129</span>
<span id='130'>130</span>
<span id='131'>131</span>
<span id='132'>132</span>
<span id='133'>133</span>
<span id='134'>134</span>
<span id='135'>135</span>
<span id='136'>136</span>
<span id='137'>137</span>
<span id='138'>138</span>
<span id='139'>139</span>
<span id='140'>140</span>
<span id='141'>141</span>
<span id='142'>142</span>
<span id='143'>143</span>
<span id='144'>144</span>
<span id='145'>145</span>
<span id='146'>146</span>
<span id='147'>147</span>
<span id='148'>148</span>
<span id='149'>149</span>
<span id='150'>150</span>
<span id='151'>151</span>
<span id='152'>152</span>
<span id='153'>153</span>
<span id='154'>154</span>
<span id='155'>155</span>
<span id='156'>156</span>
<span id='157'>157</span>
<span id='158'>158</span>
<span id='159'>159</span>
<span id='160'>160</span>
<span id='161'>161</span>
<span id='162'>162</span>
<span id='163'>163</span>
<span id='164'>164</span>
<span id='165'>165</span>
<span id='166'>166</span>
<span id='167'>167</span>
<span id='168'>168</span>
<span id='169'>169</span>
<span id='170'>170</span>
<span id='171'>171</span>
<span id='172'>172</span>
<span id='173'>173</span>
<span id='174'>174</span>
<span id='175'>175</span>
<span id='176'>176</span>
<span id='177'>177</span>
<span id='178'>178</span>
<span id='179'>179</span>
<span id='180'>180</span>
<span id='181'>181</span>
<span id='182'>182</span>
<span id='183'>183</span>
<span id='184'>184</span>
<span id='185'>185</span>
<span id='186'>186</span>
<span id='187'>187</span>
<span id='188'>188</span>
<span id='189'>189</span>
<span id='190'>190</span>
<span id='191'>191</span>
<span id='192'>192</span>
<span id='193'>193</span>
<span id='194'>194</span>
<span id='195'>195</span>
<span id='196'>196</span>
<span id='197'>197</span>
<span id='198'>198</span>
<span id='199'>199</span>
<span id='200'>200</span>
<span id='201'>201</span>
<span id='202'>202</span>
<span id='203'>203</span>
<span id='204'>204</span>
<span id='205'>205</span>
<span id='206'>206</span>
<span id='207'>207</span>
<span id='208'>208</span>
<span id='209'>209</span>
<span id='210'>210</span>
<span id='211'>211</span>
<span id='212'>212</span>
<span id='213'>213</span>
<span id='214'>214</span>
<span id='215'>215</span>
<span id='216'>216</span>
<span id='217'>217</span>
<span id='218'>218</span>
<span id='219'>219</span>
<span id='220'>220</span>
<span id='221'>221</span>
<span id='222'>222</span>
<span id='223'>223</span>
<span id='224'>224</span>
<span id='225'>225</span>
<span id='226'>226</span>
<span id='227'>227</span>
<span id='228'>228</span>
<span id='229'>229</span>
<span id='230'>230</span>
<span id='231'>231</span>
<span id='232'>232</span>
<span id='233'>233</span>
<span id='234'>234</span>
<span id='235'>235</span>
<span id='236'>236</span>
<span id='237'>237</span>
<span id='238'>238</span>
<span id='239'>239</span>
<span id='240'>240</span>
<span id='241'>241</span>
<span id='242'>242</span>
<span id='243'>243</span>
<span id='244'>244</span>
<span id='245'>245</span>
<span id='246'>246</span>
<span id='247'>247</span>
<span id='248'>248</span>
<span id='249'>249</span>
<span id='250'>250</span>
<span id='251'>251</span>
<span id='252'>252</span>
<span id='253'>253</span>
<span id='254'>254</span>
<span id='255'>255</span>
<span id='256'>256</span>
<span id='257'>257</span>
<span id='258'>258</span>
<span id='259'>259</span>
<span id='260'>260</span>
<span id='261'>261</span>
<span id='262'>262</span>
<span id='263'>263</span>
<span id='264'>264</span>
<span id='265'>265</span>
<span id='266'>266</span>
<span id='267'>267</span>
<span id='268'>268</span>
<span id='269'>269</span>
<span id='270'>270</span>
<span id='271'>271</span>
<span id='272'>272</span>
<span id='273'>273</span>
<span id='274'>274</span>
<span id='275'>275</span>
<span id='276'>276</span>
<span id='277'>277</span>
<span id='278'>278</span>
<span id='279'>279</span>
<span id='280'>280</span>
<span id='281'>281</span>
<span id='282'>282</span>
<span id='283'>283</span>
<span id='284'>284</span>
<span id='285'>285</span>
<span id='286'>286</span>
<span id='287'>287</span>
<span id='288'>288</span>
<span id='289'>289</span>
<span id='290'>290</span>
<span id='291'>291</span>
<span id='292'>292</span>
<span id='293'>293</span>
<span id='294'>294</span>
<span id='295'>295</span>
<span id='296'>296</span>
<span id='297'>297</span>
<span id='298'>298</span>
<span id='299'>299</span>
<span id='300'>300</span>
<span id='301'>301</span>
<span id='302'>302</span>
<span id='303'>303</span>
<span id='304'>304</span>
<span id='305'>305</span>
<span id='306'>306</span>
<span id='307'>307</span>
<span id='308'>308</span>
<span id='309'>309</span>
<span id='310'>310</span>
<span id='311'>311</span>
<span id='312'>312</span>
<span id='313'>313</span>
<span id='314'>314</span>
<span id='315'>315</span>
<span id='316'>316</span>
</pre><pre class='rust'>use std::ptr;
use std::util;
use util::hash_map::HashMap;
use util::hash::UintTWHash;
use util::pair::{Pair, PairTWHash};
use broad::Dispatcher;
use bounding_volume::{HasBoundingVolume, LooseBoundingVolume};

/// Association of an object with its loose bounding volume.
pub struct BoundingVolumeProxy&lt;N, B, BV&gt; {
    /// The objects loose bounding volume.
    bounding_volume: BV,
    /// The object.
    body:            @mut B
}

impl&lt;N:  Clone,
     BV: LooseBoundingVolume&lt;N&gt;,
     B:  HasBoundingVolume&lt;BV&gt;&gt;
BoundingVolumeProxy&lt;N, B, BV&gt; {
    /// Builds a new brute force broad phase based on loose bounding volumes.
    ///
    /// # Arguments:
    ///     * `b` - collision dispatcher.
    ///     * `margin` - loosening margin.
    pub fn new(b: @mut B, margin: N) -&gt; BoundingVolumeProxy&lt;N, B, BV&gt; {
        BoundingVolumeProxy {
            bounding_volume: b.bounding_volume().loosened(margin),
            body:            b
        }
    }

    /// Updates this proxy.
    ///
    /// Returns `true` if the stored bounding volume has been changed.
    pub fn update(&amp;mut self, margin: &amp;N) -&gt; bool {
        let mut new_bv = self.body.bounding_volume();

        if !self.bounding_volume.contains(&amp;new_bv) {
            new_bv.loosen(margin.clone());
            self.bounding_volume = new_bv;

            true
        }
        else {
            false
        }
    }
}

/// Broad phase with quadratic complexity but sped up using loose bounding volumes.
///
/// Interference detection is executed only for objects which have their bounding volumes updated.
///
/// Dont use this broad phase. It exists mainly as a transition broad phase between the Brute Force
/// one and the DBVH/SAP based broad phases.
pub struct BruteForceBoundingVolumeBroadPhase&lt;N, B, BV, D, DV&gt; {
    priv objects:    ~[@mut BoundingVolumeProxy&lt;N, B, BV&gt;], // active   objects
    priv sobjects:   ~[@mut BoundingVolumeProxy&lt;N, B, BV&gt;], // inactive objects
    priv rb2bv:      HashMap&lt;uint, uint, UintTWHash&gt;,
    priv pairs:      HashMap&lt;Pair&lt;BoundingVolumeProxy&lt;N, B, BV&gt;&gt;, DV, PairTWHash&gt;, // pair manager
    priv dispatcher: D,
    priv margin:     N,
    priv to_update:  ~[@mut BoundingVolumeProxy&lt;N, B, BV&gt;],
    priv update_off: uint // incremental pairs removal index
}

impl&lt;N:  Clone,
     B:  &#39;static + HasBoundingVolume&lt;BV&gt;,
     BV: &#39;static + LooseBoundingVolume&lt;N&gt;,
     D:  Dispatcher&lt;B, B, DV&gt;,
     DV&gt;
BruteForceBoundingVolumeBroadPhase&lt;N, B, BV, D, DV&gt; {
    /// Creates a new bounding volume based brute force broad phase.
    pub fn new(dispatcher: D, margin: N) -&gt; BruteForceBoundingVolumeBroadPhase&lt;N, B, BV, D, DV&gt; {
        BruteForceBoundingVolumeBroadPhase {
            objects:    ~[],
            sobjects:   ~[],
            to_update:  ~[],
            rb2bv:      HashMap::new(UintTWHash::new()),
            pairs:      HashMap::new(PairTWHash::new()),
            dispatcher: dispatcher,
            update_off: 0,
            margin:     margin
        }
    }

    /// Number of interferences detected by this broad phase.
    pub fn num_interferences(&amp;self) -&gt; uint {
        self.pairs.len()
    }

    /// The pair manager of this broad phase.
    pub fn pairs&lt;&#39;r&gt;(&amp;&#39;r self) -&gt; &amp;&#39;r HashMap&lt;Pair&lt;BoundingVolumeProxy&lt;N, B, BV&gt;&gt;, DV, PairTWHash&gt; {
        &amp;&#39;r self.pairs
    }

    /// The pair manager of this broad phase.
    pub fn pairs_mut&lt;&#39;r&gt;(&amp;&#39;r mut self)
                         -&gt; &amp;&#39;r mut HashMap&lt;Pair&lt;BoundingVolumeProxy&lt;N, B, BV&gt;&gt;, DV, PairTWHash&gt; {
        &amp;&#39;r mut self.pairs
    }

    /// Adds an element to this broad phase.
    pub fn add(&amp;mut self, rb: @mut B) {
        let proxy = @mut BoundingVolumeProxy::new(rb, self.margin.clone());
        self.objects.push(proxy);
        self.to_update.push(proxy);
    }

    /// Removes an element from this broad phase.
    pub fn remove(&amp;mut self, _: @mut B) {
        fail!(&quot;Not yet implemented.&quot;);
    }

    /// Marks and object as active or inactive. The bounding volume of an inactive object is never
    /// updated. Activating/deactivating an already active/inactive objecs leads to undefined
    /// behaviour.
    pub fn set_active(&amp;mut self, b: @mut B, active: bool) {
        let (key, at) =
            match self.rb2bv.find_mut(&amp;(ptr::to_mut_unsafe_ptr(b) as uint)) {
                None    =&gt; fail!(&quot;Unable to change the active state of an unknown object.&quot;),
                Some(i) =&gt; {
                    if active {
                        // remove from sobjects…
                        let proxy  = self.sobjects[*i];
                        let lproxy = self.sobjects.pop();
                        self.sobjects[*i] = lproxy;

                        // … then add to objects
                        self.objects.push(proxy);

                        let mut at = self.objects.len() - 1;

                        util::swap(&amp;mut at, i);

                        (lproxy, at)
                    }
                    else {
                        // remove from objects…
                        let proxy  = self.objects[*i];
                        let lproxy = self.objects.pop();
                        self.objects[*i] = lproxy;

                        // … then add to sobjects
                        self.sobjects.push(proxy);

                        let mut at = self.sobjects.len() - 1;

                        util::swap(&amp;mut at, i);

                        (lproxy, at)
                    }
                }
            };

        self.rb2bv.insert(ptr::to_mut_unsafe_ptr(key) as uint, at);
    }

    /// Updates the collision pairs based on the objects bounding volumes.
    pub fn update(&amp;mut self) {
        let mut new_colls = 0u;

        for &amp;b in self.objects.mut_iter() {
            if b.update(&amp;self.margin) {
                self.to_update.push(b)
            }
        }

        for &amp;b1 in self.to_update.iter() {
            for &amp;b2 in self.objects.iter() {
                if self.dispatcher.is_valid(b1.body, b2.body) {
                    if b2.bounding_volume.intersects(&amp;b1.bounding_volume) {
                        self.pairs.find_or_insert_lazy(
                            Pair::new(b1, b2),
                            || self.dispatcher.dispatch(b1.body, b2.body)
                        );

                        new_colls = new_colls + 1;
                    }
                }
            }
        }

        if new_colls != 0 {
            let len          = self.pairs.len();
            let num_removals = new_colls.clamp(&amp;(len / 10), &amp;len);

            for i in range(self.update_off, self.update_off + num_removals) {
                let id = i % self.pairs.len();

                let remove = {
                    let elts  = self.pairs.elements();
                    let entry = &amp;elts[id];

                    if (!entry.key.first.bounding_volume.intersects(&amp;entry.key.second.bounding_volume)) {
                        true
                    }
                    else {
                        false
                    }
                };

                if remove {
                    self.pairs.remove_elem_at(id);
                }
            }

            self.update_off = (self.update_off + num_removals) % self.pairs.len();
        }

        self.to_update.clear()
    }
}

#[cfg(test)]
mod test {
    use super::BruteForceBoundingVolumeBroadPhase;
    use nalgebra::na::Vec3;
    use geom::Ball;
    use bounding_volume::WithAABB;
    use broad::NoIdDispatcher;

    #[test]
    fn test_bfbv_empty() {
        type Shape = WithAABB&lt;Vec3&lt;f64&gt;, Ball&lt;f64&gt;&gt;;
        let dispatcher: NoIdDispatcher&lt;Shape&gt; = NoIdDispatcher;
        let mut bf     = BruteForceBoundingVolumeBroadPhase::new(dispatcher, 0.2);
        let ball       = Ball::new(0.3);

        for i in range(-10, 10) {
            for j in range(-10, 10) {
                bf.add(@mut WithAABB(Vec3::new(i as f64 * 30.0, j as f64 * 30.0, 0.0), ball));
            }
        }

        bf.update();

        assert_eq!(bf.num_interferences(), 0)
    }

    #[test]
    fn test_bfbv_nbh_collide() {
        type Shape = WithAABB&lt;Vec3&lt;f64&gt;, Ball&lt;f64&gt;&gt;;
        let dispatcher: NoIdDispatcher&lt;Shape&gt; = NoIdDispatcher;
        let mut bf     = BruteForceBoundingVolumeBroadPhase::new(dispatcher, 0.2);
        let ball       = Ball::new(0.3);

        // create a grid
        for i in range(-10, 10) {
            for j in range(-10, 10) {
                bf.add(@mut WithAABB(Vec3::new(i as f64 * 0.9, j as f64 * 0.9, 0.0), ball));
            }
        }

        bf.update();

        assert_eq!(
            bf.num_interferences(),
            (18 * 18 * 8 + // internal rectangles have 8 neighbors
             18 * 4 * 5  + // border (excluding corners) rectangles have 5 neighbors
             4 * 3)        // corners have 3 neighbors
             / 2            // remove all duplicates
        )
    }

    #[test]
    fn test_dbvt_nbh_move_collide() {
        type Shape = WithAABB&lt;Vec3&lt;f64&gt;, Ball&lt;f64&gt;&gt;;
        let dispatcher: NoIdDispatcher&lt;Shape&gt; = NoIdDispatcher;
        let mut bf     = BruteForceBoundingVolumeBroadPhase::new(dispatcher, 0.2);
        let ball       = Ball::new(0.3);

        let mut to_move = ~[];

        // create a grid
        for i in range(-10, 10) {
            for j in range(-10, 10) {
                let to_add = @mut WithAABB(Vec3::new(i as f64 * 0.9, j as f64 * 0.9, 0.0), ball);
                bf.add(to_add);
                to_move.push(to_add);
            }
        }

        for e in to_move.mut_iter() {
            let WithAABB(m, c) = **e;
            **e = WithAABB(Vec3::new(10.0, 10.0, 10.0) + m, c)
        }

        bf.update();

        assert_eq!(
            bf.num_interferences(),
            (18 * 18 * 8 + // internal rectangles have 8 neighbors
             18 * 4 * 5  + // border (excluding corners) rectangles have 5 neighbors
             4 * 3)        // corners have 3 neighbors
            / 2            // remove all duplicates
        )
    }

    #[test]
    fn test_bfbv_quadratic_collide() {
        type Shape = WithAABB&lt;Vec3&lt;f64&gt;, Ball&lt;f64&gt;&gt;;
        let dispatcher: NoIdDispatcher&lt;Shape&gt; = NoIdDispatcher;
        let mut bf     = BruteForceBoundingVolumeBroadPhase::new(dispatcher, 0.2);
        let ball       = Ball::new(0.3);

        400.times(|| {
            bf.add(@mut WithAABB(Vec3::new(0.0, 0.0, 0.0), ball))
        });

        bf.update();

        assert_eq!(bf.num_interferences(), (399 * (399 + 1)) / 2)
    }
}
</pre></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <script>
        var rootPath = "../../../../";
    </script>
    <script src="../../../../ncollide/jquery.js"></script>
    <script src="../../../../ncollide/search-index.js"></script>
    <script src="../../../../ncollide/main.js"></script>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>
</body>
</html>
